
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Vibe
 * 
 */
export type Vibe = $Result.DefaultSelection<Prisma.$VibePayload>
/**
 * Model VibeContributor
 * 
 */
export type VibeContributor = $Result.DefaultSelection<Prisma.$VibeContributorPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model VibeViewer
 * 
 */
export type VibeViewer = $Result.DefaultSelection<Prisma.$VibeViewerPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Draft
 * 
 */
export type Draft = $Result.DefaultSelection<Prisma.$DraftPayload>
/**
 * Model VibeInvite
 * 
 */
export type VibeInvite = $Result.DefaultSelection<Prisma.$VibeInvitePayload>
/**
 * Model MediaFlag
 * 
 */
export type MediaFlag = $Result.DefaultSelection<Prisma.$MediaFlagPayload>
/**
 * Model FeedEvent
 * 
 */
export type FeedEvent = $Result.DefaultSelection<Prisma.$FeedEventPayload>
/**
 * Model SuggestedUser
 * 
 */
export type SuggestedUser = $Result.DefaultSelection<Prisma.$SuggestedUserPayload>
/**
 * Model CityFeedCache
 * 
 */
export type CityFeedCache = $Result.DefaultSelection<Prisma.$CityFeedCachePayload>
/**
 * Model InviteQueue
 * 
 */
export type InviteQueue = $Result.DefaultSelection<Prisma.$InviteQueuePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.vibe`: Exposes CRUD operations for the **Vibe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vibes
    * const vibes = await prisma.vibe.findMany()
    * ```
    */
  get vibe(): Prisma.VibeDelegate<ExtArgs>;

  /**
   * `prisma.vibeContributor`: Exposes CRUD operations for the **VibeContributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VibeContributors
    * const vibeContributors = await prisma.vibeContributor.findMany()
    * ```
    */
  get vibeContributor(): Prisma.VibeContributorDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.vibeViewer`: Exposes CRUD operations for the **VibeViewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VibeViewers
    * const vibeViewers = await prisma.vibeViewer.findMany()
    * ```
    */
  get vibeViewer(): Prisma.VibeViewerDelegate<ExtArgs>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.draft`: Exposes CRUD operations for the **Draft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drafts
    * const drafts = await prisma.draft.findMany()
    * ```
    */
  get draft(): Prisma.DraftDelegate<ExtArgs>;

  /**
   * `prisma.vibeInvite`: Exposes CRUD operations for the **VibeInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VibeInvites
    * const vibeInvites = await prisma.vibeInvite.findMany()
    * ```
    */
  get vibeInvite(): Prisma.VibeInviteDelegate<ExtArgs>;

  /**
   * `prisma.mediaFlag`: Exposes CRUD operations for the **MediaFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaFlags
    * const mediaFlags = await prisma.mediaFlag.findMany()
    * ```
    */
  get mediaFlag(): Prisma.MediaFlagDelegate<ExtArgs>;

  /**
   * `prisma.feedEvent`: Exposes CRUD operations for the **FeedEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedEvents
    * const feedEvents = await prisma.feedEvent.findMany()
    * ```
    */
  get feedEvent(): Prisma.FeedEventDelegate<ExtArgs>;

  /**
   * `prisma.suggestedUser`: Exposes CRUD operations for the **SuggestedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuggestedUsers
    * const suggestedUsers = await prisma.suggestedUser.findMany()
    * ```
    */
  get suggestedUser(): Prisma.SuggestedUserDelegate<ExtArgs>;

  /**
   * `prisma.cityFeedCache`: Exposes CRUD operations for the **CityFeedCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CityFeedCaches
    * const cityFeedCaches = await prisma.cityFeedCache.findMany()
    * ```
    */
  get cityFeedCache(): Prisma.CityFeedCacheDelegate<ExtArgs>;

  /**
   * `prisma.inviteQueue`: Exposes CRUD operations for the **InviteQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InviteQueues
    * const inviteQueues = await prisma.inviteQueue.findMany()
    * ```
    */
  get inviteQueue(): Prisma.InviteQueueDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Vibe: 'Vibe',
    VibeContributor: 'VibeContributor',
    Media: 'Media',
    VibeViewer: 'VibeViewer',
    Favorite: 'Favorite',
    Notification: 'Notification',
    Draft: 'Draft',
    VibeInvite: 'VibeInvite',
    MediaFlag: 'MediaFlag',
    FeedEvent: 'FeedEvent',
    SuggestedUser: 'SuggestedUser',
    CityFeedCache: 'CityFeedCache',
    InviteQueue: 'InviteQueue',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "vibe" | "vibeContributor" | "media" | "vibeViewer" | "favorite" | "notification" | "draft" | "vibeInvite" | "mediaFlag" | "feedEvent" | "suggestedUser" | "cityFeedCache" | "inviteQueue" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Vibe: {
        payload: Prisma.$VibePayload<ExtArgs>
        fields: Prisma.VibeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VibeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VibeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          findFirst: {
            args: Prisma.VibeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VibeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          findMany: {
            args: Prisma.VibeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>[]
          }
          create: {
            args: Prisma.VibeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          createMany: {
            args: Prisma.VibeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VibeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>[]
          }
          delete: {
            args: Prisma.VibeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          update: {
            args: Prisma.VibeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          deleteMany: {
            args: Prisma.VibeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VibeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VibeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibePayload>
          }
          aggregate: {
            args: Prisma.VibeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVibe>
          }
          groupBy: {
            args: Prisma.VibeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VibeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VibeCountArgs<ExtArgs>
            result: $Utils.Optional<VibeCountAggregateOutputType> | number
          }
        }
      }
      VibeContributor: {
        payload: Prisma.$VibeContributorPayload<ExtArgs>
        fields: Prisma.VibeContributorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VibeContributorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VibeContributorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          findFirst: {
            args: Prisma.VibeContributorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VibeContributorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          findMany: {
            args: Prisma.VibeContributorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>[]
          }
          create: {
            args: Prisma.VibeContributorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          createMany: {
            args: Prisma.VibeContributorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VibeContributorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>[]
          }
          delete: {
            args: Prisma.VibeContributorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          update: {
            args: Prisma.VibeContributorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          deleteMany: {
            args: Prisma.VibeContributorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VibeContributorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VibeContributorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeContributorPayload>
          }
          aggregate: {
            args: Prisma.VibeContributorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVibeContributor>
          }
          groupBy: {
            args: Prisma.VibeContributorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VibeContributorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VibeContributorCountArgs<ExtArgs>
            result: $Utils.Optional<VibeContributorCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      VibeViewer: {
        payload: Prisma.$VibeViewerPayload<ExtArgs>
        fields: Prisma.VibeViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VibeViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VibeViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          findFirst: {
            args: Prisma.VibeViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VibeViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          findMany: {
            args: Prisma.VibeViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>[]
          }
          create: {
            args: Prisma.VibeViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          createMany: {
            args: Prisma.VibeViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VibeViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>[]
          }
          delete: {
            args: Prisma.VibeViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          update: {
            args: Prisma.VibeViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          deleteMany: {
            args: Prisma.VibeViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VibeViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VibeViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeViewerPayload>
          }
          aggregate: {
            args: Prisma.VibeViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVibeViewer>
          }
          groupBy: {
            args: Prisma.VibeViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<VibeViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.VibeViewerCountArgs<ExtArgs>
            result: $Utils.Optional<VibeViewerCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Draft: {
        payload: Prisma.$DraftPayload<ExtArgs>
        fields: Prisma.DraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findFirst: {
            args: Prisma.DraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findMany: {
            args: Prisma.DraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          create: {
            args: Prisma.DraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          createMany: {
            args: Prisma.DraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          delete: {
            args: Prisma.DraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          update: {
            args: Prisma.DraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          deleteMany: {
            args: Prisma.DraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          aggregate: {
            args: Prisma.DraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraft>
          }
          groupBy: {
            args: Prisma.DraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftCountArgs<ExtArgs>
            result: $Utils.Optional<DraftCountAggregateOutputType> | number
          }
        }
      }
      VibeInvite: {
        payload: Prisma.$VibeInvitePayload<ExtArgs>
        fields: Prisma.VibeInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VibeInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VibeInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          findFirst: {
            args: Prisma.VibeInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VibeInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          findMany: {
            args: Prisma.VibeInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>[]
          }
          create: {
            args: Prisma.VibeInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          createMany: {
            args: Prisma.VibeInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VibeInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>[]
          }
          delete: {
            args: Prisma.VibeInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          update: {
            args: Prisma.VibeInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          deleteMany: {
            args: Prisma.VibeInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VibeInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VibeInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VibeInvitePayload>
          }
          aggregate: {
            args: Prisma.VibeInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVibeInvite>
          }
          groupBy: {
            args: Prisma.VibeInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VibeInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VibeInviteCountArgs<ExtArgs>
            result: $Utils.Optional<VibeInviteCountAggregateOutputType> | number
          }
        }
      }
      MediaFlag: {
        payload: Prisma.$MediaFlagPayload<ExtArgs>
        fields: Prisma.MediaFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          findFirst: {
            args: Prisma.MediaFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          findMany: {
            args: Prisma.MediaFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>[]
          }
          create: {
            args: Prisma.MediaFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          createMany: {
            args: Prisma.MediaFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>[]
          }
          delete: {
            args: Prisma.MediaFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          update: {
            args: Prisma.MediaFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          deleteMany: {
            args: Prisma.MediaFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFlagPayload>
          }
          aggregate: {
            args: Prisma.MediaFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaFlag>
          }
          groupBy: {
            args: Prisma.MediaFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaFlagCountArgs<ExtArgs>
            result: $Utils.Optional<MediaFlagCountAggregateOutputType> | number
          }
        }
      }
      FeedEvent: {
        payload: Prisma.$FeedEventPayload<ExtArgs>
        fields: Prisma.FeedEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          findFirst: {
            args: Prisma.FeedEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          findMany: {
            args: Prisma.FeedEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>[]
          }
          create: {
            args: Prisma.FeedEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          createMany: {
            args: Prisma.FeedEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>[]
          }
          delete: {
            args: Prisma.FeedEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          update: {
            args: Prisma.FeedEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          deleteMany: {
            args: Prisma.FeedEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedEventPayload>
          }
          aggregate: {
            args: Prisma.FeedEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedEvent>
          }
          groupBy: {
            args: Prisma.FeedEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedEventCountArgs<ExtArgs>
            result: $Utils.Optional<FeedEventCountAggregateOutputType> | number
          }
        }
      }
      SuggestedUser: {
        payload: Prisma.$SuggestedUserPayload<ExtArgs>
        fields: Prisma.SuggestedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          findFirst: {
            args: Prisma.SuggestedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          findMany: {
            args: Prisma.SuggestedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>[]
          }
          create: {
            args: Prisma.SuggestedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          createMany: {
            args: Prisma.SuggestedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>[]
          }
          delete: {
            args: Prisma.SuggestedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          update: {
            args: Prisma.SuggestedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          deleteMany: {
            args: Prisma.SuggestedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuggestedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestedUserPayload>
          }
          aggregate: {
            args: Prisma.SuggestedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestedUser>
          }
          groupBy: {
            args: Prisma.SuggestedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestedUserCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestedUserCountAggregateOutputType> | number
          }
        }
      }
      CityFeedCache: {
        payload: Prisma.$CityFeedCachePayload<ExtArgs>
        fields: Prisma.CityFeedCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFeedCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFeedCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          findFirst: {
            args: Prisma.CityFeedCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFeedCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          findMany: {
            args: Prisma.CityFeedCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>[]
          }
          create: {
            args: Prisma.CityFeedCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          createMany: {
            args: Prisma.CityFeedCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityFeedCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>[]
          }
          delete: {
            args: Prisma.CityFeedCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          update: {
            args: Prisma.CityFeedCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          deleteMany: {
            args: Prisma.CityFeedCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityFeedCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityFeedCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityFeedCachePayload>
          }
          aggregate: {
            args: Prisma.CityFeedCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCityFeedCache>
          }
          groupBy: {
            args: Prisma.CityFeedCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityFeedCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityFeedCacheCountArgs<ExtArgs>
            result: $Utils.Optional<CityFeedCacheCountAggregateOutputType> | number
          }
        }
      }
      InviteQueue: {
        payload: Prisma.$InviteQueuePayload<ExtArgs>
        fields: Prisma.InviteQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          findFirst: {
            args: Prisma.InviteQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          findMany: {
            args: Prisma.InviteQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>[]
          }
          create: {
            args: Prisma.InviteQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          createMany: {
            args: Prisma.InviteQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>[]
          }
          delete: {
            args: Prisma.InviteQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          update: {
            args: Prisma.InviteQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          deleteMany: {
            args: Prisma.InviteQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteQueuePayload>
          }
          aggregate: {
            args: Prisma.InviteQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInviteQueue>
          }
          groupBy: {
            args: Prisma.InviteQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteQueueCountArgs<ExtArgs>
            result: $Utils.Optional<InviteQueueCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invitedUsers: number
    createdVibes: number
    contributedVibes: number
    media: number
    vibeViews: number
    favorites: number
    notifications: number
    sentNotifications: number
    drafts: number
    invites: number
    sentInvites: number
    suggestedTo: number
    suggestedFrom: number
    feedEvents: number
    inviteQueue: number
    flaggedMedia: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedUsers?: boolean | UserCountOutputTypeCountInvitedUsersArgs
    createdVibes?: boolean | UserCountOutputTypeCountCreatedVibesArgs
    contributedVibes?: boolean | UserCountOutputTypeCountContributedVibesArgs
    media?: boolean | UserCountOutputTypeCountMediaArgs
    vibeViews?: boolean | UserCountOutputTypeCountVibeViewsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    drafts?: boolean | UserCountOutputTypeCountDraftsArgs
    invites?: boolean | UserCountOutputTypeCountInvitesArgs
    sentInvites?: boolean | UserCountOutputTypeCountSentInvitesArgs
    suggestedTo?: boolean | UserCountOutputTypeCountSuggestedToArgs
    suggestedFrom?: boolean | UserCountOutputTypeCountSuggestedFromArgs
    feedEvents?: boolean | UserCountOutputTypeCountFeedEventsArgs
    inviteQueue?: boolean | UserCountOutputTypeCountInviteQueueArgs
    flaggedMedia?: boolean | UserCountOutputTypeCountFlaggedMediaArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedVibesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContributedVibesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeContributorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVibeViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeViewerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeInviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeInviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuggestedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuggestedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInviteQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteQueueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlaggedMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFlagWhereInput
  }


  /**
   * Count Type VibeCountOutputType
   */

  export type VibeCountOutputType = {
    contributors: number
    media: number
    viewers: number
    drafts: number
    invites: number
    notifications: number
    feedEvents: number
    cityFeedCache: number
    inviteQueue: number
  }

  export type VibeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributors?: boolean | VibeCountOutputTypeCountContributorsArgs
    media?: boolean | VibeCountOutputTypeCountMediaArgs
    viewers?: boolean | VibeCountOutputTypeCountViewersArgs
    drafts?: boolean | VibeCountOutputTypeCountDraftsArgs
    invites?: boolean | VibeCountOutputTypeCountInvitesArgs
    notifications?: boolean | VibeCountOutputTypeCountNotificationsArgs
    feedEvents?: boolean | VibeCountOutputTypeCountFeedEventsArgs
    cityFeedCache?: boolean | VibeCountOutputTypeCountCityFeedCacheArgs
    inviteQueue?: boolean | VibeCountOutputTypeCountInviteQueueArgs
  }

  // Custom InputTypes
  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeCountOutputType
     */
    select?: VibeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountContributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeContributorWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeViewerWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeInviteWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountFeedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedEventWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountCityFeedCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityFeedCacheWhereInput
  }

  /**
   * VibeCountOutputType without action
   */
  export type VibeCountOutputTypeCountInviteQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteQueueWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    favoritedBy: number
    flags: number
    notifications: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favoritedBy?: boolean | MediaCountOutputTypeCountFavoritedByArgs
    flags?: boolean | MediaCountOutputTypeCountFlagsArgs
    notifications?: boolean | MediaCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountFavoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFlagWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    phoneNumber: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    bio: string | null
    city: string | null
    profilePicture: string | null
    timeZone: string | null
    joinedAt: Date | null
    inviteCode: string | null
    invitedById: string | null
    isDeleted: boolean | null
    firebaseUid: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    phoneNumber: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    bio: string | null
    city: string | null
    profilePicture: string | null
    timeZone: string | null
    joinedAt: Date | null
    inviteCode: string | null
    invitedById: string | null
    isDeleted: boolean | null
    firebaseUid: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    phoneNumber: number
    email: number
    passwordHash: number
    name: number
    bio: number
    city: number
    profilePicture: number
    timeZone: number
    joinedAt: number
    inviteCode: number
    invitedById: number
    isDeleted: number
    firebaseUid: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    passwordHash?: true
    name?: true
    bio?: true
    city?: true
    profilePicture?: true
    timeZone?: true
    joinedAt?: true
    inviteCode?: true
    invitedById?: true
    isDeleted?: true
    firebaseUid?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    passwordHash?: true
    name?: true
    bio?: true
    city?: true
    profilePicture?: true
    timeZone?: true
    joinedAt?: true
    inviteCode?: true
    invitedById?: true
    isDeleted?: true
    firebaseUid?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    phoneNumber?: true
    email?: true
    passwordHash?: true
    name?: true
    bio?: true
    city?: true
    profilePicture?: true
    timeZone?: true
    joinedAt?: true
    inviteCode?: true
    invitedById?: true
    isDeleted?: true
    firebaseUid?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    phoneNumber: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    bio: string | null
    city: string | null
    profilePicture: string | null
    timeZone: string | null
    joinedAt: Date
    inviteCode: string | null
    invitedById: string | null
    isDeleted: boolean
    firebaseUid: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    bio?: boolean
    city?: boolean
    profilePicture?: boolean
    timeZone?: boolean
    joinedAt?: boolean
    inviteCode?: boolean
    invitedById?: boolean
    isDeleted?: boolean
    firebaseUid?: boolean
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
    invitedUsers?: boolean | User$invitedUsersArgs<ExtArgs>
    createdVibes?: boolean | User$createdVibesArgs<ExtArgs>
    contributedVibes?: boolean | User$contributedVibesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    vibeViews?: boolean | User$vibeViewsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    drafts?: boolean | User$draftsArgs<ExtArgs>
    invites?: boolean | User$invitesArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    suggestedTo?: boolean | User$suggestedToArgs<ExtArgs>
    suggestedFrom?: boolean | User$suggestedFromArgs<ExtArgs>
    feedEvents?: boolean | User$feedEventsArgs<ExtArgs>
    inviteQueue?: boolean | User$inviteQueueArgs<ExtArgs>
    flaggedMedia?: boolean | User$flaggedMediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    bio?: boolean
    city?: boolean
    profilePicture?: boolean
    timeZone?: boolean
    joinedAt?: boolean
    inviteCode?: boolean
    invitedById?: boolean
    isDeleted?: boolean
    firebaseUid?: boolean
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    phoneNumber?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    bio?: boolean
    city?: boolean
    profilePicture?: boolean
    timeZone?: boolean
    joinedAt?: boolean
    inviteCode?: boolean
    invitedById?: boolean
    isDeleted?: boolean
    firebaseUid?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
    invitedUsers?: boolean | User$invitedUsersArgs<ExtArgs>
    createdVibes?: boolean | User$createdVibesArgs<ExtArgs>
    contributedVibes?: boolean | User$contributedVibesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    vibeViews?: boolean | User$vibeViewsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    drafts?: boolean | User$draftsArgs<ExtArgs>
    invites?: boolean | User$invitesArgs<ExtArgs>
    sentInvites?: boolean | User$sentInvitesArgs<ExtArgs>
    suggestedTo?: boolean | User$suggestedToArgs<ExtArgs>
    suggestedFrom?: boolean | User$suggestedFromArgs<ExtArgs>
    feedEvents?: boolean | User$feedEventsArgs<ExtArgs>
    inviteQueue?: boolean | User$inviteQueueArgs<ExtArgs>
    flaggedMedia?: boolean | User$flaggedMediaArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | User$invitedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      invitedBy: Prisma.$UserPayload<ExtArgs> | null
      invitedUsers: Prisma.$UserPayload<ExtArgs>[]
      createdVibes: Prisma.$VibePayload<ExtArgs>[]
      contributedVibes: Prisma.$VibeContributorPayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      vibeViews: Prisma.$VibeViewerPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      drafts: Prisma.$DraftPayload<ExtArgs>[]
      invites: Prisma.$VibeInvitePayload<ExtArgs>[]
      sentInvites: Prisma.$VibeInvitePayload<ExtArgs>[]
      suggestedTo: Prisma.$SuggestedUserPayload<ExtArgs>[]
      suggestedFrom: Prisma.$SuggestedUserPayload<ExtArgs>[]
      feedEvents: Prisma.$FeedEventPayload<ExtArgs>[]
      inviteQueue: Prisma.$InviteQueuePayload<ExtArgs>[]
      flaggedMedia: Prisma.$MediaFlagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      phoneNumber: string | null
      email: string | null
      passwordHash: string | null
      name: string | null
      bio: string | null
      city: string | null
      profilePicture: string | null
      timeZone: string | null
      joinedAt: Date
      inviteCode: string | null
      invitedById: string | null
      isDeleted: boolean
      firebaseUid: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedBy<T extends User$invitedByArgs<ExtArgs> = {}>(args?: Subset<T, User$invitedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invitedUsers<T extends User$invitedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$invitedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    createdVibes<T extends User$createdVibesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdVibesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findMany"> | Null>
    contributedVibes<T extends User$contributedVibesArgs<ExtArgs> = {}>(args?: Subset<T, User$contributedVibesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findMany"> | Null>
    media<T extends User$mediaArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    vibeViews<T extends User$vibeViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$vibeViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findMany"> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    drafts<T extends User$draftsArgs<ExtArgs> = {}>(args?: Subset<T, User$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends User$invitesArgs<ExtArgs> = {}>(args?: Subset<T, User$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findMany"> | Null>
    sentInvites<T extends User$sentInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findMany"> | Null>
    suggestedTo<T extends User$suggestedToArgs<ExtArgs> = {}>(args?: Subset<T, User$suggestedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findMany"> | Null>
    suggestedFrom<T extends User$suggestedFromArgs<ExtArgs> = {}>(args?: Subset<T, User$suggestedFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findMany"> | Null>
    feedEvents<T extends User$feedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findMany"> | Null>
    inviteQueue<T extends User$inviteQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$inviteQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findMany"> | Null>
    flaggedMedia<T extends User$flaggedMediaArgs<ExtArgs> = {}>(args?: Subset<T, User$flaggedMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly timeZone: FieldRef<"User", 'String'>
    readonly joinedAt: FieldRef<"User", 'DateTime'>
    readonly inviteCode: FieldRef<"User", 'String'>
    readonly invitedById: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly firebaseUid: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.invitedBy
   */
  export type User$invitedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.invitedUsers
   */
  export type User$invitedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.createdVibes
   */
  export type User$createdVibesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    where?: VibeWhereInput
    orderBy?: VibeOrderByWithRelationInput | VibeOrderByWithRelationInput[]
    cursor?: VibeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeScalarFieldEnum | VibeScalarFieldEnum[]
  }

  /**
   * User.contributedVibes
   */
  export type User$contributedVibesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    where?: VibeContributorWhereInput
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    cursor?: VibeContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeContributorScalarFieldEnum | VibeContributorScalarFieldEnum[]
  }

  /**
   * User.media
   */
  export type User$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User.vibeViews
   */
  export type User$vibeViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    where?: VibeViewerWhereInput
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    cursor?: VibeViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeViewerScalarFieldEnum | VibeViewerScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.drafts
   */
  export type User$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    cursor?: DraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * User.invites
   */
  export type User$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    where?: VibeInviteWhereInput
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    cursor?: VibeInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * User.sentInvites
   */
  export type User$sentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    where?: VibeInviteWhereInput
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    cursor?: VibeInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * User.suggestedTo
   */
  export type User$suggestedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    where?: SuggestedUserWhereInput
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    cursor?: SuggestedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestedUserScalarFieldEnum | SuggestedUserScalarFieldEnum[]
  }

  /**
   * User.suggestedFrom
   */
  export type User$suggestedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    where?: SuggestedUserWhereInput
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    cursor?: SuggestedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestedUserScalarFieldEnum | SuggestedUserScalarFieldEnum[]
  }

  /**
   * User.feedEvents
   */
  export type User$feedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    where?: FeedEventWhereInput
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    cursor?: FeedEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedEventScalarFieldEnum | FeedEventScalarFieldEnum[]
  }

  /**
   * User.inviteQueue
   */
  export type User$inviteQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    where?: InviteQueueWhereInput
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    cursor?: InviteQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteQueueScalarFieldEnum | InviteQueueScalarFieldEnum[]
  }

  /**
   * User.flaggedMedia
   */
  export type User$flaggedMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    where?: MediaFlagWhereInput
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    cursor?: MediaFlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFlagScalarFieldEnum | MediaFlagScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Vibe
   */

  export type AggregateVibe = {
    _count: VibeCountAggregateOutputType | null
    _min: VibeMinAggregateOutputType | null
    _max: VibeMaxAggregateOutputType | null
  }

  export type VibeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    coverMediaId: string | null
    createdById: string | null
    isShared: boolean | null
    status: string | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VibeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    coverMediaId: string | null
    createdById: string | null
    isShared: boolean | null
    status: string | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VibeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    location: number
    startDate: number
    endDate: number
    coverMediaId: number
    createdById: number
    isShared: number
    status: number
    finalizedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VibeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    coverMediaId?: true
    createdById?: true
    isShared?: true
    status?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VibeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    coverMediaId?: true
    createdById?: true
    isShared?: true
    status?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VibeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    startDate?: true
    endDate?: true
    coverMediaId?: true
    createdById?: true
    isShared?: true
    status?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VibeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vibe to aggregate.
     */
    where?: VibeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vibes to fetch.
     */
    orderBy?: VibeOrderByWithRelationInput | VibeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VibeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vibes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vibes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vibes
    **/
    _count?: true | VibeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VibeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VibeMaxAggregateInputType
  }

  export type GetVibeAggregateType<T extends VibeAggregateArgs> = {
        [P in keyof T & keyof AggregateVibe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVibe[P]>
      : GetScalarType<T[P], AggregateVibe[P]>
  }




  export type VibeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeWhereInput
    orderBy?: VibeOrderByWithAggregationInput | VibeOrderByWithAggregationInput[]
    by: VibeScalarFieldEnum[] | VibeScalarFieldEnum
    having?: VibeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VibeCountAggregateInputType | true
    _min?: VibeMinAggregateInputType
    _max?: VibeMaxAggregateInputType
  }

  export type VibeGroupByOutputType = {
    id: string
    title: string
    description: string | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    coverMediaId: string | null
    createdById: string
    isShared: boolean
    status: string
    finalizedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VibeCountAggregateOutputType | null
    _min: VibeMinAggregateOutputType | null
    _max: VibeMaxAggregateOutputType | null
  }

  type GetVibeGroupByPayload<T extends VibeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VibeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VibeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VibeGroupByOutputType[P]>
            : GetScalarType<T[P], VibeGroupByOutputType[P]>
        }
      >
    >


  export type VibeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    coverMediaId?: boolean
    createdById?: boolean
    isShared?: boolean
    status?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coverMedia?: boolean | Vibe$coverMediaArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    contributors?: boolean | Vibe$contributorsArgs<ExtArgs>
    media?: boolean | Vibe$mediaArgs<ExtArgs>
    viewers?: boolean | Vibe$viewersArgs<ExtArgs>
    drafts?: boolean | Vibe$draftsArgs<ExtArgs>
    invites?: boolean | Vibe$invitesArgs<ExtArgs>
    notifications?: boolean | Vibe$notificationsArgs<ExtArgs>
    feedEvents?: boolean | Vibe$feedEventsArgs<ExtArgs>
    cityFeedCache?: boolean | Vibe$cityFeedCacheArgs<ExtArgs>
    inviteQueue?: boolean | Vibe$inviteQueueArgs<ExtArgs>
    _count?: boolean | VibeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibe"]>

  export type VibeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    coverMediaId?: boolean
    createdById?: boolean
    isShared?: boolean
    status?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coverMedia?: boolean | Vibe$coverMediaArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibe"]>

  export type VibeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    coverMediaId?: boolean
    createdById?: boolean
    isShared?: boolean
    status?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VibeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coverMedia?: boolean | Vibe$coverMediaArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    contributors?: boolean | Vibe$contributorsArgs<ExtArgs>
    media?: boolean | Vibe$mediaArgs<ExtArgs>
    viewers?: boolean | Vibe$viewersArgs<ExtArgs>
    drafts?: boolean | Vibe$draftsArgs<ExtArgs>
    invites?: boolean | Vibe$invitesArgs<ExtArgs>
    notifications?: boolean | Vibe$notificationsArgs<ExtArgs>
    feedEvents?: boolean | Vibe$feedEventsArgs<ExtArgs>
    cityFeedCache?: boolean | Vibe$cityFeedCacheArgs<ExtArgs>
    inviteQueue?: boolean | Vibe$inviteQueueArgs<ExtArgs>
    _count?: boolean | VibeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VibeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coverMedia?: boolean | Vibe$coverMediaArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VibePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vibe"
    objects: {
      coverMedia: Prisma.$MediaPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      contributors: Prisma.$VibeContributorPayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      viewers: Prisma.$VibeViewerPayload<ExtArgs>[]
      drafts: Prisma.$DraftPayload<ExtArgs>[]
      invites: Prisma.$VibeInvitePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      feedEvents: Prisma.$FeedEventPayload<ExtArgs>[]
      cityFeedCache: Prisma.$CityFeedCachePayload<ExtArgs>[]
      inviteQueue: Prisma.$InviteQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      location: string | null
      startDate: Date | null
      endDate: Date | null
      coverMediaId: string | null
      createdById: string
      isShared: boolean
      status: string
      finalizedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vibe"]>
    composites: {}
  }

  type VibeGetPayload<S extends boolean | null | undefined | VibeDefaultArgs> = $Result.GetResult<Prisma.$VibePayload, S>

  type VibeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VibeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VibeCountAggregateInputType | true
    }

  export interface VibeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vibe'], meta: { name: 'Vibe' } }
    /**
     * Find zero or one Vibe that matches the filter.
     * @param {VibeFindUniqueArgs} args - Arguments to find a Vibe
     * @example
     * // Get one Vibe
     * const vibe = await prisma.vibe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VibeFindUniqueArgs>(args: SelectSubset<T, VibeFindUniqueArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vibe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VibeFindUniqueOrThrowArgs} args - Arguments to find a Vibe
     * @example
     * // Get one Vibe
     * const vibe = await prisma.vibe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VibeFindUniqueOrThrowArgs>(args: SelectSubset<T, VibeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vibe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeFindFirstArgs} args - Arguments to find a Vibe
     * @example
     * // Get one Vibe
     * const vibe = await prisma.vibe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VibeFindFirstArgs>(args?: SelectSubset<T, VibeFindFirstArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vibe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeFindFirstOrThrowArgs} args - Arguments to find a Vibe
     * @example
     * // Get one Vibe
     * const vibe = await prisma.vibe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VibeFindFirstOrThrowArgs>(args?: SelectSubset<T, VibeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vibes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vibes
     * const vibes = await prisma.vibe.findMany()
     * 
     * // Get first 10 Vibes
     * const vibes = await prisma.vibe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vibeWithIdOnly = await prisma.vibe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VibeFindManyArgs>(args?: SelectSubset<T, VibeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vibe.
     * @param {VibeCreateArgs} args - Arguments to create a Vibe.
     * @example
     * // Create one Vibe
     * const Vibe = await prisma.vibe.create({
     *   data: {
     *     // ... data to create a Vibe
     *   }
     * })
     * 
     */
    create<T extends VibeCreateArgs>(args: SelectSubset<T, VibeCreateArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vibes.
     * @param {VibeCreateManyArgs} args - Arguments to create many Vibes.
     * @example
     * // Create many Vibes
     * const vibe = await prisma.vibe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VibeCreateManyArgs>(args?: SelectSubset<T, VibeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vibes and returns the data saved in the database.
     * @param {VibeCreateManyAndReturnArgs} args - Arguments to create many Vibes.
     * @example
     * // Create many Vibes
     * const vibe = await prisma.vibe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vibes and only return the `id`
     * const vibeWithIdOnly = await prisma.vibe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VibeCreateManyAndReturnArgs>(args?: SelectSubset<T, VibeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vibe.
     * @param {VibeDeleteArgs} args - Arguments to delete one Vibe.
     * @example
     * // Delete one Vibe
     * const Vibe = await prisma.vibe.delete({
     *   where: {
     *     // ... filter to delete one Vibe
     *   }
     * })
     * 
     */
    delete<T extends VibeDeleteArgs>(args: SelectSubset<T, VibeDeleteArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vibe.
     * @param {VibeUpdateArgs} args - Arguments to update one Vibe.
     * @example
     * // Update one Vibe
     * const vibe = await prisma.vibe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VibeUpdateArgs>(args: SelectSubset<T, VibeUpdateArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vibes.
     * @param {VibeDeleteManyArgs} args - Arguments to filter Vibes to delete.
     * @example
     * // Delete a few Vibes
     * const { count } = await prisma.vibe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VibeDeleteManyArgs>(args?: SelectSubset<T, VibeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vibes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vibes
     * const vibe = await prisma.vibe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VibeUpdateManyArgs>(args: SelectSubset<T, VibeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vibe.
     * @param {VibeUpsertArgs} args - Arguments to update or create a Vibe.
     * @example
     * // Update or create a Vibe
     * const vibe = await prisma.vibe.upsert({
     *   create: {
     *     // ... data to create a Vibe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vibe we want to update
     *   }
     * })
     */
    upsert<T extends VibeUpsertArgs>(args: SelectSubset<T, VibeUpsertArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vibes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeCountArgs} args - Arguments to filter Vibes to count.
     * @example
     * // Count the number of Vibes
     * const count = await prisma.vibe.count({
     *   where: {
     *     // ... the filter for the Vibes we want to count
     *   }
     * })
    **/
    count<T extends VibeCountArgs>(
      args?: Subset<T, VibeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VibeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vibe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VibeAggregateArgs>(args: Subset<T, VibeAggregateArgs>): Prisma.PrismaPromise<GetVibeAggregateType<T>>

    /**
     * Group by Vibe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VibeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VibeGroupByArgs['orderBy'] }
        : { orderBy?: VibeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VibeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVibeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vibe model
   */
  readonly fields: VibeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vibe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VibeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coverMedia<T extends Vibe$coverMediaArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$coverMediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contributors<T extends Vibe$contributorsArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$contributorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findMany"> | Null>
    media<T extends Vibe$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    viewers<T extends Vibe$viewersArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$viewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findMany"> | Null>
    drafts<T extends Vibe$draftsArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Vibe$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Vibe$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    feedEvents<T extends Vibe$feedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$feedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findMany"> | Null>
    cityFeedCache<T extends Vibe$cityFeedCacheArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$cityFeedCacheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findMany"> | Null>
    inviteQueue<T extends Vibe$inviteQueueArgs<ExtArgs> = {}>(args?: Subset<T, Vibe$inviteQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vibe model
   */ 
  interface VibeFieldRefs {
    readonly id: FieldRef<"Vibe", 'String'>
    readonly title: FieldRef<"Vibe", 'String'>
    readonly description: FieldRef<"Vibe", 'String'>
    readonly location: FieldRef<"Vibe", 'String'>
    readonly startDate: FieldRef<"Vibe", 'DateTime'>
    readonly endDate: FieldRef<"Vibe", 'DateTime'>
    readonly coverMediaId: FieldRef<"Vibe", 'String'>
    readonly createdById: FieldRef<"Vibe", 'String'>
    readonly isShared: FieldRef<"Vibe", 'Boolean'>
    readonly status: FieldRef<"Vibe", 'String'>
    readonly finalizedAt: FieldRef<"Vibe", 'DateTime'>
    readonly createdAt: FieldRef<"Vibe", 'DateTime'>
    readonly updatedAt: FieldRef<"Vibe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vibe findUnique
   */
  export type VibeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter, which Vibe to fetch.
     */
    where: VibeWhereUniqueInput
  }

  /**
   * Vibe findUniqueOrThrow
   */
  export type VibeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter, which Vibe to fetch.
     */
    where: VibeWhereUniqueInput
  }

  /**
   * Vibe findFirst
   */
  export type VibeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter, which Vibe to fetch.
     */
    where?: VibeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vibes to fetch.
     */
    orderBy?: VibeOrderByWithRelationInput | VibeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vibes.
     */
    cursor?: VibeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vibes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vibes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vibes.
     */
    distinct?: VibeScalarFieldEnum | VibeScalarFieldEnum[]
  }

  /**
   * Vibe findFirstOrThrow
   */
  export type VibeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter, which Vibe to fetch.
     */
    where?: VibeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vibes to fetch.
     */
    orderBy?: VibeOrderByWithRelationInput | VibeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vibes.
     */
    cursor?: VibeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vibes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vibes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vibes.
     */
    distinct?: VibeScalarFieldEnum | VibeScalarFieldEnum[]
  }

  /**
   * Vibe findMany
   */
  export type VibeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter, which Vibes to fetch.
     */
    where?: VibeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vibes to fetch.
     */
    orderBy?: VibeOrderByWithRelationInput | VibeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vibes.
     */
    cursor?: VibeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vibes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vibes.
     */
    skip?: number
    distinct?: VibeScalarFieldEnum | VibeScalarFieldEnum[]
  }

  /**
   * Vibe create
   */
  export type VibeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * The data needed to create a Vibe.
     */
    data: XOR<VibeCreateInput, VibeUncheckedCreateInput>
  }

  /**
   * Vibe createMany
   */
  export type VibeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vibes.
     */
    data: VibeCreateManyInput | VibeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vibe createManyAndReturn
   */
  export type VibeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vibes.
     */
    data: VibeCreateManyInput | VibeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vibe update
   */
  export type VibeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * The data needed to update a Vibe.
     */
    data: XOR<VibeUpdateInput, VibeUncheckedUpdateInput>
    /**
     * Choose, which Vibe to update.
     */
    where: VibeWhereUniqueInput
  }

  /**
   * Vibe updateMany
   */
  export type VibeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vibes.
     */
    data: XOR<VibeUpdateManyMutationInput, VibeUncheckedUpdateManyInput>
    /**
     * Filter which Vibes to update
     */
    where?: VibeWhereInput
  }

  /**
   * Vibe upsert
   */
  export type VibeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * The filter to search for the Vibe to update in case it exists.
     */
    where: VibeWhereUniqueInput
    /**
     * In case the Vibe found by the `where` argument doesn't exist, create a new Vibe with this data.
     */
    create: XOR<VibeCreateInput, VibeUncheckedCreateInput>
    /**
     * In case the Vibe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VibeUpdateInput, VibeUncheckedUpdateInput>
  }

  /**
   * Vibe delete
   */
  export type VibeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    /**
     * Filter which Vibe to delete.
     */
    where: VibeWhereUniqueInput
  }

  /**
   * Vibe deleteMany
   */
  export type VibeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vibes to delete
     */
    where?: VibeWhereInput
  }

  /**
   * Vibe.coverMedia
   */
  export type Vibe$coverMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Vibe.contributors
   */
  export type Vibe$contributorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    where?: VibeContributorWhereInput
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    cursor?: VibeContributorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeContributorScalarFieldEnum | VibeContributorScalarFieldEnum[]
  }

  /**
   * Vibe.media
   */
  export type Vibe$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Vibe.viewers
   */
  export type Vibe$viewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    where?: VibeViewerWhereInput
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    cursor?: VibeViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeViewerScalarFieldEnum | VibeViewerScalarFieldEnum[]
  }

  /**
   * Vibe.drafts
   */
  export type Vibe$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    cursor?: DraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Vibe.invites
   */
  export type Vibe$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    where?: VibeInviteWhereInput
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    cursor?: VibeInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * Vibe.notifications
   */
  export type Vibe$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Vibe.feedEvents
   */
  export type Vibe$feedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    where?: FeedEventWhereInput
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    cursor?: FeedEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedEventScalarFieldEnum | FeedEventScalarFieldEnum[]
  }

  /**
   * Vibe.cityFeedCache
   */
  export type Vibe$cityFeedCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    where?: CityFeedCacheWhereInput
    orderBy?: CityFeedCacheOrderByWithRelationInput | CityFeedCacheOrderByWithRelationInput[]
    cursor?: CityFeedCacheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityFeedCacheScalarFieldEnum | CityFeedCacheScalarFieldEnum[]
  }

  /**
   * Vibe.inviteQueue
   */
  export type Vibe$inviteQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    where?: InviteQueueWhereInput
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    cursor?: InviteQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteQueueScalarFieldEnum | InviteQueueScalarFieldEnum[]
  }

  /**
   * Vibe without action
   */
  export type VibeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
  }


  /**
   * Model VibeContributor
   */

  export type AggregateVibeContributor = {
    _count: VibeContributorCountAggregateOutputType | null
    _min: VibeContributorMinAggregateOutputType | null
    _max: VibeContributorMaxAggregateOutputType | null
  }

  export type VibeContributorMinAggregateOutputType = {
    id: string | null
    vibeId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    hasUploaded: boolean | null
    leftAt: Date | null
  }

  export type VibeContributorMaxAggregateOutputType = {
    id: string | null
    vibeId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    hasUploaded: boolean | null
    leftAt: Date | null
  }

  export type VibeContributorCountAggregateOutputType = {
    id: number
    vibeId: number
    userId: number
    role: number
    joinedAt: number
    hasUploaded: number
    leftAt: number
    _all: number
  }


  export type VibeContributorMinAggregateInputType = {
    id?: true
    vibeId?: true
    userId?: true
    role?: true
    joinedAt?: true
    hasUploaded?: true
    leftAt?: true
  }

  export type VibeContributorMaxAggregateInputType = {
    id?: true
    vibeId?: true
    userId?: true
    role?: true
    joinedAt?: true
    hasUploaded?: true
    leftAt?: true
  }

  export type VibeContributorCountAggregateInputType = {
    id?: true
    vibeId?: true
    userId?: true
    role?: true
    joinedAt?: true
    hasUploaded?: true
    leftAt?: true
    _all?: true
  }

  export type VibeContributorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeContributor to aggregate.
     */
    where?: VibeContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeContributors to fetch.
     */
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VibeContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VibeContributors
    **/
    _count?: true | VibeContributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VibeContributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VibeContributorMaxAggregateInputType
  }

  export type GetVibeContributorAggregateType<T extends VibeContributorAggregateArgs> = {
        [P in keyof T & keyof AggregateVibeContributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVibeContributor[P]>
      : GetScalarType<T[P], AggregateVibeContributor[P]>
  }




  export type VibeContributorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeContributorWhereInput
    orderBy?: VibeContributorOrderByWithAggregationInput | VibeContributorOrderByWithAggregationInput[]
    by: VibeContributorScalarFieldEnum[] | VibeContributorScalarFieldEnum
    having?: VibeContributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VibeContributorCountAggregateInputType | true
    _min?: VibeContributorMinAggregateInputType
    _max?: VibeContributorMaxAggregateInputType
  }

  export type VibeContributorGroupByOutputType = {
    id: string
    vibeId: string
    userId: string
    role: string
    joinedAt: Date
    hasUploaded: boolean
    leftAt: Date | null
    _count: VibeContributorCountAggregateOutputType | null
    _min: VibeContributorMinAggregateOutputType | null
    _max: VibeContributorMaxAggregateOutputType | null
  }

  type GetVibeContributorGroupByPayload<T extends VibeContributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VibeContributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VibeContributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VibeContributorGroupByOutputType[P]>
            : GetScalarType<T[P], VibeContributorGroupByOutputType[P]>
        }
      >
    >


  export type VibeContributorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    hasUploaded?: boolean
    leftAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeContributor"]>

  export type VibeContributorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    hasUploaded?: boolean
    leftAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeContributor"]>

  export type VibeContributorSelectScalar = {
    id?: boolean
    vibeId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    hasUploaded?: boolean
    leftAt?: boolean
  }

  export type VibeContributorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VibeContributorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VibeContributorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VibeContributor"
    objects: {
      vibe: Prisma.$VibePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vibeId: string
      userId: string
      role: string
      joinedAt: Date
      hasUploaded: boolean
      leftAt: Date | null
    }, ExtArgs["result"]["vibeContributor"]>
    composites: {}
  }

  type VibeContributorGetPayload<S extends boolean | null | undefined | VibeContributorDefaultArgs> = $Result.GetResult<Prisma.$VibeContributorPayload, S>

  type VibeContributorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VibeContributorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VibeContributorCountAggregateInputType | true
    }

  export interface VibeContributorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VibeContributor'], meta: { name: 'VibeContributor' } }
    /**
     * Find zero or one VibeContributor that matches the filter.
     * @param {VibeContributorFindUniqueArgs} args - Arguments to find a VibeContributor
     * @example
     * // Get one VibeContributor
     * const vibeContributor = await prisma.vibeContributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VibeContributorFindUniqueArgs>(args: SelectSubset<T, VibeContributorFindUniqueArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VibeContributor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VibeContributorFindUniqueOrThrowArgs} args - Arguments to find a VibeContributor
     * @example
     * // Get one VibeContributor
     * const vibeContributor = await prisma.vibeContributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VibeContributorFindUniqueOrThrowArgs>(args: SelectSubset<T, VibeContributorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VibeContributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorFindFirstArgs} args - Arguments to find a VibeContributor
     * @example
     * // Get one VibeContributor
     * const vibeContributor = await prisma.vibeContributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VibeContributorFindFirstArgs>(args?: SelectSubset<T, VibeContributorFindFirstArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VibeContributor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorFindFirstOrThrowArgs} args - Arguments to find a VibeContributor
     * @example
     * // Get one VibeContributor
     * const vibeContributor = await prisma.vibeContributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VibeContributorFindFirstOrThrowArgs>(args?: SelectSubset<T, VibeContributorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VibeContributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VibeContributors
     * const vibeContributors = await prisma.vibeContributor.findMany()
     * 
     * // Get first 10 VibeContributors
     * const vibeContributors = await prisma.vibeContributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vibeContributorWithIdOnly = await prisma.vibeContributor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VibeContributorFindManyArgs>(args?: SelectSubset<T, VibeContributorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VibeContributor.
     * @param {VibeContributorCreateArgs} args - Arguments to create a VibeContributor.
     * @example
     * // Create one VibeContributor
     * const VibeContributor = await prisma.vibeContributor.create({
     *   data: {
     *     // ... data to create a VibeContributor
     *   }
     * })
     * 
     */
    create<T extends VibeContributorCreateArgs>(args: SelectSubset<T, VibeContributorCreateArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VibeContributors.
     * @param {VibeContributorCreateManyArgs} args - Arguments to create many VibeContributors.
     * @example
     * // Create many VibeContributors
     * const vibeContributor = await prisma.vibeContributor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VibeContributorCreateManyArgs>(args?: SelectSubset<T, VibeContributorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VibeContributors and returns the data saved in the database.
     * @param {VibeContributorCreateManyAndReturnArgs} args - Arguments to create many VibeContributors.
     * @example
     * // Create many VibeContributors
     * const vibeContributor = await prisma.vibeContributor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VibeContributors and only return the `id`
     * const vibeContributorWithIdOnly = await prisma.vibeContributor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VibeContributorCreateManyAndReturnArgs>(args?: SelectSubset<T, VibeContributorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VibeContributor.
     * @param {VibeContributorDeleteArgs} args - Arguments to delete one VibeContributor.
     * @example
     * // Delete one VibeContributor
     * const VibeContributor = await prisma.vibeContributor.delete({
     *   where: {
     *     // ... filter to delete one VibeContributor
     *   }
     * })
     * 
     */
    delete<T extends VibeContributorDeleteArgs>(args: SelectSubset<T, VibeContributorDeleteArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VibeContributor.
     * @param {VibeContributorUpdateArgs} args - Arguments to update one VibeContributor.
     * @example
     * // Update one VibeContributor
     * const vibeContributor = await prisma.vibeContributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VibeContributorUpdateArgs>(args: SelectSubset<T, VibeContributorUpdateArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VibeContributors.
     * @param {VibeContributorDeleteManyArgs} args - Arguments to filter VibeContributors to delete.
     * @example
     * // Delete a few VibeContributors
     * const { count } = await prisma.vibeContributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VibeContributorDeleteManyArgs>(args?: SelectSubset<T, VibeContributorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VibeContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VibeContributors
     * const vibeContributor = await prisma.vibeContributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VibeContributorUpdateManyArgs>(args: SelectSubset<T, VibeContributorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VibeContributor.
     * @param {VibeContributorUpsertArgs} args - Arguments to update or create a VibeContributor.
     * @example
     * // Update or create a VibeContributor
     * const vibeContributor = await prisma.vibeContributor.upsert({
     *   create: {
     *     // ... data to create a VibeContributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VibeContributor we want to update
     *   }
     * })
     */
    upsert<T extends VibeContributorUpsertArgs>(args: SelectSubset<T, VibeContributorUpsertArgs<ExtArgs>>): Prisma__VibeContributorClient<$Result.GetResult<Prisma.$VibeContributorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VibeContributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorCountArgs} args - Arguments to filter VibeContributors to count.
     * @example
     * // Count the number of VibeContributors
     * const count = await prisma.vibeContributor.count({
     *   where: {
     *     // ... the filter for the VibeContributors we want to count
     *   }
     * })
    **/
    count<T extends VibeContributorCountArgs>(
      args?: Subset<T, VibeContributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VibeContributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VibeContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VibeContributorAggregateArgs>(args: Subset<T, VibeContributorAggregateArgs>): Prisma.PrismaPromise<GetVibeContributorAggregateType<T>>

    /**
     * Group by VibeContributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeContributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VibeContributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VibeContributorGroupByArgs['orderBy'] }
        : { orderBy?: VibeContributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VibeContributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVibeContributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VibeContributor model
   */
  readonly fields: VibeContributorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VibeContributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VibeContributorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VibeContributor model
   */ 
  interface VibeContributorFieldRefs {
    readonly id: FieldRef<"VibeContributor", 'String'>
    readonly vibeId: FieldRef<"VibeContributor", 'String'>
    readonly userId: FieldRef<"VibeContributor", 'String'>
    readonly role: FieldRef<"VibeContributor", 'String'>
    readonly joinedAt: FieldRef<"VibeContributor", 'DateTime'>
    readonly hasUploaded: FieldRef<"VibeContributor", 'Boolean'>
    readonly leftAt: FieldRef<"VibeContributor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VibeContributor findUnique
   */
  export type VibeContributorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter, which VibeContributor to fetch.
     */
    where: VibeContributorWhereUniqueInput
  }

  /**
   * VibeContributor findUniqueOrThrow
   */
  export type VibeContributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter, which VibeContributor to fetch.
     */
    where: VibeContributorWhereUniqueInput
  }

  /**
   * VibeContributor findFirst
   */
  export type VibeContributorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter, which VibeContributor to fetch.
     */
    where?: VibeContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeContributors to fetch.
     */
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeContributors.
     */
    cursor?: VibeContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeContributors.
     */
    distinct?: VibeContributorScalarFieldEnum | VibeContributorScalarFieldEnum[]
  }

  /**
   * VibeContributor findFirstOrThrow
   */
  export type VibeContributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter, which VibeContributor to fetch.
     */
    where?: VibeContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeContributors to fetch.
     */
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeContributors.
     */
    cursor?: VibeContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeContributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeContributors.
     */
    distinct?: VibeContributorScalarFieldEnum | VibeContributorScalarFieldEnum[]
  }

  /**
   * VibeContributor findMany
   */
  export type VibeContributorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter, which VibeContributors to fetch.
     */
    where?: VibeContributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeContributors to fetch.
     */
    orderBy?: VibeContributorOrderByWithRelationInput | VibeContributorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VibeContributors.
     */
    cursor?: VibeContributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeContributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeContributors.
     */
    skip?: number
    distinct?: VibeContributorScalarFieldEnum | VibeContributorScalarFieldEnum[]
  }

  /**
   * VibeContributor create
   */
  export type VibeContributorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * The data needed to create a VibeContributor.
     */
    data: XOR<VibeContributorCreateInput, VibeContributorUncheckedCreateInput>
  }

  /**
   * VibeContributor createMany
   */
  export type VibeContributorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VibeContributors.
     */
    data: VibeContributorCreateManyInput | VibeContributorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VibeContributor createManyAndReturn
   */
  export type VibeContributorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VibeContributors.
     */
    data: VibeContributorCreateManyInput | VibeContributorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VibeContributor update
   */
  export type VibeContributorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * The data needed to update a VibeContributor.
     */
    data: XOR<VibeContributorUpdateInput, VibeContributorUncheckedUpdateInput>
    /**
     * Choose, which VibeContributor to update.
     */
    where: VibeContributorWhereUniqueInput
  }

  /**
   * VibeContributor updateMany
   */
  export type VibeContributorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VibeContributors.
     */
    data: XOR<VibeContributorUpdateManyMutationInput, VibeContributorUncheckedUpdateManyInput>
    /**
     * Filter which VibeContributors to update
     */
    where?: VibeContributorWhereInput
  }

  /**
   * VibeContributor upsert
   */
  export type VibeContributorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * The filter to search for the VibeContributor to update in case it exists.
     */
    where: VibeContributorWhereUniqueInput
    /**
     * In case the VibeContributor found by the `where` argument doesn't exist, create a new VibeContributor with this data.
     */
    create: XOR<VibeContributorCreateInput, VibeContributorUncheckedCreateInput>
    /**
     * In case the VibeContributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VibeContributorUpdateInput, VibeContributorUncheckedUpdateInput>
  }

  /**
   * VibeContributor delete
   */
  export type VibeContributorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
    /**
     * Filter which VibeContributor to delete.
     */
    where: VibeContributorWhereUniqueInput
  }

  /**
   * VibeContributor deleteMany
   */
  export type VibeContributorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeContributors to delete
     */
    where?: VibeContributorWhereInput
  }

  /**
   * VibeContributor without action
   */
  export type VibeContributorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeContributor
     */
    select?: VibeContributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeContributorInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    vibeId: string | null
    uploadedById: string | null
    mediaType: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    caption: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    vibeId: string | null
    uploadedById: string | null
    mediaType: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    caption: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    vibeId: number
    uploadedById: number
    mediaType: number
    mediaUrl: number
    thumbnailUrl: number
    caption: number
    timestamp: number
    exifData: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    vibeId?: true
    uploadedById?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    timestamp?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    vibeId?: true
    uploadedById?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    timestamp?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    vibeId?: true
    uploadedById?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    timestamp?: true
    exifData?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl: string | null
    caption: string | null
    timestamp: Date | null
    exifData: JsonValue | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    uploadedById?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    timestamp?: boolean
    exifData?: boolean
    createdAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    favoritedBy?: boolean | Media$favoritedByArgs<ExtArgs>
    coverOfVibe?: boolean | Media$coverOfVibeArgs<ExtArgs>
    flags?: boolean | Media$flagsArgs<ExtArgs>
    notifications?: boolean | Media$notificationsArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    uploadedById?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    timestamp?: boolean
    exifData?: boolean
    createdAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    vibeId?: boolean
    uploadedById?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    timestamp?: boolean
    exifData?: boolean
    createdAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    favoritedBy?: boolean | Media$favoritedByArgs<ExtArgs>
    coverOfVibe?: boolean | Media$coverOfVibeArgs<ExtArgs>
    flags?: boolean | Media$flagsArgs<ExtArgs>
    notifications?: boolean | Media$notificationsArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      vibe: Prisma.$VibePayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      favoritedBy: Prisma.$FavoritePayload<ExtArgs>[]
      coverOfVibe: Prisma.$VibePayload<ExtArgs> | null
      flags: Prisma.$MediaFlagPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vibeId: string
      uploadedById: string
      mediaType: string
      mediaUrl: string
      thumbnailUrl: string | null
      caption: string | null
      timestamp: Date | null
      exifData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    favoritedBy<T extends Media$favoritedByArgs<ExtArgs> = {}>(args?: Subset<T, Media$favoritedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany"> | Null>
    coverOfVibe<T extends Media$coverOfVibeArgs<ExtArgs> = {}>(args?: Subset<T, Media$coverOfVibeArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    flags<T extends Media$flagsArgs<ExtArgs> = {}>(args?: Subset<T, Media$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Media$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Media$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly vibeId: FieldRef<"Media", 'String'>
    readonly uploadedById: FieldRef<"Media", 'String'>
    readonly mediaType: FieldRef<"Media", 'String'>
    readonly mediaUrl: FieldRef<"Media", 'String'>
    readonly thumbnailUrl: FieldRef<"Media", 'String'>
    readonly caption: FieldRef<"Media", 'String'>
    readonly timestamp: FieldRef<"Media", 'DateTime'>
    readonly exifData: FieldRef<"Media", 'Json'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media.favoritedBy
   */
  export type Media$favoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Media.coverOfVibe
   */
  export type Media$coverOfVibeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    where?: VibeWhereInput
  }

  /**
   * Media.flags
   */
  export type Media$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    where?: MediaFlagWhereInput
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    cursor?: MediaFlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFlagScalarFieldEnum | MediaFlagScalarFieldEnum[]
  }

  /**
   * Media.notifications
   */
  export type Media$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model VibeViewer
   */

  export type AggregateVibeViewer = {
    _count: VibeViewerCountAggregateOutputType | null
    _min: VibeViewerMinAggregateOutputType | null
    _max: VibeViewerMaxAggregateOutputType | null
  }

  export type VibeViewerMinAggregateOutputType = {
    id: string | null
    vibeId: string | null
    viewerId: string | null
    viewedAt: Date | null
  }

  export type VibeViewerMaxAggregateOutputType = {
    id: string | null
    vibeId: string | null
    viewerId: string | null
    viewedAt: Date | null
  }

  export type VibeViewerCountAggregateOutputType = {
    id: number
    vibeId: number
    viewerId: number
    viewedAt: number
    _all: number
  }


  export type VibeViewerMinAggregateInputType = {
    id?: true
    vibeId?: true
    viewerId?: true
    viewedAt?: true
  }

  export type VibeViewerMaxAggregateInputType = {
    id?: true
    vibeId?: true
    viewerId?: true
    viewedAt?: true
  }

  export type VibeViewerCountAggregateInputType = {
    id?: true
    vibeId?: true
    viewerId?: true
    viewedAt?: true
    _all?: true
  }

  export type VibeViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeViewer to aggregate.
     */
    where?: VibeViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeViewers to fetch.
     */
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VibeViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VibeViewers
    **/
    _count?: true | VibeViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VibeViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VibeViewerMaxAggregateInputType
  }

  export type GetVibeViewerAggregateType<T extends VibeViewerAggregateArgs> = {
        [P in keyof T & keyof AggregateVibeViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVibeViewer[P]>
      : GetScalarType<T[P], AggregateVibeViewer[P]>
  }




  export type VibeViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeViewerWhereInput
    orderBy?: VibeViewerOrderByWithAggregationInput | VibeViewerOrderByWithAggregationInput[]
    by: VibeViewerScalarFieldEnum[] | VibeViewerScalarFieldEnum
    having?: VibeViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VibeViewerCountAggregateInputType | true
    _min?: VibeViewerMinAggregateInputType
    _max?: VibeViewerMaxAggregateInputType
  }

  export type VibeViewerGroupByOutputType = {
    id: string
    vibeId: string
    viewerId: string
    viewedAt: Date
    _count: VibeViewerCountAggregateOutputType | null
    _min: VibeViewerMinAggregateOutputType | null
    _max: VibeViewerMaxAggregateOutputType | null
  }

  type GetVibeViewerGroupByPayload<T extends VibeViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VibeViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VibeViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VibeViewerGroupByOutputType[P]>
            : GetScalarType<T[P], VibeViewerGroupByOutputType[P]>
        }
      >
    >


  export type VibeViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    viewerId?: boolean
    viewedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeViewer"]>

  export type VibeViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    viewerId?: boolean
    viewedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeViewer"]>

  export type VibeViewerSelectScalar = {
    id?: boolean
    vibeId?: boolean
    viewerId?: boolean
    viewedAt?: boolean
  }

  export type VibeViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VibeViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VibeViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VibeViewer"
    objects: {
      vibe: Prisma.$VibePayload<ExtArgs>
      viewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vibeId: string
      viewerId: string
      viewedAt: Date
    }, ExtArgs["result"]["vibeViewer"]>
    composites: {}
  }

  type VibeViewerGetPayload<S extends boolean | null | undefined | VibeViewerDefaultArgs> = $Result.GetResult<Prisma.$VibeViewerPayload, S>

  type VibeViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VibeViewerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VibeViewerCountAggregateInputType | true
    }

  export interface VibeViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VibeViewer'], meta: { name: 'VibeViewer' } }
    /**
     * Find zero or one VibeViewer that matches the filter.
     * @param {VibeViewerFindUniqueArgs} args - Arguments to find a VibeViewer
     * @example
     * // Get one VibeViewer
     * const vibeViewer = await prisma.vibeViewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VibeViewerFindUniqueArgs>(args: SelectSubset<T, VibeViewerFindUniqueArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VibeViewer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VibeViewerFindUniqueOrThrowArgs} args - Arguments to find a VibeViewer
     * @example
     * // Get one VibeViewer
     * const vibeViewer = await prisma.vibeViewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VibeViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, VibeViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VibeViewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerFindFirstArgs} args - Arguments to find a VibeViewer
     * @example
     * // Get one VibeViewer
     * const vibeViewer = await prisma.vibeViewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VibeViewerFindFirstArgs>(args?: SelectSubset<T, VibeViewerFindFirstArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VibeViewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerFindFirstOrThrowArgs} args - Arguments to find a VibeViewer
     * @example
     * // Get one VibeViewer
     * const vibeViewer = await prisma.vibeViewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VibeViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, VibeViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VibeViewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VibeViewers
     * const vibeViewers = await prisma.vibeViewer.findMany()
     * 
     * // Get first 10 VibeViewers
     * const vibeViewers = await prisma.vibeViewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vibeViewerWithIdOnly = await prisma.vibeViewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VibeViewerFindManyArgs>(args?: SelectSubset<T, VibeViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VibeViewer.
     * @param {VibeViewerCreateArgs} args - Arguments to create a VibeViewer.
     * @example
     * // Create one VibeViewer
     * const VibeViewer = await prisma.vibeViewer.create({
     *   data: {
     *     // ... data to create a VibeViewer
     *   }
     * })
     * 
     */
    create<T extends VibeViewerCreateArgs>(args: SelectSubset<T, VibeViewerCreateArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VibeViewers.
     * @param {VibeViewerCreateManyArgs} args - Arguments to create many VibeViewers.
     * @example
     * // Create many VibeViewers
     * const vibeViewer = await prisma.vibeViewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VibeViewerCreateManyArgs>(args?: SelectSubset<T, VibeViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VibeViewers and returns the data saved in the database.
     * @param {VibeViewerCreateManyAndReturnArgs} args - Arguments to create many VibeViewers.
     * @example
     * // Create many VibeViewers
     * const vibeViewer = await prisma.vibeViewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VibeViewers and only return the `id`
     * const vibeViewerWithIdOnly = await prisma.vibeViewer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VibeViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, VibeViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VibeViewer.
     * @param {VibeViewerDeleteArgs} args - Arguments to delete one VibeViewer.
     * @example
     * // Delete one VibeViewer
     * const VibeViewer = await prisma.vibeViewer.delete({
     *   where: {
     *     // ... filter to delete one VibeViewer
     *   }
     * })
     * 
     */
    delete<T extends VibeViewerDeleteArgs>(args: SelectSubset<T, VibeViewerDeleteArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VibeViewer.
     * @param {VibeViewerUpdateArgs} args - Arguments to update one VibeViewer.
     * @example
     * // Update one VibeViewer
     * const vibeViewer = await prisma.vibeViewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VibeViewerUpdateArgs>(args: SelectSubset<T, VibeViewerUpdateArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VibeViewers.
     * @param {VibeViewerDeleteManyArgs} args - Arguments to filter VibeViewers to delete.
     * @example
     * // Delete a few VibeViewers
     * const { count } = await prisma.vibeViewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VibeViewerDeleteManyArgs>(args?: SelectSubset<T, VibeViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VibeViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VibeViewers
     * const vibeViewer = await prisma.vibeViewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VibeViewerUpdateManyArgs>(args: SelectSubset<T, VibeViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VibeViewer.
     * @param {VibeViewerUpsertArgs} args - Arguments to update or create a VibeViewer.
     * @example
     * // Update or create a VibeViewer
     * const vibeViewer = await prisma.vibeViewer.upsert({
     *   create: {
     *     // ... data to create a VibeViewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VibeViewer we want to update
     *   }
     * })
     */
    upsert<T extends VibeViewerUpsertArgs>(args: SelectSubset<T, VibeViewerUpsertArgs<ExtArgs>>): Prisma__VibeViewerClient<$Result.GetResult<Prisma.$VibeViewerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VibeViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerCountArgs} args - Arguments to filter VibeViewers to count.
     * @example
     * // Count the number of VibeViewers
     * const count = await prisma.vibeViewer.count({
     *   where: {
     *     // ... the filter for the VibeViewers we want to count
     *   }
     * })
    **/
    count<T extends VibeViewerCountArgs>(
      args?: Subset<T, VibeViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VibeViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VibeViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VibeViewerAggregateArgs>(args: Subset<T, VibeViewerAggregateArgs>): Prisma.PrismaPromise<GetVibeViewerAggregateType<T>>

    /**
     * Group by VibeViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VibeViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VibeViewerGroupByArgs['orderBy'] }
        : { orderBy?: VibeViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VibeViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVibeViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VibeViewer model
   */
  readonly fields: VibeViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VibeViewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VibeViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VibeViewer model
   */ 
  interface VibeViewerFieldRefs {
    readonly id: FieldRef<"VibeViewer", 'String'>
    readonly vibeId: FieldRef<"VibeViewer", 'String'>
    readonly viewerId: FieldRef<"VibeViewer", 'String'>
    readonly viewedAt: FieldRef<"VibeViewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VibeViewer findUnique
   */
  export type VibeViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter, which VibeViewer to fetch.
     */
    where: VibeViewerWhereUniqueInput
  }

  /**
   * VibeViewer findUniqueOrThrow
   */
  export type VibeViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter, which VibeViewer to fetch.
     */
    where: VibeViewerWhereUniqueInput
  }

  /**
   * VibeViewer findFirst
   */
  export type VibeViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter, which VibeViewer to fetch.
     */
    where?: VibeViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeViewers to fetch.
     */
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeViewers.
     */
    cursor?: VibeViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeViewers.
     */
    distinct?: VibeViewerScalarFieldEnum | VibeViewerScalarFieldEnum[]
  }

  /**
   * VibeViewer findFirstOrThrow
   */
  export type VibeViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter, which VibeViewer to fetch.
     */
    where?: VibeViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeViewers to fetch.
     */
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeViewers.
     */
    cursor?: VibeViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeViewers.
     */
    distinct?: VibeViewerScalarFieldEnum | VibeViewerScalarFieldEnum[]
  }

  /**
   * VibeViewer findMany
   */
  export type VibeViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter, which VibeViewers to fetch.
     */
    where?: VibeViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeViewers to fetch.
     */
    orderBy?: VibeViewerOrderByWithRelationInput | VibeViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VibeViewers.
     */
    cursor?: VibeViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeViewers.
     */
    skip?: number
    distinct?: VibeViewerScalarFieldEnum | VibeViewerScalarFieldEnum[]
  }

  /**
   * VibeViewer create
   */
  export type VibeViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a VibeViewer.
     */
    data: XOR<VibeViewerCreateInput, VibeViewerUncheckedCreateInput>
  }

  /**
   * VibeViewer createMany
   */
  export type VibeViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VibeViewers.
     */
    data: VibeViewerCreateManyInput | VibeViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VibeViewer createManyAndReturn
   */
  export type VibeViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VibeViewers.
     */
    data: VibeViewerCreateManyInput | VibeViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VibeViewer update
   */
  export type VibeViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a VibeViewer.
     */
    data: XOR<VibeViewerUpdateInput, VibeViewerUncheckedUpdateInput>
    /**
     * Choose, which VibeViewer to update.
     */
    where: VibeViewerWhereUniqueInput
  }

  /**
   * VibeViewer updateMany
   */
  export type VibeViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VibeViewers.
     */
    data: XOR<VibeViewerUpdateManyMutationInput, VibeViewerUncheckedUpdateManyInput>
    /**
     * Filter which VibeViewers to update
     */
    where?: VibeViewerWhereInput
  }

  /**
   * VibeViewer upsert
   */
  export type VibeViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the VibeViewer to update in case it exists.
     */
    where: VibeViewerWhereUniqueInput
    /**
     * In case the VibeViewer found by the `where` argument doesn't exist, create a new VibeViewer with this data.
     */
    create: XOR<VibeViewerCreateInput, VibeViewerUncheckedCreateInput>
    /**
     * In case the VibeViewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VibeViewerUpdateInput, VibeViewerUncheckedUpdateInput>
  }

  /**
   * VibeViewer delete
   */
  export type VibeViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
    /**
     * Filter which VibeViewer to delete.
     */
    where: VibeViewerWhereUniqueInput
  }

  /**
   * VibeViewer deleteMany
   */
  export type VibeViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeViewers to delete
     */
    where?: VibeViewerWhereInput
  }

  /**
   * VibeViewer without action
   */
  export type VibeViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeViewer
     */
    select?: VibeViewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeViewerInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mediaId: string | null
    favoritedAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mediaId: string | null
    favoritedAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    mediaId: number
    favoritedAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    mediaId?: true
    favoritedAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    mediaId?: true
    favoritedAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    mediaId?: true
    favoritedAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    mediaId: string
    favoritedAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mediaId?: boolean
    favoritedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mediaId?: boolean
    favoritedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    mediaId?: boolean
    favoritedAt?: boolean
  }

  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mediaId: string
      favoritedAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */ 
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly mediaId: FieldRef<"Favorite", 'String'>
    readonly favoritedAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: string | null
    message: string | null
    vibeId: string | null
    mediaId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: string | null
    message: string | null
    vibeId: string | null
    mediaId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    senderId: number
    type: number
    message: number
    vibeId: number
    mediaId: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    message?: true
    vibeId?: true
    mediaId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    message?: true
    vibeId?: true
    mediaId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    message?: true
    vibeId?: true
    mediaId?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    senderId: string
    type: string
    message: string | null
    vibeId: string | null
    mediaId: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    message?: boolean
    vibeId?: boolean
    mediaId?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | Notification$vibeArgs<ExtArgs>
    media?: boolean | Notification$mediaArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    message?: boolean
    vibeId?: boolean
    mediaId?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | Notification$vibeArgs<ExtArgs>
    media?: boolean | Notification$mediaArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    message?: boolean
    vibeId?: boolean
    mediaId?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | Notification$vibeArgs<ExtArgs>
    media?: boolean | Notification$mediaArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | Notification$vibeArgs<ExtArgs>
    media?: boolean | Notification$mediaArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      vibe: Prisma.$VibePayload<ExtArgs> | null
      media: Prisma.$MediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      senderId: string
      type: string
      message: string | null
      vibeId: string | null
      mediaId: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vibe<T extends Notification$vibeArgs<ExtArgs> = {}>(args?: Subset<T, Notification$vibeArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    media<T extends Notification$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Notification$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly vibeId: FieldRef<"Notification", 'String'>
    readonly mediaId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.vibe
   */
  export type Notification$vibeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    where?: VibeWhereInput
  }

  /**
   * Notification.media
   */
  export type Notification$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Draft
   */

  export type AggregateDraft = {
    _count: DraftCountAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  export type DraftMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vibeId: string | null
    lastEditedAt: Date | null
    expiresAt: Date | null
  }

  export type DraftMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vibeId: string | null
    lastEditedAt: Date | null
    expiresAt: Date | null
  }

  export type DraftCountAggregateOutputType = {
    id: number
    userId: number
    vibeId: number
    lastEditedAt: number
    expiresAt: number
    _all: number
  }


  export type DraftMinAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    lastEditedAt?: true
    expiresAt?: true
  }

  export type DraftMaxAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    lastEditedAt?: true
    expiresAt?: true
  }

  export type DraftCountAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    lastEditedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type DraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Draft to aggregate.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drafts
    **/
    _count?: true | DraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftMaxAggregateInputType
  }

  export type GetDraftAggregateType<T extends DraftAggregateArgs> = {
        [P in keyof T & keyof AggregateDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraft[P]>
      : GetScalarType<T[P], AggregateDraft[P]>
  }




  export type DraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithAggregationInput | DraftOrderByWithAggregationInput[]
    by: DraftScalarFieldEnum[] | DraftScalarFieldEnum
    having?: DraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftCountAggregateInputType | true
    _min?: DraftMinAggregateInputType
    _max?: DraftMaxAggregateInputType
  }

  export type DraftGroupByOutputType = {
    id: string
    userId: string
    vibeId: string
    lastEditedAt: Date
    expiresAt: Date | null
    _count: DraftCountAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  type GetDraftGroupByPayload<T extends DraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftGroupByOutputType[P]>
            : GetScalarType<T[P], DraftGroupByOutputType[P]>
        }
      >
    >


  export type DraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    lastEditedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    lastEditedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectScalar = {
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    lastEditedAt?: boolean
    expiresAt?: boolean
  }

  export type DraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }
  export type DraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }

  export type $DraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Draft"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vibe: Prisma.$VibePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vibeId: string
      lastEditedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["draft"]>
    composites: {}
  }

  type DraftGetPayload<S extends boolean | null | undefined | DraftDefaultArgs> = $Result.GetResult<Prisma.$DraftPayload, S>

  type DraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DraftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DraftCountAggregateInputType | true
    }

  export interface DraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Draft'], meta: { name: 'Draft' } }
    /**
     * Find zero or one Draft that matches the filter.
     * @param {DraftFindUniqueArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftFindUniqueArgs>(args: SelectSubset<T, DraftFindUniqueArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Draft that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DraftFindUniqueOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Draft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftFindFirstArgs>(args?: SelectSubset<T, DraftFindFirstArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Draft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drafts
     * const drafts = await prisma.draft.findMany()
     * 
     * // Get first 10 Drafts
     * const drafts = await prisma.draft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const draftWithIdOnly = await prisma.draft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DraftFindManyArgs>(args?: SelectSubset<T, DraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Draft.
     * @param {DraftCreateArgs} args - Arguments to create a Draft.
     * @example
     * // Create one Draft
     * const Draft = await prisma.draft.create({
     *   data: {
     *     // ... data to create a Draft
     *   }
     * })
     * 
     */
    create<T extends DraftCreateArgs>(args: SelectSubset<T, DraftCreateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drafts.
     * @param {DraftCreateManyArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftCreateManyArgs>(args?: SelectSubset<T, DraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drafts and returns the data saved in the database.
     * @param {DraftCreateManyAndReturnArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drafts and only return the `id`
     * const draftWithIdOnly = await prisma.draft.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Draft.
     * @param {DraftDeleteArgs} args - Arguments to delete one Draft.
     * @example
     * // Delete one Draft
     * const Draft = await prisma.draft.delete({
     *   where: {
     *     // ... filter to delete one Draft
     *   }
     * })
     * 
     */
    delete<T extends DraftDeleteArgs>(args: SelectSubset<T, DraftDeleteArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Draft.
     * @param {DraftUpdateArgs} args - Arguments to update one Draft.
     * @example
     * // Update one Draft
     * const draft = await prisma.draft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftUpdateArgs>(args: SelectSubset<T, DraftUpdateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drafts.
     * @param {DraftDeleteManyArgs} args - Arguments to filter Drafts to delete.
     * @example
     * // Delete a few Drafts
     * const { count } = await prisma.draft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftDeleteManyArgs>(args?: SelectSubset<T, DraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drafts
     * const draft = await prisma.draft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftUpdateManyArgs>(args: SelectSubset<T, DraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Draft.
     * @param {DraftUpsertArgs} args - Arguments to update or create a Draft.
     * @example
     * // Update or create a Draft
     * const draft = await prisma.draft.upsert({
     *   create: {
     *     // ... data to create a Draft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Draft we want to update
     *   }
     * })
     */
    upsert<T extends DraftUpsertArgs>(args: SelectSubset<T, DraftUpsertArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftCountArgs} args - Arguments to filter Drafts to count.
     * @example
     * // Count the number of Drafts
     * const count = await prisma.draft.count({
     *   where: {
     *     // ... the filter for the Drafts we want to count
     *   }
     * })
    **/
    count<T extends DraftCountArgs>(
      args?: Subset<T, DraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftAggregateArgs>(args: Subset<T, DraftAggregateArgs>): Prisma.PrismaPromise<GetDraftAggregateType<T>>

    /**
     * Group by Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftGroupByArgs['orderBy'] }
        : { orderBy?: DraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Draft model
   */
  readonly fields: DraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Draft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Draft model
   */ 
  interface DraftFieldRefs {
    readonly id: FieldRef<"Draft", 'String'>
    readonly userId: FieldRef<"Draft", 'String'>
    readonly vibeId: FieldRef<"Draft", 'String'>
    readonly lastEditedAt: FieldRef<"Draft", 'DateTime'>
    readonly expiresAt: FieldRef<"Draft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Draft findUnique
   */
  export type DraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findUniqueOrThrow
   */
  export type DraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findFirst
   */
  export type DraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findFirstOrThrow
   */
  export type DraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findMany
   */
  export type DraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Drafts to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft create
   */
  export type DraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to create a Draft.
     */
    data: XOR<DraftCreateInput, DraftUncheckedCreateInput>
  }

  /**
   * Draft createMany
   */
  export type DraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Draft createManyAndReturn
   */
  export type DraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Draft update
   */
  export type DraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to update a Draft.
     */
    data: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
    /**
     * Choose, which Draft to update.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft updateMany
   */
  export type DraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drafts.
     */
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyInput>
    /**
     * Filter which Drafts to update
     */
    where?: DraftWhereInput
  }

  /**
   * Draft upsert
   */
  export type DraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The filter to search for the Draft to update in case it exists.
     */
    where: DraftWhereUniqueInput
    /**
     * In case the Draft found by the `where` argument doesn't exist, create a new Draft with this data.
     */
    create: XOR<DraftCreateInput, DraftUncheckedCreateInput>
    /**
     * In case the Draft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
  }

  /**
   * Draft delete
   */
  export type DraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter which Draft to delete.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft deleteMany
   */
  export type DraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drafts to delete
     */
    where?: DraftWhereInput
  }

  /**
   * Draft without action
   */
  export type DraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
  }


  /**
   * Model VibeInvite
   */

  export type AggregateVibeInvite = {
    _count: VibeInviteCountAggregateOutputType | null
    _min: VibeInviteMinAggregateOutputType | null
    _max: VibeInviteMaxAggregateOutputType | null
  }

  export type VibeInviteMinAggregateOutputType = {
    id: string | null
    vibeId: string | null
    invitedUserId: string | null
    invitedById: string | null
    status: string | null
    invitedAt: Date | null
    respondedAt: Date | null
  }

  export type VibeInviteMaxAggregateOutputType = {
    id: string | null
    vibeId: string | null
    invitedUserId: string | null
    invitedById: string | null
    status: string | null
    invitedAt: Date | null
    respondedAt: Date | null
  }

  export type VibeInviteCountAggregateOutputType = {
    id: number
    vibeId: number
    invitedUserId: number
    invitedById: number
    status: number
    invitedAt: number
    respondedAt: number
    _all: number
  }


  export type VibeInviteMinAggregateInputType = {
    id?: true
    vibeId?: true
    invitedUserId?: true
    invitedById?: true
    status?: true
    invitedAt?: true
    respondedAt?: true
  }

  export type VibeInviteMaxAggregateInputType = {
    id?: true
    vibeId?: true
    invitedUserId?: true
    invitedById?: true
    status?: true
    invitedAt?: true
    respondedAt?: true
  }

  export type VibeInviteCountAggregateInputType = {
    id?: true
    vibeId?: true
    invitedUserId?: true
    invitedById?: true
    status?: true
    invitedAt?: true
    respondedAt?: true
    _all?: true
  }

  export type VibeInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeInvite to aggregate.
     */
    where?: VibeInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeInvites to fetch.
     */
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VibeInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VibeInvites
    **/
    _count?: true | VibeInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VibeInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VibeInviteMaxAggregateInputType
  }

  export type GetVibeInviteAggregateType<T extends VibeInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateVibeInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVibeInvite[P]>
      : GetScalarType<T[P], AggregateVibeInvite[P]>
  }




  export type VibeInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VibeInviteWhereInput
    orderBy?: VibeInviteOrderByWithAggregationInput | VibeInviteOrderByWithAggregationInput[]
    by: VibeInviteScalarFieldEnum[] | VibeInviteScalarFieldEnum
    having?: VibeInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VibeInviteCountAggregateInputType | true
    _min?: VibeInviteMinAggregateInputType
    _max?: VibeInviteMaxAggregateInputType
  }

  export type VibeInviteGroupByOutputType = {
    id: string
    vibeId: string
    invitedUserId: string
    invitedById: string
    status: string
    invitedAt: Date
    respondedAt: Date | null
    _count: VibeInviteCountAggregateOutputType | null
    _min: VibeInviteMinAggregateOutputType | null
    _max: VibeInviteMaxAggregateOutputType | null
  }

  type GetVibeInviteGroupByPayload<T extends VibeInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VibeInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VibeInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VibeInviteGroupByOutputType[P]>
            : GetScalarType<T[P], VibeInviteGroupByOutputType[P]>
        }
      >
    >


  export type VibeInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    invitedUserId?: boolean
    invitedById?: boolean
    status?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    invitedUser?: boolean | UserDefaultArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeInvite"]>

  export type VibeInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vibeId?: boolean
    invitedUserId?: boolean
    invitedById?: boolean
    status?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    invitedUser?: boolean | UserDefaultArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vibeInvite"]>

  export type VibeInviteSelectScalar = {
    id?: boolean
    vibeId?: boolean
    invitedUserId?: boolean
    invitedById?: boolean
    status?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
  }

  export type VibeInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    invitedUser?: boolean | UserDefaultArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VibeInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
    invitedUser?: boolean | UserDefaultArgs<ExtArgs>
    invitedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VibeInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VibeInvite"
    objects: {
      vibe: Prisma.$VibePayload<ExtArgs>
      invitedUser: Prisma.$UserPayload<ExtArgs>
      invitedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vibeId: string
      invitedUserId: string
      invitedById: string
      status: string
      invitedAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["vibeInvite"]>
    composites: {}
  }

  type VibeInviteGetPayload<S extends boolean | null | undefined | VibeInviteDefaultArgs> = $Result.GetResult<Prisma.$VibeInvitePayload, S>

  type VibeInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VibeInviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VibeInviteCountAggregateInputType | true
    }

  export interface VibeInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VibeInvite'], meta: { name: 'VibeInvite' } }
    /**
     * Find zero or one VibeInvite that matches the filter.
     * @param {VibeInviteFindUniqueArgs} args - Arguments to find a VibeInvite
     * @example
     * // Get one VibeInvite
     * const vibeInvite = await prisma.vibeInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VibeInviteFindUniqueArgs>(args: SelectSubset<T, VibeInviteFindUniqueArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VibeInvite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VibeInviteFindUniqueOrThrowArgs} args - Arguments to find a VibeInvite
     * @example
     * // Get one VibeInvite
     * const vibeInvite = await prisma.vibeInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VibeInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, VibeInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VibeInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteFindFirstArgs} args - Arguments to find a VibeInvite
     * @example
     * // Get one VibeInvite
     * const vibeInvite = await prisma.vibeInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VibeInviteFindFirstArgs>(args?: SelectSubset<T, VibeInviteFindFirstArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VibeInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteFindFirstOrThrowArgs} args - Arguments to find a VibeInvite
     * @example
     * // Get one VibeInvite
     * const vibeInvite = await prisma.vibeInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VibeInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, VibeInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VibeInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VibeInvites
     * const vibeInvites = await prisma.vibeInvite.findMany()
     * 
     * // Get first 10 VibeInvites
     * const vibeInvites = await prisma.vibeInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vibeInviteWithIdOnly = await prisma.vibeInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VibeInviteFindManyArgs>(args?: SelectSubset<T, VibeInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VibeInvite.
     * @param {VibeInviteCreateArgs} args - Arguments to create a VibeInvite.
     * @example
     * // Create one VibeInvite
     * const VibeInvite = await prisma.vibeInvite.create({
     *   data: {
     *     // ... data to create a VibeInvite
     *   }
     * })
     * 
     */
    create<T extends VibeInviteCreateArgs>(args: SelectSubset<T, VibeInviteCreateArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VibeInvites.
     * @param {VibeInviteCreateManyArgs} args - Arguments to create many VibeInvites.
     * @example
     * // Create many VibeInvites
     * const vibeInvite = await prisma.vibeInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VibeInviteCreateManyArgs>(args?: SelectSubset<T, VibeInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VibeInvites and returns the data saved in the database.
     * @param {VibeInviteCreateManyAndReturnArgs} args - Arguments to create many VibeInvites.
     * @example
     * // Create many VibeInvites
     * const vibeInvite = await prisma.vibeInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VibeInvites and only return the `id`
     * const vibeInviteWithIdOnly = await prisma.vibeInvite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VibeInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, VibeInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VibeInvite.
     * @param {VibeInviteDeleteArgs} args - Arguments to delete one VibeInvite.
     * @example
     * // Delete one VibeInvite
     * const VibeInvite = await prisma.vibeInvite.delete({
     *   where: {
     *     // ... filter to delete one VibeInvite
     *   }
     * })
     * 
     */
    delete<T extends VibeInviteDeleteArgs>(args: SelectSubset<T, VibeInviteDeleteArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VibeInvite.
     * @param {VibeInviteUpdateArgs} args - Arguments to update one VibeInvite.
     * @example
     * // Update one VibeInvite
     * const vibeInvite = await prisma.vibeInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VibeInviteUpdateArgs>(args: SelectSubset<T, VibeInviteUpdateArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VibeInvites.
     * @param {VibeInviteDeleteManyArgs} args - Arguments to filter VibeInvites to delete.
     * @example
     * // Delete a few VibeInvites
     * const { count } = await prisma.vibeInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VibeInviteDeleteManyArgs>(args?: SelectSubset<T, VibeInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VibeInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VibeInvites
     * const vibeInvite = await prisma.vibeInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VibeInviteUpdateManyArgs>(args: SelectSubset<T, VibeInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VibeInvite.
     * @param {VibeInviteUpsertArgs} args - Arguments to update or create a VibeInvite.
     * @example
     * // Update or create a VibeInvite
     * const vibeInvite = await prisma.vibeInvite.upsert({
     *   create: {
     *     // ... data to create a VibeInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VibeInvite we want to update
     *   }
     * })
     */
    upsert<T extends VibeInviteUpsertArgs>(args: SelectSubset<T, VibeInviteUpsertArgs<ExtArgs>>): Prisma__VibeInviteClient<$Result.GetResult<Prisma.$VibeInvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VibeInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteCountArgs} args - Arguments to filter VibeInvites to count.
     * @example
     * // Count the number of VibeInvites
     * const count = await prisma.vibeInvite.count({
     *   where: {
     *     // ... the filter for the VibeInvites we want to count
     *   }
     * })
    **/
    count<T extends VibeInviteCountArgs>(
      args?: Subset<T, VibeInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VibeInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VibeInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VibeInviteAggregateArgs>(args: Subset<T, VibeInviteAggregateArgs>): Prisma.PrismaPromise<GetVibeInviteAggregateType<T>>

    /**
     * Group by VibeInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VibeInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VibeInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VibeInviteGroupByArgs['orderBy'] }
        : { orderBy?: VibeInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VibeInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVibeInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VibeInvite model
   */
  readonly fields: VibeInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VibeInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VibeInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invitedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invitedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VibeInvite model
   */ 
  interface VibeInviteFieldRefs {
    readonly id: FieldRef<"VibeInvite", 'String'>
    readonly vibeId: FieldRef<"VibeInvite", 'String'>
    readonly invitedUserId: FieldRef<"VibeInvite", 'String'>
    readonly invitedById: FieldRef<"VibeInvite", 'String'>
    readonly status: FieldRef<"VibeInvite", 'String'>
    readonly invitedAt: FieldRef<"VibeInvite", 'DateTime'>
    readonly respondedAt: FieldRef<"VibeInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VibeInvite findUnique
   */
  export type VibeInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter, which VibeInvite to fetch.
     */
    where: VibeInviteWhereUniqueInput
  }

  /**
   * VibeInvite findUniqueOrThrow
   */
  export type VibeInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter, which VibeInvite to fetch.
     */
    where: VibeInviteWhereUniqueInput
  }

  /**
   * VibeInvite findFirst
   */
  export type VibeInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter, which VibeInvite to fetch.
     */
    where?: VibeInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeInvites to fetch.
     */
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeInvites.
     */
    cursor?: VibeInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeInvites.
     */
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * VibeInvite findFirstOrThrow
   */
  export type VibeInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter, which VibeInvite to fetch.
     */
    where?: VibeInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeInvites to fetch.
     */
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VibeInvites.
     */
    cursor?: VibeInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VibeInvites.
     */
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * VibeInvite findMany
   */
  export type VibeInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter, which VibeInvites to fetch.
     */
    where?: VibeInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VibeInvites to fetch.
     */
    orderBy?: VibeInviteOrderByWithRelationInput | VibeInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VibeInvites.
     */
    cursor?: VibeInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VibeInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VibeInvites.
     */
    skip?: number
    distinct?: VibeInviteScalarFieldEnum | VibeInviteScalarFieldEnum[]
  }

  /**
   * VibeInvite create
   */
  export type VibeInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a VibeInvite.
     */
    data: XOR<VibeInviteCreateInput, VibeInviteUncheckedCreateInput>
  }

  /**
   * VibeInvite createMany
   */
  export type VibeInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VibeInvites.
     */
    data: VibeInviteCreateManyInput | VibeInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VibeInvite createManyAndReturn
   */
  export type VibeInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VibeInvites.
     */
    data: VibeInviteCreateManyInput | VibeInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VibeInvite update
   */
  export type VibeInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a VibeInvite.
     */
    data: XOR<VibeInviteUpdateInput, VibeInviteUncheckedUpdateInput>
    /**
     * Choose, which VibeInvite to update.
     */
    where: VibeInviteWhereUniqueInput
  }

  /**
   * VibeInvite updateMany
   */
  export type VibeInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VibeInvites.
     */
    data: XOR<VibeInviteUpdateManyMutationInput, VibeInviteUncheckedUpdateManyInput>
    /**
     * Filter which VibeInvites to update
     */
    where?: VibeInviteWhereInput
  }

  /**
   * VibeInvite upsert
   */
  export type VibeInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the VibeInvite to update in case it exists.
     */
    where: VibeInviteWhereUniqueInput
    /**
     * In case the VibeInvite found by the `where` argument doesn't exist, create a new VibeInvite with this data.
     */
    create: XOR<VibeInviteCreateInput, VibeInviteUncheckedCreateInput>
    /**
     * In case the VibeInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VibeInviteUpdateInput, VibeInviteUncheckedUpdateInput>
  }

  /**
   * VibeInvite delete
   */
  export type VibeInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
    /**
     * Filter which VibeInvite to delete.
     */
    where: VibeInviteWhereUniqueInput
  }

  /**
   * VibeInvite deleteMany
   */
  export type VibeInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VibeInvites to delete
     */
    where?: VibeInviteWhereInput
  }

  /**
   * VibeInvite without action
   */
  export type VibeInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VibeInvite
     */
    select?: VibeInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInviteInclude<ExtArgs> | null
  }


  /**
   * Model MediaFlag
   */

  export type AggregateMediaFlag = {
    _count: MediaFlagCountAggregateOutputType | null
    _min: MediaFlagMinAggregateOutputType | null
    _max: MediaFlagMaxAggregateOutputType | null
  }

  export type MediaFlagMinAggregateOutputType = {
    id: string | null
    mediaId: string | null
    flaggedById: string | null
    reason: string | null
    additionalInfo: string | null
    flaggedAt: Date | null
  }

  export type MediaFlagMaxAggregateOutputType = {
    id: string | null
    mediaId: string | null
    flaggedById: string | null
    reason: string | null
    additionalInfo: string | null
    flaggedAt: Date | null
  }

  export type MediaFlagCountAggregateOutputType = {
    id: number
    mediaId: number
    flaggedById: number
    reason: number
    additionalInfo: number
    flaggedAt: number
    _all: number
  }


  export type MediaFlagMinAggregateInputType = {
    id?: true
    mediaId?: true
    flaggedById?: true
    reason?: true
    additionalInfo?: true
    flaggedAt?: true
  }

  export type MediaFlagMaxAggregateInputType = {
    id?: true
    mediaId?: true
    flaggedById?: true
    reason?: true
    additionalInfo?: true
    flaggedAt?: true
  }

  export type MediaFlagCountAggregateInputType = {
    id?: true
    mediaId?: true
    flaggedById?: true
    reason?: true
    additionalInfo?: true
    flaggedAt?: true
    _all?: true
  }

  export type MediaFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFlag to aggregate.
     */
    where?: MediaFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFlags to fetch.
     */
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaFlags
    **/
    _count?: true | MediaFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaFlagMaxAggregateInputType
  }

  export type GetMediaFlagAggregateType<T extends MediaFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaFlag[P]>
      : GetScalarType<T[P], AggregateMediaFlag[P]>
  }




  export type MediaFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFlagWhereInput
    orderBy?: MediaFlagOrderByWithAggregationInput | MediaFlagOrderByWithAggregationInput[]
    by: MediaFlagScalarFieldEnum[] | MediaFlagScalarFieldEnum
    having?: MediaFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaFlagCountAggregateInputType | true
    _min?: MediaFlagMinAggregateInputType
    _max?: MediaFlagMaxAggregateInputType
  }

  export type MediaFlagGroupByOutputType = {
    id: string
    mediaId: string
    flaggedById: string
    reason: string
    additionalInfo: string | null
    flaggedAt: Date
    _count: MediaFlagCountAggregateOutputType | null
    _min: MediaFlagMinAggregateOutputType | null
    _max: MediaFlagMaxAggregateOutputType | null
  }

  type GetMediaFlagGroupByPayload<T extends MediaFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaFlagGroupByOutputType[P]>
            : GetScalarType<T[P], MediaFlagGroupByOutputType[P]>
        }
      >
    >


  export type MediaFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    flaggedById?: boolean
    reason?: boolean
    additionalInfo?: boolean
    flaggedAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
    flaggedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFlag"]>

  export type MediaFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaId?: boolean
    flaggedById?: boolean
    reason?: boolean
    additionalInfo?: boolean
    flaggedAt?: boolean
    media?: boolean | MediaDefaultArgs<ExtArgs>
    flaggedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFlag"]>

  export type MediaFlagSelectScalar = {
    id?: boolean
    mediaId?: boolean
    flaggedById?: boolean
    reason?: boolean
    additionalInfo?: boolean
    flaggedAt?: boolean
  }

  export type MediaFlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
    flaggedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MediaFlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | MediaDefaultArgs<ExtArgs>
    flaggedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MediaFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaFlag"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>
      flaggedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaId: string
      flaggedById: string
      reason: string
      additionalInfo: string | null
      flaggedAt: Date
    }, ExtArgs["result"]["mediaFlag"]>
    composites: {}
  }

  type MediaFlagGetPayload<S extends boolean | null | undefined | MediaFlagDefaultArgs> = $Result.GetResult<Prisma.$MediaFlagPayload, S>

  type MediaFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFlagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaFlagCountAggregateInputType | true
    }

  export interface MediaFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaFlag'], meta: { name: 'MediaFlag' } }
    /**
     * Find zero or one MediaFlag that matches the filter.
     * @param {MediaFlagFindUniqueArgs} args - Arguments to find a MediaFlag
     * @example
     * // Get one MediaFlag
     * const mediaFlag = await prisma.mediaFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFlagFindUniqueArgs>(args: SelectSubset<T, MediaFlagFindUniqueArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaFlag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFlagFindUniqueOrThrowArgs} args - Arguments to find a MediaFlag
     * @example
     * // Get one MediaFlag
     * const mediaFlag = await prisma.mediaFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagFindFirstArgs} args - Arguments to find a MediaFlag
     * @example
     * // Get one MediaFlag
     * const mediaFlag = await prisma.mediaFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFlagFindFirstArgs>(args?: SelectSubset<T, MediaFlagFindFirstArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagFindFirstOrThrowArgs} args - Arguments to find a MediaFlag
     * @example
     * // Get one MediaFlag
     * const mediaFlag = await prisma.mediaFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaFlags
     * const mediaFlags = await prisma.mediaFlag.findMany()
     * 
     * // Get first 10 MediaFlags
     * const mediaFlags = await prisma.mediaFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaFlagWithIdOnly = await prisma.mediaFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFlagFindManyArgs>(args?: SelectSubset<T, MediaFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaFlag.
     * @param {MediaFlagCreateArgs} args - Arguments to create a MediaFlag.
     * @example
     * // Create one MediaFlag
     * const MediaFlag = await prisma.mediaFlag.create({
     *   data: {
     *     // ... data to create a MediaFlag
     *   }
     * })
     * 
     */
    create<T extends MediaFlagCreateArgs>(args: SelectSubset<T, MediaFlagCreateArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaFlags.
     * @param {MediaFlagCreateManyArgs} args - Arguments to create many MediaFlags.
     * @example
     * // Create many MediaFlags
     * const mediaFlag = await prisma.mediaFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaFlagCreateManyArgs>(args?: SelectSubset<T, MediaFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaFlags and returns the data saved in the database.
     * @param {MediaFlagCreateManyAndReturnArgs} args - Arguments to create many MediaFlags.
     * @example
     * // Create many MediaFlags
     * const mediaFlag = await prisma.mediaFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaFlags and only return the `id`
     * const mediaFlagWithIdOnly = await prisma.mediaFlag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaFlag.
     * @param {MediaFlagDeleteArgs} args - Arguments to delete one MediaFlag.
     * @example
     * // Delete one MediaFlag
     * const MediaFlag = await prisma.mediaFlag.delete({
     *   where: {
     *     // ... filter to delete one MediaFlag
     *   }
     * })
     * 
     */
    delete<T extends MediaFlagDeleteArgs>(args: SelectSubset<T, MediaFlagDeleteArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaFlag.
     * @param {MediaFlagUpdateArgs} args - Arguments to update one MediaFlag.
     * @example
     * // Update one MediaFlag
     * const mediaFlag = await prisma.mediaFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaFlagUpdateArgs>(args: SelectSubset<T, MediaFlagUpdateArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaFlags.
     * @param {MediaFlagDeleteManyArgs} args - Arguments to filter MediaFlags to delete.
     * @example
     * // Delete a few MediaFlags
     * const { count } = await prisma.mediaFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaFlagDeleteManyArgs>(args?: SelectSubset<T, MediaFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaFlags
     * const mediaFlag = await prisma.mediaFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaFlagUpdateManyArgs>(args: SelectSubset<T, MediaFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaFlag.
     * @param {MediaFlagUpsertArgs} args - Arguments to update or create a MediaFlag.
     * @example
     * // Update or create a MediaFlag
     * const mediaFlag = await prisma.mediaFlag.upsert({
     *   create: {
     *     // ... data to create a MediaFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaFlag we want to update
     *   }
     * })
     */
    upsert<T extends MediaFlagUpsertArgs>(args: SelectSubset<T, MediaFlagUpsertArgs<ExtArgs>>): Prisma__MediaFlagClient<$Result.GetResult<Prisma.$MediaFlagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagCountArgs} args - Arguments to filter MediaFlags to count.
     * @example
     * // Count the number of MediaFlags
     * const count = await prisma.mediaFlag.count({
     *   where: {
     *     // ... the filter for the MediaFlags we want to count
     *   }
     * })
    **/
    count<T extends MediaFlagCountArgs>(
      args?: Subset<T, MediaFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaFlagAggregateArgs>(args: Subset<T, MediaFlagAggregateArgs>): Prisma.PrismaPromise<GetMediaFlagAggregateType<T>>

    /**
     * Group by MediaFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaFlagGroupByArgs['orderBy'] }
        : { orderBy?: MediaFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaFlag model
   */
  readonly fields: MediaFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    flaggedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaFlag model
   */ 
  interface MediaFlagFieldRefs {
    readonly id: FieldRef<"MediaFlag", 'String'>
    readonly mediaId: FieldRef<"MediaFlag", 'String'>
    readonly flaggedById: FieldRef<"MediaFlag", 'String'>
    readonly reason: FieldRef<"MediaFlag", 'String'>
    readonly additionalInfo: FieldRef<"MediaFlag", 'String'>
    readonly flaggedAt: FieldRef<"MediaFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaFlag findUnique
   */
  export type MediaFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter, which MediaFlag to fetch.
     */
    where: MediaFlagWhereUniqueInput
  }

  /**
   * MediaFlag findUniqueOrThrow
   */
  export type MediaFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter, which MediaFlag to fetch.
     */
    where: MediaFlagWhereUniqueInput
  }

  /**
   * MediaFlag findFirst
   */
  export type MediaFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter, which MediaFlag to fetch.
     */
    where?: MediaFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFlags to fetch.
     */
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFlags.
     */
    cursor?: MediaFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFlags.
     */
    distinct?: MediaFlagScalarFieldEnum | MediaFlagScalarFieldEnum[]
  }

  /**
   * MediaFlag findFirstOrThrow
   */
  export type MediaFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter, which MediaFlag to fetch.
     */
    where?: MediaFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFlags to fetch.
     */
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFlags.
     */
    cursor?: MediaFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFlags.
     */
    distinct?: MediaFlagScalarFieldEnum | MediaFlagScalarFieldEnum[]
  }

  /**
   * MediaFlag findMany
   */
  export type MediaFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter, which MediaFlags to fetch.
     */
    where?: MediaFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFlags to fetch.
     */
    orderBy?: MediaFlagOrderByWithRelationInput | MediaFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaFlags.
     */
    cursor?: MediaFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFlags.
     */
    skip?: number
    distinct?: MediaFlagScalarFieldEnum | MediaFlagScalarFieldEnum[]
  }

  /**
   * MediaFlag create
   */
  export type MediaFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaFlag.
     */
    data: XOR<MediaFlagCreateInput, MediaFlagUncheckedCreateInput>
  }

  /**
   * MediaFlag createMany
   */
  export type MediaFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaFlags.
     */
    data: MediaFlagCreateManyInput | MediaFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaFlag createManyAndReturn
   */
  export type MediaFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaFlags.
     */
    data: MediaFlagCreateManyInput | MediaFlagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFlag update
   */
  export type MediaFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaFlag.
     */
    data: XOR<MediaFlagUpdateInput, MediaFlagUncheckedUpdateInput>
    /**
     * Choose, which MediaFlag to update.
     */
    where: MediaFlagWhereUniqueInput
  }

  /**
   * MediaFlag updateMany
   */
  export type MediaFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaFlags.
     */
    data: XOR<MediaFlagUpdateManyMutationInput, MediaFlagUncheckedUpdateManyInput>
    /**
     * Filter which MediaFlags to update
     */
    where?: MediaFlagWhereInput
  }

  /**
   * MediaFlag upsert
   */
  export type MediaFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaFlag to update in case it exists.
     */
    where: MediaFlagWhereUniqueInput
    /**
     * In case the MediaFlag found by the `where` argument doesn't exist, create a new MediaFlag with this data.
     */
    create: XOR<MediaFlagCreateInput, MediaFlagUncheckedCreateInput>
    /**
     * In case the MediaFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaFlagUpdateInput, MediaFlagUncheckedUpdateInput>
  }

  /**
   * MediaFlag delete
   */
  export type MediaFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
    /**
     * Filter which MediaFlag to delete.
     */
    where: MediaFlagWhereUniqueInput
  }

  /**
   * MediaFlag deleteMany
   */
  export type MediaFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFlags to delete
     */
    where?: MediaFlagWhereInput
  }

  /**
   * MediaFlag without action
   */
  export type MediaFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFlag
     */
    select?: MediaFlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFlagInclude<ExtArgs> | null
  }


  /**
   * Model FeedEvent
   */

  export type AggregateFeedEvent = {
    _count: FeedEventCountAggregateOutputType | null
    _min: FeedEventMinAggregateOutputType | null
    _max: FeedEventMaxAggregateOutputType | null
  }

  export type FeedEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    vibeId: string | null
    createdAt: Date | null
  }

  export type FeedEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    vibeId: string | null
    createdAt: Date | null
  }

  export type FeedEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    vibeId: number
    createdAt: number
    _all: number
  }


  export type FeedEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    vibeId?: true
    createdAt?: true
  }

  export type FeedEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    vibeId?: true
    createdAt?: true
  }

  export type FeedEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    vibeId?: true
    createdAt?: true
    _all?: true
  }

  export type FeedEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedEvent to aggregate.
     */
    where?: FeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedEvents to fetch.
     */
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedEvents
    **/
    _count?: true | FeedEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedEventMaxAggregateInputType
  }

  export type GetFeedEventAggregateType<T extends FeedEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedEvent[P]>
      : GetScalarType<T[P], AggregateFeedEvent[P]>
  }




  export type FeedEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedEventWhereInput
    orderBy?: FeedEventOrderByWithAggregationInput | FeedEventOrderByWithAggregationInput[]
    by: FeedEventScalarFieldEnum[] | FeedEventScalarFieldEnum
    having?: FeedEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedEventCountAggregateInputType | true
    _min?: FeedEventMinAggregateInputType
    _max?: FeedEventMaxAggregateInputType
  }

  export type FeedEventGroupByOutputType = {
    id: string
    userId: string
    eventType: string
    vibeId: string | null
    createdAt: Date
    _count: FeedEventCountAggregateOutputType | null
    _min: FeedEventMinAggregateOutputType | null
    _max: FeedEventMaxAggregateOutputType | null
  }

  type GetFeedEventGroupByPayload<T extends FeedEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedEventGroupByOutputType[P]>
            : GetScalarType<T[P], FeedEventGroupByOutputType[P]>
        }
      >
    >


  export type FeedEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    vibeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | FeedEvent$vibeArgs<ExtArgs>
  }, ExtArgs["result"]["feedEvent"]>

  export type FeedEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    vibeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | FeedEvent$vibeArgs<ExtArgs>
  }, ExtArgs["result"]["feedEvent"]>

  export type FeedEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    vibeId?: boolean
    createdAt?: boolean
  }

  export type FeedEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | FeedEvent$vibeArgs<ExtArgs>
  }
  export type FeedEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | FeedEvent$vibeArgs<ExtArgs>
  }

  export type $FeedEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vibe: Prisma.$VibePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventType: string
      vibeId: string | null
      createdAt: Date
    }, ExtArgs["result"]["feedEvent"]>
    composites: {}
  }

  type FeedEventGetPayload<S extends boolean | null | undefined | FeedEventDefaultArgs> = $Result.GetResult<Prisma.$FeedEventPayload, S>

  type FeedEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedEventCountAggregateInputType | true
    }

  export interface FeedEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedEvent'], meta: { name: 'FeedEvent' } }
    /**
     * Find zero or one FeedEvent that matches the filter.
     * @param {FeedEventFindUniqueArgs} args - Arguments to find a FeedEvent
     * @example
     * // Get one FeedEvent
     * const feedEvent = await prisma.feedEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedEventFindUniqueArgs>(args: SelectSubset<T, FeedEventFindUniqueArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedEventFindUniqueOrThrowArgs} args - Arguments to find a FeedEvent
     * @example
     * // Get one FeedEvent
     * const feedEvent = await prisma.feedEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventFindFirstArgs} args - Arguments to find a FeedEvent
     * @example
     * // Get one FeedEvent
     * const feedEvent = await prisma.feedEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedEventFindFirstArgs>(args?: SelectSubset<T, FeedEventFindFirstArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventFindFirstOrThrowArgs} args - Arguments to find a FeedEvent
     * @example
     * // Get one FeedEvent
     * const feedEvent = await prisma.feedEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedEvents
     * const feedEvents = await prisma.feedEvent.findMany()
     * 
     * // Get first 10 FeedEvents
     * const feedEvents = await prisma.feedEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedEventWithIdOnly = await prisma.feedEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedEventFindManyArgs>(args?: SelectSubset<T, FeedEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedEvent.
     * @param {FeedEventCreateArgs} args - Arguments to create a FeedEvent.
     * @example
     * // Create one FeedEvent
     * const FeedEvent = await prisma.feedEvent.create({
     *   data: {
     *     // ... data to create a FeedEvent
     *   }
     * })
     * 
     */
    create<T extends FeedEventCreateArgs>(args: SelectSubset<T, FeedEventCreateArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedEvents.
     * @param {FeedEventCreateManyArgs} args - Arguments to create many FeedEvents.
     * @example
     * // Create many FeedEvents
     * const feedEvent = await prisma.feedEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedEventCreateManyArgs>(args?: SelectSubset<T, FeedEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedEvents and returns the data saved in the database.
     * @param {FeedEventCreateManyAndReturnArgs} args - Arguments to create many FeedEvents.
     * @example
     * // Create many FeedEvents
     * const feedEvent = await prisma.feedEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedEvents and only return the `id`
     * const feedEventWithIdOnly = await prisma.feedEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedEvent.
     * @param {FeedEventDeleteArgs} args - Arguments to delete one FeedEvent.
     * @example
     * // Delete one FeedEvent
     * const FeedEvent = await prisma.feedEvent.delete({
     *   where: {
     *     // ... filter to delete one FeedEvent
     *   }
     * })
     * 
     */
    delete<T extends FeedEventDeleteArgs>(args: SelectSubset<T, FeedEventDeleteArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedEvent.
     * @param {FeedEventUpdateArgs} args - Arguments to update one FeedEvent.
     * @example
     * // Update one FeedEvent
     * const feedEvent = await prisma.feedEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedEventUpdateArgs>(args: SelectSubset<T, FeedEventUpdateArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedEvents.
     * @param {FeedEventDeleteManyArgs} args - Arguments to filter FeedEvents to delete.
     * @example
     * // Delete a few FeedEvents
     * const { count } = await prisma.feedEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedEventDeleteManyArgs>(args?: SelectSubset<T, FeedEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedEvents
     * const feedEvent = await prisma.feedEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedEventUpdateManyArgs>(args: SelectSubset<T, FeedEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedEvent.
     * @param {FeedEventUpsertArgs} args - Arguments to update or create a FeedEvent.
     * @example
     * // Update or create a FeedEvent
     * const feedEvent = await prisma.feedEvent.upsert({
     *   create: {
     *     // ... data to create a FeedEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedEvent we want to update
     *   }
     * })
     */
    upsert<T extends FeedEventUpsertArgs>(args: SelectSubset<T, FeedEventUpsertArgs<ExtArgs>>): Prisma__FeedEventClient<$Result.GetResult<Prisma.$FeedEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventCountArgs} args - Arguments to filter FeedEvents to count.
     * @example
     * // Count the number of FeedEvents
     * const count = await prisma.feedEvent.count({
     *   where: {
     *     // ... the filter for the FeedEvents we want to count
     *   }
     * })
    **/
    count<T extends FeedEventCountArgs>(
      args?: Subset<T, FeedEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedEventAggregateArgs>(args: Subset<T, FeedEventAggregateArgs>): Prisma.PrismaPromise<GetFeedEventAggregateType<T>>

    /**
     * Group by FeedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedEventGroupByArgs['orderBy'] }
        : { orderBy?: FeedEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedEvent model
   */
  readonly fields: FeedEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vibe<T extends FeedEvent$vibeArgs<ExtArgs> = {}>(args?: Subset<T, FeedEvent$vibeArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedEvent model
   */ 
  interface FeedEventFieldRefs {
    readonly id: FieldRef<"FeedEvent", 'String'>
    readonly userId: FieldRef<"FeedEvent", 'String'>
    readonly eventType: FieldRef<"FeedEvent", 'String'>
    readonly vibeId: FieldRef<"FeedEvent", 'String'>
    readonly createdAt: FieldRef<"FeedEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedEvent findUnique
   */
  export type FeedEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter, which FeedEvent to fetch.
     */
    where: FeedEventWhereUniqueInput
  }

  /**
   * FeedEvent findUniqueOrThrow
   */
  export type FeedEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter, which FeedEvent to fetch.
     */
    where: FeedEventWhereUniqueInput
  }

  /**
   * FeedEvent findFirst
   */
  export type FeedEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter, which FeedEvent to fetch.
     */
    where?: FeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedEvents to fetch.
     */
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedEvents.
     */
    cursor?: FeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedEvents.
     */
    distinct?: FeedEventScalarFieldEnum | FeedEventScalarFieldEnum[]
  }

  /**
   * FeedEvent findFirstOrThrow
   */
  export type FeedEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter, which FeedEvent to fetch.
     */
    where?: FeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedEvents to fetch.
     */
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedEvents.
     */
    cursor?: FeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedEvents.
     */
    distinct?: FeedEventScalarFieldEnum | FeedEventScalarFieldEnum[]
  }

  /**
   * FeedEvent findMany
   */
  export type FeedEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter, which FeedEvents to fetch.
     */
    where?: FeedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedEvents to fetch.
     */
    orderBy?: FeedEventOrderByWithRelationInput | FeedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedEvents.
     */
    cursor?: FeedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedEvents.
     */
    skip?: number
    distinct?: FeedEventScalarFieldEnum | FeedEventScalarFieldEnum[]
  }

  /**
   * FeedEvent create
   */
  export type FeedEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedEvent.
     */
    data: XOR<FeedEventCreateInput, FeedEventUncheckedCreateInput>
  }

  /**
   * FeedEvent createMany
   */
  export type FeedEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedEvents.
     */
    data: FeedEventCreateManyInput | FeedEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedEvent createManyAndReturn
   */
  export type FeedEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeedEvents.
     */
    data: FeedEventCreateManyInput | FeedEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedEvent update
   */
  export type FeedEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedEvent.
     */
    data: XOR<FeedEventUpdateInput, FeedEventUncheckedUpdateInput>
    /**
     * Choose, which FeedEvent to update.
     */
    where: FeedEventWhereUniqueInput
  }

  /**
   * FeedEvent updateMany
   */
  export type FeedEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedEvents.
     */
    data: XOR<FeedEventUpdateManyMutationInput, FeedEventUncheckedUpdateManyInput>
    /**
     * Filter which FeedEvents to update
     */
    where?: FeedEventWhereInput
  }

  /**
   * FeedEvent upsert
   */
  export type FeedEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedEvent to update in case it exists.
     */
    where: FeedEventWhereUniqueInput
    /**
     * In case the FeedEvent found by the `where` argument doesn't exist, create a new FeedEvent with this data.
     */
    create: XOR<FeedEventCreateInput, FeedEventUncheckedCreateInput>
    /**
     * In case the FeedEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedEventUpdateInput, FeedEventUncheckedUpdateInput>
  }

  /**
   * FeedEvent delete
   */
  export type FeedEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
    /**
     * Filter which FeedEvent to delete.
     */
    where: FeedEventWhereUniqueInput
  }

  /**
   * FeedEvent deleteMany
   */
  export type FeedEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedEvents to delete
     */
    where?: FeedEventWhereInput
  }

  /**
   * FeedEvent.vibe
   */
  export type FeedEvent$vibeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vibe
     */
    select?: VibeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VibeInclude<ExtArgs> | null
    where?: VibeWhereInput
  }

  /**
   * FeedEvent without action
   */
  export type FeedEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedEvent
     */
    select?: FeedEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedEventInclude<ExtArgs> | null
  }


  /**
   * Model SuggestedUser
   */

  export type AggregateSuggestedUser = {
    _count: SuggestedUserCountAggregateOutputType | null
    _min: SuggestedUserMinAggregateOutputType | null
    _max: SuggestedUserMaxAggregateOutputType | null
  }

  export type SuggestedUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    suggestedUserId: string | null
    reason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SuggestedUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    suggestedUserId: string | null
    reason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SuggestedUserCountAggregateOutputType = {
    id: number
    userId: number
    suggestedUserId: number
    reason: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type SuggestedUserMinAggregateInputType = {
    id?: true
    userId?: true
    suggestedUserId?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SuggestedUserMaxAggregateInputType = {
    id?: true
    userId?: true
    suggestedUserId?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SuggestedUserCountAggregateInputType = {
    id?: true
    userId?: true
    suggestedUserId?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SuggestedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestedUser to aggregate.
     */
    where?: SuggestedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedUsers to fetch.
     */
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuggestedUsers
    **/
    _count?: true | SuggestedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestedUserMaxAggregateInputType
  }

  export type GetSuggestedUserAggregateType<T extends SuggestedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestedUser[P]>
      : GetScalarType<T[P], AggregateSuggestedUser[P]>
  }




  export type SuggestedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestedUserWhereInput
    orderBy?: SuggestedUserOrderByWithAggregationInput | SuggestedUserOrderByWithAggregationInput[]
    by: SuggestedUserScalarFieldEnum[] | SuggestedUserScalarFieldEnum
    having?: SuggestedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestedUserCountAggregateInputType | true
    _min?: SuggestedUserMinAggregateInputType
    _max?: SuggestedUserMaxAggregateInputType
  }

  export type SuggestedUserGroupByOutputType = {
    id: string
    userId: string
    suggestedUserId: string
    reason: string | null
    createdAt: Date
    expiresAt: Date | null
    _count: SuggestedUserCountAggregateOutputType | null
    _min: SuggestedUserMinAggregateOutputType | null
    _max: SuggestedUserMaxAggregateOutputType | null
  }

  type GetSuggestedUserGroupByPayload<T extends SuggestedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestedUserGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestedUserGroupByOutputType[P]>
        }
      >
    >


  export type SuggestedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    suggestedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    suggestedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestedUser"]>

  export type SuggestedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    suggestedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    suggestedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestedUser"]>

  export type SuggestedUserSelectScalar = {
    id?: boolean
    userId?: boolean
    suggestedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type SuggestedUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    suggestedUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuggestedUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    suggestedUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SuggestedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuggestedUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      suggestedUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      suggestedUserId: string
      reason: string | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["suggestedUser"]>
    composites: {}
  }

  type SuggestedUserGetPayload<S extends boolean | null | undefined | SuggestedUserDefaultArgs> = $Result.GetResult<Prisma.$SuggestedUserPayload, S>

  type SuggestedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SuggestedUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SuggestedUserCountAggregateInputType | true
    }

  export interface SuggestedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuggestedUser'], meta: { name: 'SuggestedUser' } }
    /**
     * Find zero or one SuggestedUser that matches the filter.
     * @param {SuggestedUserFindUniqueArgs} args - Arguments to find a SuggestedUser
     * @example
     * // Get one SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestedUserFindUniqueArgs>(args: SelectSubset<T, SuggestedUserFindUniqueArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SuggestedUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SuggestedUserFindUniqueOrThrowArgs} args - Arguments to find a SuggestedUser
     * @example
     * // Get one SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SuggestedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserFindFirstArgs} args - Arguments to find a SuggestedUser
     * @example
     * // Get one SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestedUserFindFirstArgs>(args?: SelectSubset<T, SuggestedUserFindFirstArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SuggestedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserFindFirstOrThrowArgs} args - Arguments to find a SuggestedUser
     * @example
     * // Get one SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SuggestedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuggestedUsers
     * const suggestedUsers = await prisma.suggestedUser.findMany()
     * 
     * // Get first 10 SuggestedUsers
     * const suggestedUsers = await prisma.suggestedUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestedUserWithIdOnly = await prisma.suggestedUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuggestedUserFindManyArgs>(args?: SelectSubset<T, SuggestedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SuggestedUser.
     * @param {SuggestedUserCreateArgs} args - Arguments to create a SuggestedUser.
     * @example
     * // Create one SuggestedUser
     * const SuggestedUser = await prisma.suggestedUser.create({
     *   data: {
     *     // ... data to create a SuggestedUser
     *   }
     * })
     * 
     */
    create<T extends SuggestedUserCreateArgs>(args: SelectSubset<T, SuggestedUserCreateArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SuggestedUsers.
     * @param {SuggestedUserCreateManyArgs} args - Arguments to create many SuggestedUsers.
     * @example
     * // Create many SuggestedUsers
     * const suggestedUser = await prisma.suggestedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestedUserCreateManyArgs>(args?: SelectSubset<T, SuggestedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuggestedUsers and returns the data saved in the database.
     * @param {SuggestedUserCreateManyAndReturnArgs} args - Arguments to create many SuggestedUsers.
     * @example
     * // Create many SuggestedUsers
     * const suggestedUser = await prisma.suggestedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuggestedUsers and only return the `id`
     * const suggestedUserWithIdOnly = await prisma.suggestedUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SuggestedUser.
     * @param {SuggestedUserDeleteArgs} args - Arguments to delete one SuggestedUser.
     * @example
     * // Delete one SuggestedUser
     * const SuggestedUser = await prisma.suggestedUser.delete({
     *   where: {
     *     // ... filter to delete one SuggestedUser
     *   }
     * })
     * 
     */
    delete<T extends SuggestedUserDeleteArgs>(args: SelectSubset<T, SuggestedUserDeleteArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SuggestedUser.
     * @param {SuggestedUserUpdateArgs} args - Arguments to update one SuggestedUser.
     * @example
     * // Update one SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestedUserUpdateArgs>(args: SelectSubset<T, SuggestedUserUpdateArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SuggestedUsers.
     * @param {SuggestedUserDeleteManyArgs} args - Arguments to filter SuggestedUsers to delete.
     * @example
     * // Delete a few SuggestedUsers
     * const { count } = await prisma.suggestedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestedUserDeleteManyArgs>(args?: SelectSubset<T, SuggestedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuggestedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuggestedUsers
     * const suggestedUser = await prisma.suggestedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestedUserUpdateManyArgs>(args: SelectSubset<T, SuggestedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuggestedUser.
     * @param {SuggestedUserUpsertArgs} args - Arguments to update or create a SuggestedUser.
     * @example
     * // Update or create a SuggestedUser
     * const suggestedUser = await prisma.suggestedUser.upsert({
     *   create: {
     *     // ... data to create a SuggestedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuggestedUser we want to update
     *   }
     * })
     */
    upsert<T extends SuggestedUserUpsertArgs>(args: SelectSubset<T, SuggestedUserUpsertArgs<ExtArgs>>): Prisma__SuggestedUserClient<$Result.GetResult<Prisma.$SuggestedUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SuggestedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserCountArgs} args - Arguments to filter SuggestedUsers to count.
     * @example
     * // Count the number of SuggestedUsers
     * const count = await prisma.suggestedUser.count({
     *   where: {
     *     // ... the filter for the SuggestedUsers we want to count
     *   }
     * })
    **/
    count<T extends SuggestedUserCountArgs>(
      args?: Subset<T, SuggestedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuggestedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestedUserAggregateArgs>(args: Subset<T, SuggestedUserAggregateArgs>): Prisma.PrismaPromise<GetSuggestedUserAggregateType<T>>

    /**
     * Group by SuggestedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestedUserGroupByArgs['orderBy'] }
        : { orderBy?: SuggestedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuggestedUser model
   */
  readonly fields: SuggestedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuggestedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    suggestedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuggestedUser model
   */ 
  interface SuggestedUserFieldRefs {
    readonly id: FieldRef<"SuggestedUser", 'String'>
    readonly userId: FieldRef<"SuggestedUser", 'String'>
    readonly suggestedUserId: FieldRef<"SuggestedUser", 'String'>
    readonly reason: FieldRef<"SuggestedUser", 'String'>
    readonly createdAt: FieldRef<"SuggestedUser", 'DateTime'>
    readonly expiresAt: FieldRef<"SuggestedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuggestedUser findUnique
   */
  export type SuggestedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedUser to fetch.
     */
    where: SuggestedUserWhereUniqueInput
  }

  /**
   * SuggestedUser findUniqueOrThrow
   */
  export type SuggestedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedUser to fetch.
     */
    where: SuggestedUserWhereUniqueInput
  }

  /**
   * SuggestedUser findFirst
   */
  export type SuggestedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedUser to fetch.
     */
    where?: SuggestedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedUsers to fetch.
     */
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedUsers.
     */
    cursor?: SuggestedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedUsers.
     */
    distinct?: SuggestedUserScalarFieldEnum | SuggestedUserScalarFieldEnum[]
  }

  /**
   * SuggestedUser findFirstOrThrow
   */
  export type SuggestedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedUser to fetch.
     */
    where?: SuggestedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedUsers to fetch.
     */
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuggestedUsers.
     */
    cursor?: SuggestedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuggestedUsers.
     */
    distinct?: SuggestedUserScalarFieldEnum | SuggestedUserScalarFieldEnum[]
  }

  /**
   * SuggestedUser findMany
   */
  export type SuggestedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter, which SuggestedUsers to fetch.
     */
    where?: SuggestedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuggestedUsers to fetch.
     */
    orderBy?: SuggestedUserOrderByWithRelationInput | SuggestedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuggestedUsers.
     */
    cursor?: SuggestedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuggestedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuggestedUsers.
     */
    skip?: number
    distinct?: SuggestedUserScalarFieldEnum | SuggestedUserScalarFieldEnum[]
  }

  /**
   * SuggestedUser create
   */
  export type SuggestedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a SuggestedUser.
     */
    data: XOR<SuggestedUserCreateInput, SuggestedUserUncheckedCreateInput>
  }

  /**
   * SuggestedUser createMany
   */
  export type SuggestedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuggestedUsers.
     */
    data: SuggestedUserCreateManyInput | SuggestedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuggestedUser createManyAndReturn
   */
  export type SuggestedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SuggestedUsers.
     */
    data: SuggestedUserCreateManyInput | SuggestedUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuggestedUser update
   */
  export type SuggestedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a SuggestedUser.
     */
    data: XOR<SuggestedUserUpdateInput, SuggestedUserUncheckedUpdateInput>
    /**
     * Choose, which SuggestedUser to update.
     */
    where: SuggestedUserWhereUniqueInput
  }

  /**
   * SuggestedUser updateMany
   */
  export type SuggestedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuggestedUsers.
     */
    data: XOR<SuggestedUserUpdateManyMutationInput, SuggestedUserUncheckedUpdateManyInput>
    /**
     * Filter which SuggestedUsers to update
     */
    where?: SuggestedUserWhereInput
  }

  /**
   * SuggestedUser upsert
   */
  export type SuggestedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the SuggestedUser to update in case it exists.
     */
    where: SuggestedUserWhereUniqueInput
    /**
     * In case the SuggestedUser found by the `where` argument doesn't exist, create a new SuggestedUser with this data.
     */
    create: XOR<SuggestedUserCreateInput, SuggestedUserUncheckedCreateInput>
    /**
     * In case the SuggestedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestedUserUpdateInput, SuggestedUserUncheckedUpdateInput>
  }

  /**
   * SuggestedUser delete
   */
  export type SuggestedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
    /**
     * Filter which SuggestedUser to delete.
     */
    where: SuggestedUserWhereUniqueInput
  }

  /**
   * SuggestedUser deleteMany
   */
  export type SuggestedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuggestedUsers to delete
     */
    where?: SuggestedUserWhereInput
  }

  /**
   * SuggestedUser without action
   */
  export type SuggestedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuggestedUser
     */
    select?: SuggestedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestedUserInclude<ExtArgs> | null
  }


  /**
   * Model CityFeedCache
   */

  export type AggregateCityFeedCache = {
    _count: CityFeedCacheCountAggregateOutputType | null
    _min: CityFeedCacheMinAggregateOutputType | null
    _max: CityFeedCacheMaxAggregateOutputType | null
  }

  export type CityFeedCacheMinAggregateOutputType = {
    id: string | null
    city: string | null
    vibeId: string | null
    cachedAt: Date | null
  }

  export type CityFeedCacheMaxAggregateOutputType = {
    id: string | null
    city: string | null
    vibeId: string | null
    cachedAt: Date | null
  }

  export type CityFeedCacheCountAggregateOutputType = {
    id: number
    city: number
    vibeId: number
    cachedAt: number
    _all: number
  }


  export type CityFeedCacheMinAggregateInputType = {
    id?: true
    city?: true
    vibeId?: true
    cachedAt?: true
  }

  export type CityFeedCacheMaxAggregateInputType = {
    id?: true
    city?: true
    vibeId?: true
    cachedAt?: true
  }

  export type CityFeedCacheCountAggregateInputType = {
    id?: true
    city?: true
    vibeId?: true
    cachedAt?: true
    _all?: true
  }

  export type CityFeedCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CityFeedCache to aggregate.
     */
    where?: CityFeedCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CityFeedCaches to fetch.
     */
    orderBy?: CityFeedCacheOrderByWithRelationInput | CityFeedCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityFeedCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CityFeedCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CityFeedCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CityFeedCaches
    **/
    _count?: true | CityFeedCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityFeedCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityFeedCacheMaxAggregateInputType
  }

  export type GetCityFeedCacheAggregateType<T extends CityFeedCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCityFeedCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCityFeedCache[P]>
      : GetScalarType<T[P], AggregateCityFeedCache[P]>
  }




  export type CityFeedCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityFeedCacheWhereInput
    orderBy?: CityFeedCacheOrderByWithAggregationInput | CityFeedCacheOrderByWithAggregationInput[]
    by: CityFeedCacheScalarFieldEnum[] | CityFeedCacheScalarFieldEnum
    having?: CityFeedCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityFeedCacheCountAggregateInputType | true
    _min?: CityFeedCacheMinAggregateInputType
    _max?: CityFeedCacheMaxAggregateInputType
  }

  export type CityFeedCacheGroupByOutputType = {
    id: string
    city: string
    vibeId: string
    cachedAt: Date
    _count: CityFeedCacheCountAggregateOutputType | null
    _min: CityFeedCacheMinAggregateOutputType | null
    _max: CityFeedCacheMaxAggregateOutputType | null
  }

  type GetCityFeedCacheGroupByPayload<T extends CityFeedCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityFeedCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityFeedCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityFeedCacheGroupByOutputType[P]>
            : GetScalarType<T[P], CityFeedCacheGroupByOutputType[P]>
        }
      >
    >


  export type CityFeedCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    vibeId?: boolean
    cachedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cityFeedCache"]>

  export type CityFeedCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    vibeId?: boolean
    cachedAt?: boolean
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cityFeedCache"]>

  export type CityFeedCacheSelectScalar = {
    id?: boolean
    city?: boolean
    vibeId?: boolean
    cachedAt?: boolean
  }

  export type CityFeedCacheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }
  export type CityFeedCacheIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }

  export type $CityFeedCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CityFeedCache"
    objects: {
      vibe: Prisma.$VibePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      city: string
      vibeId: string
      cachedAt: Date
    }, ExtArgs["result"]["cityFeedCache"]>
    composites: {}
  }

  type CityFeedCacheGetPayload<S extends boolean | null | undefined | CityFeedCacheDefaultArgs> = $Result.GetResult<Prisma.$CityFeedCachePayload, S>

  type CityFeedCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFeedCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CityFeedCacheCountAggregateInputType | true
    }

  export interface CityFeedCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CityFeedCache'], meta: { name: 'CityFeedCache' } }
    /**
     * Find zero or one CityFeedCache that matches the filter.
     * @param {CityFeedCacheFindUniqueArgs} args - Arguments to find a CityFeedCache
     * @example
     * // Get one CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFeedCacheFindUniqueArgs>(args: SelectSubset<T, CityFeedCacheFindUniqueArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CityFeedCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CityFeedCacheFindUniqueOrThrowArgs} args - Arguments to find a CityFeedCache
     * @example
     * // Get one CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFeedCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFeedCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CityFeedCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheFindFirstArgs} args - Arguments to find a CityFeedCache
     * @example
     * // Get one CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFeedCacheFindFirstArgs>(args?: SelectSubset<T, CityFeedCacheFindFirstArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CityFeedCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheFindFirstOrThrowArgs} args - Arguments to find a CityFeedCache
     * @example
     * // Get one CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFeedCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFeedCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CityFeedCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CityFeedCaches
     * const cityFeedCaches = await prisma.cityFeedCache.findMany()
     * 
     * // Get first 10 CityFeedCaches
     * const cityFeedCaches = await prisma.cityFeedCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityFeedCacheWithIdOnly = await prisma.cityFeedCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFeedCacheFindManyArgs>(args?: SelectSubset<T, CityFeedCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CityFeedCache.
     * @param {CityFeedCacheCreateArgs} args - Arguments to create a CityFeedCache.
     * @example
     * // Create one CityFeedCache
     * const CityFeedCache = await prisma.cityFeedCache.create({
     *   data: {
     *     // ... data to create a CityFeedCache
     *   }
     * })
     * 
     */
    create<T extends CityFeedCacheCreateArgs>(args: SelectSubset<T, CityFeedCacheCreateArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CityFeedCaches.
     * @param {CityFeedCacheCreateManyArgs} args - Arguments to create many CityFeedCaches.
     * @example
     * // Create many CityFeedCaches
     * const cityFeedCache = await prisma.cityFeedCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityFeedCacheCreateManyArgs>(args?: SelectSubset<T, CityFeedCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CityFeedCaches and returns the data saved in the database.
     * @param {CityFeedCacheCreateManyAndReturnArgs} args - Arguments to create many CityFeedCaches.
     * @example
     * // Create many CityFeedCaches
     * const cityFeedCache = await prisma.cityFeedCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CityFeedCaches and only return the `id`
     * const cityFeedCacheWithIdOnly = await prisma.cityFeedCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityFeedCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, CityFeedCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CityFeedCache.
     * @param {CityFeedCacheDeleteArgs} args - Arguments to delete one CityFeedCache.
     * @example
     * // Delete one CityFeedCache
     * const CityFeedCache = await prisma.cityFeedCache.delete({
     *   where: {
     *     // ... filter to delete one CityFeedCache
     *   }
     * })
     * 
     */
    delete<T extends CityFeedCacheDeleteArgs>(args: SelectSubset<T, CityFeedCacheDeleteArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CityFeedCache.
     * @param {CityFeedCacheUpdateArgs} args - Arguments to update one CityFeedCache.
     * @example
     * // Update one CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityFeedCacheUpdateArgs>(args: SelectSubset<T, CityFeedCacheUpdateArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CityFeedCaches.
     * @param {CityFeedCacheDeleteManyArgs} args - Arguments to filter CityFeedCaches to delete.
     * @example
     * // Delete a few CityFeedCaches
     * const { count } = await prisma.cityFeedCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityFeedCacheDeleteManyArgs>(args?: SelectSubset<T, CityFeedCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CityFeedCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CityFeedCaches
     * const cityFeedCache = await prisma.cityFeedCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityFeedCacheUpdateManyArgs>(args: SelectSubset<T, CityFeedCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CityFeedCache.
     * @param {CityFeedCacheUpsertArgs} args - Arguments to update or create a CityFeedCache.
     * @example
     * // Update or create a CityFeedCache
     * const cityFeedCache = await prisma.cityFeedCache.upsert({
     *   create: {
     *     // ... data to create a CityFeedCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CityFeedCache we want to update
     *   }
     * })
     */
    upsert<T extends CityFeedCacheUpsertArgs>(args: SelectSubset<T, CityFeedCacheUpsertArgs<ExtArgs>>): Prisma__CityFeedCacheClient<$Result.GetResult<Prisma.$CityFeedCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CityFeedCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheCountArgs} args - Arguments to filter CityFeedCaches to count.
     * @example
     * // Count the number of CityFeedCaches
     * const count = await prisma.cityFeedCache.count({
     *   where: {
     *     // ... the filter for the CityFeedCaches we want to count
     *   }
     * })
    **/
    count<T extends CityFeedCacheCountArgs>(
      args?: Subset<T, CityFeedCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityFeedCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CityFeedCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityFeedCacheAggregateArgs>(args: Subset<T, CityFeedCacheAggregateArgs>): Prisma.PrismaPromise<GetCityFeedCacheAggregateType<T>>

    /**
     * Group by CityFeedCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFeedCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityFeedCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityFeedCacheGroupByArgs['orderBy'] }
        : { orderBy?: CityFeedCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityFeedCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityFeedCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CityFeedCache model
   */
  readonly fields: CityFeedCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CityFeedCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityFeedCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CityFeedCache model
   */ 
  interface CityFeedCacheFieldRefs {
    readonly id: FieldRef<"CityFeedCache", 'String'>
    readonly city: FieldRef<"CityFeedCache", 'String'>
    readonly vibeId: FieldRef<"CityFeedCache", 'String'>
    readonly cachedAt: FieldRef<"CityFeedCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CityFeedCache findUnique
   */
  export type CityFeedCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter, which CityFeedCache to fetch.
     */
    where: CityFeedCacheWhereUniqueInput
  }

  /**
   * CityFeedCache findUniqueOrThrow
   */
  export type CityFeedCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter, which CityFeedCache to fetch.
     */
    where: CityFeedCacheWhereUniqueInput
  }

  /**
   * CityFeedCache findFirst
   */
  export type CityFeedCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter, which CityFeedCache to fetch.
     */
    where?: CityFeedCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CityFeedCaches to fetch.
     */
    orderBy?: CityFeedCacheOrderByWithRelationInput | CityFeedCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CityFeedCaches.
     */
    cursor?: CityFeedCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CityFeedCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CityFeedCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CityFeedCaches.
     */
    distinct?: CityFeedCacheScalarFieldEnum | CityFeedCacheScalarFieldEnum[]
  }

  /**
   * CityFeedCache findFirstOrThrow
   */
  export type CityFeedCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter, which CityFeedCache to fetch.
     */
    where?: CityFeedCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CityFeedCaches to fetch.
     */
    orderBy?: CityFeedCacheOrderByWithRelationInput | CityFeedCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CityFeedCaches.
     */
    cursor?: CityFeedCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CityFeedCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CityFeedCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CityFeedCaches.
     */
    distinct?: CityFeedCacheScalarFieldEnum | CityFeedCacheScalarFieldEnum[]
  }

  /**
   * CityFeedCache findMany
   */
  export type CityFeedCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter, which CityFeedCaches to fetch.
     */
    where?: CityFeedCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CityFeedCaches to fetch.
     */
    orderBy?: CityFeedCacheOrderByWithRelationInput | CityFeedCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CityFeedCaches.
     */
    cursor?: CityFeedCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CityFeedCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CityFeedCaches.
     */
    skip?: number
    distinct?: CityFeedCacheScalarFieldEnum | CityFeedCacheScalarFieldEnum[]
  }

  /**
   * CityFeedCache create
   */
  export type CityFeedCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * The data needed to create a CityFeedCache.
     */
    data: XOR<CityFeedCacheCreateInput, CityFeedCacheUncheckedCreateInput>
  }

  /**
   * CityFeedCache createMany
   */
  export type CityFeedCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CityFeedCaches.
     */
    data: CityFeedCacheCreateManyInput | CityFeedCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CityFeedCache createManyAndReturn
   */
  export type CityFeedCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CityFeedCaches.
     */
    data: CityFeedCacheCreateManyInput | CityFeedCacheCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CityFeedCache update
   */
  export type CityFeedCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * The data needed to update a CityFeedCache.
     */
    data: XOR<CityFeedCacheUpdateInput, CityFeedCacheUncheckedUpdateInput>
    /**
     * Choose, which CityFeedCache to update.
     */
    where: CityFeedCacheWhereUniqueInput
  }

  /**
   * CityFeedCache updateMany
   */
  export type CityFeedCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CityFeedCaches.
     */
    data: XOR<CityFeedCacheUpdateManyMutationInput, CityFeedCacheUncheckedUpdateManyInput>
    /**
     * Filter which CityFeedCaches to update
     */
    where?: CityFeedCacheWhereInput
  }

  /**
   * CityFeedCache upsert
   */
  export type CityFeedCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * The filter to search for the CityFeedCache to update in case it exists.
     */
    where: CityFeedCacheWhereUniqueInput
    /**
     * In case the CityFeedCache found by the `where` argument doesn't exist, create a new CityFeedCache with this data.
     */
    create: XOR<CityFeedCacheCreateInput, CityFeedCacheUncheckedCreateInput>
    /**
     * In case the CityFeedCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityFeedCacheUpdateInput, CityFeedCacheUncheckedUpdateInput>
  }

  /**
   * CityFeedCache delete
   */
  export type CityFeedCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
    /**
     * Filter which CityFeedCache to delete.
     */
    where: CityFeedCacheWhereUniqueInput
  }

  /**
   * CityFeedCache deleteMany
   */
  export type CityFeedCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CityFeedCaches to delete
     */
    where?: CityFeedCacheWhereInput
  }

  /**
   * CityFeedCache without action
   */
  export type CityFeedCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityFeedCache
     */
    select?: CityFeedCacheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityFeedCacheInclude<ExtArgs> | null
  }


  /**
   * Model InviteQueue
   */

  export type AggregateInviteQueue = {
    _count: InviteQueueCountAggregateOutputType | null
    _min: InviteQueueMinAggregateOutputType | null
    _max: InviteQueueMaxAggregateOutputType | null
  }

  export type InviteQueueMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vibeId: string | null
    invitedAt: Date | null
  }

  export type InviteQueueMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vibeId: string | null
    invitedAt: Date | null
  }

  export type InviteQueueCountAggregateOutputType = {
    id: number
    userId: number
    vibeId: number
    invitedAt: number
    _all: number
  }


  export type InviteQueueMinAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    invitedAt?: true
  }

  export type InviteQueueMaxAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    invitedAt?: true
  }

  export type InviteQueueCountAggregateInputType = {
    id?: true
    userId?: true
    vibeId?: true
    invitedAt?: true
    _all?: true
  }

  export type InviteQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteQueue to aggregate.
     */
    where?: InviteQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteQueues to fetch.
     */
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InviteQueues
    **/
    _count?: true | InviteQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteQueueMaxAggregateInputType
  }

  export type GetInviteQueueAggregateType<T extends InviteQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateInviteQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInviteQueue[P]>
      : GetScalarType<T[P], AggregateInviteQueue[P]>
  }




  export type InviteQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteQueueWhereInput
    orderBy?: InviteQueueOrderByWithAggregationInput | InviteQueueOrderByWithAggregationInput[]
    by: InviteQueueScalarFieldEnum[] | InviteQueueScalarFieldEnum
    having?: InviteQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteQueueCountAggregateInputType | true
    _min?: InviteQueueMinAggregateInputType
    _max?: InviteQueueMaxAggregateInputType
  }

  export type InviteQueueGroupByOutputType = {
    id: string
    userId: string
    vibeId: string
    invitedAt: Date
    _count: InviteQueueCountAggregateOutputType | null
    _min: InviteQueueMinAggregateOutputType | null
    _max: InviteQueueMaxAggregateOutputType | null
  }

  type GetInviteQueueGroupByPayload<T extends InviteQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteQueueGroupByOutputType[P]>
            : GetScalarType<T[P], InviteQueueGroupByOutputType[P]>
        }
      >
    >


  export type InviteQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    invitedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteQueue"]>

  export type InviteQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    invitedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteQueue"]>

  export type InviteQueueSelectScalar = {
    id?: boolean
    userId?: boolean
    vibeId?: boolean
    invitedAt?: boolean
  }

  export type InviteQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }
  export type InviteQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vibe?: boolean | VibeDefaultArgs<ExtArgs>
  }

  export type $InviteQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InviteQueue"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vibe: Prisma.$VibePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vibeId: string
      invitedAt: Date
    }, ExtArgs["result"]["inviteQueue"]>
    composites: {}
  }

  type InviteQueueGetPayload<S extends boolean | null | undefined | InviteQueueDefaultArgs> = $Result.GetResult<Prisma.$InviteQueuePayload, S>

  type InviteQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteQueueCountAggregateInputType | true
    }

  export interface InviteQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InviteQueue'], meta: { name: 'InviteQueue' } }
    /**
     * Find zero or one InviteQueue that matches the filter.
     * @param {InviteQueueFindUniqueArgs} args - Arguments to find a InviteQueue
     * @example
     * // Get one InviteQueue
     * const inviteQueue = await prisma.inviteQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteQueueFindUniqueArgs>(args: SelectSubset<T, InviteQueueFindUniqueArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InviteQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteQueueFindUniqueOrThrowArgs} args - Arguments to find a InviteQueue
     * @example
     * // Get one InviteQueue
     * const inviteQueue = await prisma.inviteQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InviteQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueFindFirstArgs} args - Arguments to find a InviteQueue
     * @example
     * // Get one InviteQueue
     * const inviteQueue = await prisma.inviteQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteQueueFindFirstArgs>(args?: SelectSubset<T, InviteQueueFindFirstArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InviteQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueFindFirstOrThrowArgs} args - Arguments to find a InviteQueue
     * @example
     * // Get one InviteQueue
     * const inviteQueue = await prisma.inviteQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InviteQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InviteQueues
     * const inviteQueues = await prisma.inviteQueue.findMany()
     * 
     * // Get first 10 InviteQueues
     * const inviteQueues = await prisma.inviteQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteQueueWithIdOnly = await prisma.inviteQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteQueueFindManyArgs>(args?: SelectSubset<T, InviteQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InviteQueue.
     * @param {InviteQueueCreateArgs} args - Arguments to create a InviteQueue.
     * @example
     * // Create one InviteQueue
     * const InviteQueue = await prisma.inviteQueue.create({
     *   data: {
     *     // ... data to create a InviteQueue
     *   }
     * })
     * 
     */
    create<T extends InviteQueueCreateArgs>(args: SelectSubset<T, InviteQueueCreateArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InviteQueues.
     * @param {InviteQueueCreateManyArgs} args - Arguments to create many InviteQueues.
     * @example
     * // Create many InviteQueues
     * const inviteQueue = await prisma.inviteQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteQueueCreateManyArgs>(args?: SelectSubset<T, InviteQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InviteQueues and returns the data saved in the database.
     * @param {InviteQueueCreateManyAndReturnArgs} args - Arguments to create many InviteQueues.
     * @example
     * // Create many InviteQueues
     * const inviteQueue = await prisma.inviteQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InviteQueues and only return the `id`
     * const inviteQueueWithIdOnly = await prisma.inviteQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InviteQueue.
     * @param {InviteQueueDeleteArgs} args - Arguments to delete one InviteQueue.
     * @example
     * // Delete one InviteQueue
     * const InviteQueue = await prisma.inviteQueue.delete({
     *   where: {
     *     // ... filter to delete one InviteQueue
     *   }
     * })
     * 
     */
    delete<T extends InviteQueueDeleteArgs>(args: SelectSubset<T, InviteQueueDeleteArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InviteQueue.
     * @param {InviteQueueUpdateArgs} args - Arguments to update one InviteQueue.
     * @example
     * // Update one InviteQueue
     * const inviteQueue = await prisma.inviteQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteQueueUpdateArgs>(args: SelectSubset<T, InviteQueueUpdateArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InviteQueues.
     * @param {InviteQueueDeleteManyArgs} args - Arguments to filter InviteQueues to delete.
     * @example
     * // Delete a few InviteQueues
     * const { count } = await prisma.inviteQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteQueueDeleteManyArgs>(args?: SelectSubset<T, InviteQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InviteQueues
     * const inviteQueue = await prisma.inviteQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteQueueUpdateManyArgs>(args: SelectSubset<T, InviteQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InviteQueue.
     * @param {InviteQueueUpsertArgs} args - Arguments to update or create a InviteQueue.
     * @example
     * // Update or create a InviteQueue
     * const inviteQueue = await prisma.inviteQueue.upsert({
     *   create: {
     *     // ... data to create a InviteQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InviteQueue we want to update
     *   }
     * })
     */
    upsert<T extends InviteQueueUpsertArgs>(args: SelectSubset<T, InviteQueueUpsertArgs<ExtArgs>>): Prisma__InviteQueueClient<$Result.GetResult<Prisma.$InviteQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InviteQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueCountArgs} args - Arguments to filter InviteQueues to count.
     * @example
     * // Count the number of InviteQueues
     * const count = await prisma.inviteQueue.count({
     *   where: {
     *     // ... the filter for the InviteQueues we want to count
     *   }
     * })
    **/
    count<T extends InviteQueueCountArgs>(
      args?: Subset<T, InviteQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InviteQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteQueueAggregateArgs>(args: Subset<T, InviteQueueAggregateArgs>): Prisma.PrismaPromise<GetInviteQueueAggregateType<T>>

    /**
     * Group by InviteQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteQueueGroupByArgs['orderBy'] }
        : { orderBy?: InviteQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InviteQueue model
   */
  readonly fields: InviteQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InviteQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vibe<T extends VibeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VibeDefaultArgs<ExtArgs>>): Prisma__VibeClient<$Result.GetResult<Prisma.$VibePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InviteQueue model
   */ 
  interface InviteQueueFieldRefs {
    readonly id: FieldRef<"InviteQueue", 'String'>
    readonly userId: FieldRef<"InviteQueue", 'String'>
    readonly vibeId: FieldRef<"InviteQueue", 'String'>
    readonly invitedAt: FieldRef<"InviteQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InviteQueue findUnique
   */
  export type InviteQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter, which InviteQueue to fetch.
     */
    where: InviteQueueWhereUniqueInput
  }

  /**
   * InviteQueue findUniqueOrThrow
   */
  export type InviteQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter, which InviteQueue to fetch.
     */
    where: InviteQueueWhereUniqueInput
  }

  /**
   * InviteQueue findFirst
   */
  export type InviteQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter, which InviteQueue to fetch.
     */
    where?: InviteQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteQueues to fetch.
     */
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteQueues.
     */
    cursor?: InviteQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteQueues.
     */
    distinct?: InviteQueueScalarFieldEnum | InviteQueueScalarFieldEnum[]
  }

  /**
   * InviteQueue findFirstOrThrow
   */
  export type InviteQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter, which InviteQueue to fetch.
     */
    where?: InviteQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteQueues to fetch.
     */
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteQueues.
     */
    cursor?: InviteQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteQueues.
     */
    distinct?: InviteQueueScalarFieldEnum | InviteQueueScalarFieldEnum[]
  }

  /**
   * InviteQueue findMany
   */
  export type InviteQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter, which InviteQueues to fetch.
     */
    where?: InviteQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteQueues to fetch.
     */
    orderBy?: InviteQueueOrderByWithRelationInput | InviteQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InviteQueues.
     */
    cursor?: InviteQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteQueues.
     */
    skip?: number
    distinct?: InviteQueueScalarFieldEnum | InviteQueueScalarFieldEnum[]
  }

  /**
   * InviteQueue create
   */
  export type InviteQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a InviteQueue.
     */
    data: XOR<InviteQueueCreateInput, InviteQueueUncheckedCreateInput>
  }

  /**
   * InviteQueue createMany
   */
  export type InviteQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InviteQueues.
     */
    data: InviteQueueCreateManyInput | InviteQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InviteQueue createManyAndReturn
   */
  export type InviteQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InviteQueues.
     */
    data: InviteQueueCreateManyInput | InviteQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteQueue update
   */
  export type InviteQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a InviteQueue.
     */
    data: XOR<InviteQueueUpdateInput, InviteQueueUncheckedUpdateInput>
    /**
     * Choose, which InviteQueue to update.
     */
    where: InviteQueueWhereUniqueInput
  }

  /**
   * InviteQueue updateMany
   */
  export type InviteQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InviteQueues.
     */
    data: XOR<InviteQueueUpdateManyMutationInput, InviteQueueUncheckedUpdateManyInput>
    /**
     * Filter which InviteQueues to update
     */
    where?: InviteQueueWhereInput
  }

  /**
   * InviteQueue upsert
   */
  export type InviteQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the InviteQueue to update in case it exists.
     */
    where: InviteQueueWhereUniqueInput
    /**
     * In case the InviteQueue found by the `where` argument doesn't exist, create a new InviteQueue with this data.
     */
    create: XOR<InviteQueueCreateInput, InviteQueueUncheckedCreateInput>
    /**
     * In case the InviteQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteQueueUpdateInput, InviteQueueUncheckedUpdateInput>
  }

  /**
   * InviteQueue delete
   */
  export type InviteQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
    /**
     * Filter which InviteQueue to delete.
     */
    where: InviteQueueWhereUniqueInput
  }

  /**
   * InviteQueue deleteMany
   */
  export type InviteQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteQueues to delete
     */
    where?: InviteQueueWhereInput
  }

  /**
   * InviteQueue without action
   */
  export type InviteQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteQueue
     */
    select?: InviteQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteQueueInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    model: string | null
    modelId: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    model: string | null
    modelId: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    model: number
    modelId: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    model?: true
    modelId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    model?: true
    modelId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    model?: true
    modelId?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    model: string
    modelId: string
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    model?: boolean
    modelId?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    model?: boolean
    modelId?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    model?: boolean
    modelId?: boolean
    timestamp?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      model: string
      modelId: string
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly model: FieldRef<"AuditLog", 'String'>
    readonly modelId: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    phoneNumber: 'phoneNumber',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    bio: 'bio',
    city: 'city',
    profilePicture: 'profilePicture',
    timeZone: 'timeZone',
    joinedAt: 'joinedAt',
    inviteCode: 'inviteCode',
    invitedById: 'invitedById',
    isDeleted: 'isDeleted',
    firebaseUid: 'firebaseUid'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VibeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    startDate: 'startDate',
    endDate: 'endDate',
    coverMediaId: 'coverMediaId',
    createdById: 'createdById',
    isShared: 'isShared',
    status: 'status',
    finalizedAt: 'finalizedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VibeScalarFieldEnum = (typeof VibeScalarFieldEnum)[keyof typeof VibeScalarFieldEnum]


  export const VibeContributorScalarFieldEnum: {
    id: 'id',
    vibeId: 'vibeId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    hasUploaded: 'hasUploaded',
    leftAt: 'leftAt'
  };

  export type VibeContributorScalarFieldEnum = (typeof VibeContributorScalarFieldEnum)[keyof typeof VibeContributorScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    vibeId: 'vibeId',
    uploadedById: 'uploadedById',
    mediaType: 'mediaType',
    mediaUrl: 'mediaUrl',
    thumbnailUrl: 'thumbnailUrl',
    caption: 'caption',
    timestamp: 'timestamp',
    exifData: 'exifData',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const VibeViewerScalarFieldEnum: {
    id: 'id',
    vibeId: 'vibeId',
    viewerId: 'viewerId',
    viewedAt: 'viewedAt'
  };

  export type VibeViewerScalarFieldEnum = (typeof VibeViewerScalarFieldEnum)[keyof typeof VibeViewerScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mediaId: 'mediaId',
    favoritedAt: 'favoritedAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    senderId: 'senderId',
    type: 'type',
    message: 'message',
    vibeId: 'vibeId',
    mediaId: 'mediaId',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DraftScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vibeId: 'vibeId',
    lastEditedAt: 'lastEditedAt',
    expiresAt: 'expiresAt'
  };

  export type DraftScalarFieldEnum = (typeof DraftScalarFieldEnum)[keyof typeof DraftScalarFieldEnum]


  export const VibeInviteScalarFieldEnum: {
    id: 'id',
    vibeId: 'vibeId',
    invitedUserId: 'invitedUserId',
    invitedById: 'invitedById',
    status: 'status',
    invitedAt: 'invitedAt',
    respondedAt: 'respondedAt'
  };

  export type VibeInviteScalarFieldEnum = (typeof VibeInviteScalarFieldEnum)[keyof typeof VibeInviteScalarFieldEnum]


  export const MediaFlagScalarFieldEnum: {
    id: 'id',
    mediaId: 'mediaId',
    flaggedById: 'flaggedById',
    reason: 'reason',
    additionalInfo: 'additionalInfo',
    flaggedAt: 'flaggedAt'
  };

  export type MediaFlagScalarFieldEnum = (typeof MediaFlagScalarFieldEnum)[keyof typeof MediaFlagScalarFieldEnum]


  export const FeedEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    vibeId: 'vibeId',
    createdAt: 'createdAt'
  };

  export type FeedEventScalarFieldEnum = (typeof FeedEventScalarFieldEnum)[keyof typeof FeedEventScalarFieldEnum]


  export const SuggestedUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    suggestedUserId: 'suggestedUserId',
    reason: 'reason',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type SuggestedUserScalarFieldEnum = (typeof SuggestedUserScalarFieldEnum)[keyof typeof SuggestedUserScalarFieldEnum]


  export const CityFeedCacheScalarFieldEnum: {
    id: 'id',
    city: 'city',
    vibeId: 'vibeId',
    cachedAt: 'cachedAt'
  };

  export type CityFeedCacheScalarFieldEnum = (typeof CityFeedCacheScalarFieldEnum)[keyof typeof CityFeedCacheScalarFieldEnum]


  export const InviteQueueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vibeId: 'vibeId',
    invitedAt: 'invitedAt'
  };

  export type InviteQueueScalarFieldEnum = (typeof InviteQueueScalarFieldEnum)[keyof typeof InviteQueueScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    model: 'model',
    modelId: 'modelId',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    timeZone?: StringNullableFilter<"User"> | string | null
    joinedAt?: DateTimeFilter<"User"> | Date | string
    inviteCode?: StringNullableFilter<"User"> | string | null
    invitedById?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    firebaseUid?: StringNullableFilter<"User"> | string | null
    invitedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    invitedUsers?: UserListRelationFilter
    createdVibes?: VibeListRelationFilter
    contributedVibes?: VibeContributorListRelationFilter
    media?: MediaListRelationFilter
    vibeViews?: VibeViewerListRelationFilter
    favorites?: FavoriteListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    drafts?: DraftListRelationFilter
    invites?: VibeInviteListRelationFilter
    sentInvites?: VibeInviteListRelationFilter
    suggestedTo?: SuggestedUserListRelationFilter
    suggestedFrom?: SuggestedUserListRelationFilter
    feedEvents?: FeedEventListRelationFilter
    inviteQueue?: InviteQueueListRelationFilter
    flaggedMedia?: MediaFlagListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    timeZone?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    inviteCode?: SortOrderInput | SortOrder
    invitedById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    firebaseUid?: SortOrderInput | SortOrder
    invitedBy?: UserOrderByWithRelationInput
    invitedUsers?: UserOrderByRelationAggregateInput
    createdVibes?: VibeOrderByRelationAggregateInput
    contributedVibes?: VibeContributorOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    vibeViews?: VibeViewerOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    drafts?: DraftOrderByRelationAggregateInput
    invites?: VibeInviteOrderByRelationAggregateInput
    sentInvites?: VibeInviteOrderByRelationAggregateInput
    suggestedTo?: SuggestedUserOrderByRelationAggregateInput
    suggestedFrom?: SuggestedUserOrderByRelationAggregateInput
    feedEvents?: FeedEventOrderByRelationAggregateInput
    inviteQueue?: InviteQueueOrderByRelationAggregateInput
    flaggedMedia?: MediaFlagOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    phoneNumber?: string
    email?: string
    firebaseUid?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    timeZone?: StringNullableFilter<"User"> | string | null
    joinedAt?: DateTimeFilter<"User"> | Date | string
    inviteCode?: StringNullableFilter<"User"> | string | null
    invitedById?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    invitedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    invitedUsers?: UserListRelationFilter
    createdVibes?: VibeListRelationFilter
    contributedVibes?: VibeContributorListRelationFilter
    media?: MediaListRelationFilter
    vibeViews?: VibeViewerListRelationFilter
    favorites?: FavoriteListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    drafts?: DraftListRelationFilter
    invites?: VibeInviteListRelationFilter
    sentInvites?: VibeInviteListRelationFilter
    suggestedTo?: SuggestedUserListRelationFilter
    suggestedFrom?: SuggestedUserListRelationFilter
    feedEvents?: FeedEventListRelationFilter
    inviteQueue?: InviteQueueListRelationFilter
    flaggedMedia?: MediaFlagListRelationFilter
  }, "id" | "username" | "phoneNumber" | "email" | "firebaseUid">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    timeZone?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    inviteCode?: SortOrderInput | SortOrder
    invitedById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    firebaseUid?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    timeZone?: StringNullableWithAggregatesFilter<"User"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    inviteCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    invitedById?: StringNullableWithAggregatesFilter<"User"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    firebaseUid?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VibeWhereInput = {
    AND?: VibeWhereInput | VibeWhereInput[]
    OR?: VibeWhereInput[]
    NOT?: VibeWhereInput | VibeWhereInput[]
    id?: StringFilter<"Vibe"> | string
    title?: StringFilter<"Vibe"> | string
    description?: StringNullableFilter<"Vibe"> | string | null
    location?: StringNullableFilter<"Vibe"> | string | null
    startDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    coverMediaId?: StringNullableFilter<"Vibe"> | string | null
    createdById?: StringFilter<"Vibe"> | string
    isShared?: BoolFilter<"Vibe"> | boolean
    status?: StringFilter<"Vibe"> | string
    finalizedAt?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    createdAt?: DateTimeFilter<"Vibe"> | Date | string
    updatedAt?: DateTimeFilter<"Vibe"> | Date | string
    coverMedia?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    contributors?: VibeContributorListRelationFilter
    media?: MediaListRelationFilter
    viewers?: VibeViewerListRelationFilter
    drafts?: DraftListRelationFilter
    invites?: VibeInviteListRelationFilter
    notifications?: NotificationListRelationFilter
    feedEvents?: FeedEventListRelationFilter
    cityFeedCache?: CityFeedCacheListRelationFilter
    inviteQueue?: InviteQueueListRelationFilter
  }

  export type VibeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    coverMediaId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isShared?: SortOrder
    status?: SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coverMedia?: MediaOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    contributors?: VibeContributorOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    viewers?: VibeViewerOrderByRelationAggregateInput
    drafts?: DraftOrderByRelationAggregateInput
    invites?: VibeInviteOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    feedEvents?: FeedEventOrderByRelationAggregateInput
    cityFeedCache?: CityFeedCacheOrderByRelationAggregateInput
    inviteQueue?: InviteQueueOrderByRelationAggregateInput
  }

  export type VibeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    coverMediaId?: string
    AND?: VibeWhereInput | VibeWhereInput[]
    OR?: VibeWhereInput[]
    NOT?: VibeWhereInput | VibeWhereInput[]
    title?: StringFilter<"Vibe"> | string
    description?: StringNullableFilter<"Vibe"> | string | null
    location?: StringNullableFilter<"Vibe"> | string | null
    startDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    createdById?: StringFilter<"Vibe"> | string
    isShared?: BoolFilter<"Vibe"> | boolean
    status?: StringFilter<"Vibe"> | string
    finalizedAt?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    createdAt?: DateTimeFilter<"Vibe"> | Date | string
    updatedAt?: DateTimeFilter<"Vibe"> | Date | string
    coverMedia?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    contributors?: VibeContributorListRelationFilter
    media?: MediaListRelationFilter
    viewers?: VibeViewerListRelationFilter
    drafts?: DraftListRelationFilter
    invites?: VibeInviteListRelationFilter
    notifications?: NotificationListRelationFilter
    feedEvents?: FeedEventListRelationFilter
    cityFeedCache?: CityFeedCacheListRelationFilter
    inviteQueue?: InviteQueueListRelationFilter
  }, "id" | "coverMediaId">

  export type VibeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    coverMediaId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isShared?: SortOrder
    status?: SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VibeCountOrderByAggregateInput
    _max?: VibeMaxOrderByAggregateInput
    _min?: VibeMinOrderByAggregateInput
  }

  export type VibeScalarWhereWithAggregatesInput = {
    AND?: VibeScalarWhereWithAggregatesInput | VibeScalarWhereWithAggregatesInput[]
    OR?: VibeScalarWhereWithAggregatesInput[]
    NOT?: VibeScalarWhereWithAggregatesInput | VibeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vibe"> | string
    title?: StringWithAggregatesFilter<"Vibe"> | string
    description?: StringNullableWithAggregatesFilter<"Vibe"> | string | null
    location?: StringNullableWithAggregatesFilter<"Vibe"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Vibe"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Vibe"> | Date | string | null
    coverMediaId?: StringNullableWithAggregatesFilter<"Vibe"> | string | null
    createdById?: StringWithAggregatesFilter<"Vibe"> | string
    isShared?: BoolWithAggregatesFilter<"Vibe"> | boolean
    status?: StringWithAggregatesFilter<"Vibe"> | string
    finalizedAt?: DateTimeNullableWithAggregatesFilter<"Vibe"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vibe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vibe"> | Date | string
  }

  export type VibeContributorWhereInput = {
    AND?: VibeContributorWhereInput | VibeContributorWhereInput[]
    OR?: VibeContributorWhereInput[]
    NOT?: VibeContributorWhereInput | VibeContributorWhereInput[]
    id?: StringFilter<"VibeContributor"> | string
    vibeId?: StringFilter<"VibeContributor"> | string
    userId?: StringFilter<"VibeContributor"> | string
    role?: StringFilter<"VibeContributor"> | string
    joinedAt?: DateTimeFilter<"VibeContributor"> | Date | string
    hasUploaded?: BoolFilter<"VibeContributor"> | boolean
    leftAt?: DateTimeNullableFilter<"VibeContributor"> | Date | string | null
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VibeContributorOrderByWithRelationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    hasUploaded?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    vibe?: VibeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VibeContributorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VibeContributorWhereInput | VibeContributorWhereInput[]
    OR?: VibeContributorWhereInput[]
    NOT?: VibeContributorWhereInput | VibeContributorWhereInput[]
    vibeId?: StringFilter<"VibeContributor"> | string
    userId?: StringFilter<"VibeContributor"> | string
    role?: StringFilter<"VibeContributor"> | string
    joinedAt?: DateTimeFilter<"VibeContributor"> | Date | string
    hasUploaded?: BoolFilter<"VibeContributor"> | boolean
    leftAt?: DateTimeNullableFilter<"VibeContributor"> | Date | string | null
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VibeContributorOrderByWithAggregationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    hasUploaded?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    _count?: VibeContributorCountOrderByAggregateInput
    _max?: VibeContributorMaxOrderByAggregateInput
    _min?: VibeContributorMinOrderByAggregateInput
  }

  export type VibeContributorScalarWhereWithAggregatesInput = {
    AND?: VibeContributorScalarWhereWithAggregatesInput | VibeContributorScalarWhereWithAggregatesInput[]
    OR?: VibeContributorScalarWhereWithAggregatesInput[]
    NOT?: VibeContributorScalarWhereWithAggregatesInput | VibeContributorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VibeContributor"> | string
    vibeId?: StringWithAggregatesFilter<"VibeContributor"> | string
    userId?: StringWithAggregatesFilter<"VibeContributor"> | string
    role?: StringWithAggregatesFilter<"VibeContributor"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"VibeContributor"> | Date | string
    hasUploaded?: BoolWithAggregatesFilter<"VibeContributor"> | boolean
    leftAt?: DateTimeNullableWithAggregatesFilter<"VibeContributor"> | Date | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    vibeId?: StringFilter<"Media"> | string
    uploadedById?: StringFilter<"Media"> | string
    mediaType?: StringFilter<"Media"> | string
    mediaUrl?: StringFilter<"Media"> | string
    thumbnailUrl?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    timestamp?: DateTimeNullableFilter<"Media"> | Date | string | null
    exifData?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
    favoritedBy?: FavoriteListRelationFilter
    coverOfVibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
    flags?: MediaFlagListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    uploadedById?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    exifData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    vibe?: VibeOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    favoritedBy?: FavoriteOrderByRelationAggregateInput
    coverOfVibe?: VibeOrderByWithRelationInput
    flags?: MediaFlagOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    vibeId?: StringFilter<"Media"> | string
    uploadedById?: StringFilter<"Media"> | string
    mediaType?: StringFilter<"Media"> | string
    mediaUrl?: StringFilter<"Media"> | string
    thumbnailUrl?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    timestamp?: DateTimeNullableFilter<"Media"> | Date | string | null
    exifData?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
    favoritedBy?: FavoriteListRelationFilter
    coverOfVibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
    flags?: MediaFlagListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    uploadedById?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    exifData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    vibeId?: StringWithAggregatesFilter<"Media"> | string
    uploadedById?: StringWithAggregatesFilter<"Media"> | string
    mediaType?: StringWithAggregatesFilter<"Media"> | string
    mediaUrl?: StringWithAggregatesFilter<"Media"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Media"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Media"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    exifData?: JsonNullableWithAggregatesFilter<"Media">
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type VibeViewerWhereInput = {
    AND?: VibeViewerWhereInput | VibeViewerWhereInput[]
    OR?: VibeViewerWhereInput[]
    NOT?: VibeViewerWhereInput | VibeViewerWhereInput[]
    id?: StringFilter<"VibeViewer"> | string
    vibeId?: StringFilter<"VibeViewer"> | string
    viewerId?: StringFilter<"VibeViewer"> | string
    viewedAt?: DateTimeFilter<"VibeViewer"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    viewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VibeViewerOrderByWithRelationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    viewerId?: SortOrder
    viewedAt?: SortOrder
    vibe?: VibeOrderByWithRelationInput
    viewer?: UserOrderByWithRelationInput
  }

  export type VibeViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VibeViewerWhereInput | VibeViewerWhereInput[]
    OR?: VibeViewerWhereInput[]
    NOT?: VibeViewerWhereInput | VibeViewerWhereInput[]
    vibeId?: StringFilter<"VibeViewer"> | string
    viewerId?: StringFilter<"VibeViewer"> | string
    viewedAt?: DateTimeFilter<"VibeViewer"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    viewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VibeViewerOrderByWithAggregationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    viewerId?: SortOrder
    viewedAt?: SortOrder
    _count?: VibeViewerCountOrderByAggregateInput
    _max?: VibeViewerMaxOrderByAggregateInput
    _min?: VibeViewerMinOrderByAggregateInput
  }

  export type VibeViewerScalarWhereWithAggregatesInput = {
    AND?: VibeViewerScalarWhereWithAggregatesInput | VibeViewerScalarWhereWithAggregatesInput[]
    OR?: VibeViewerScalarWhereWithAggregatesInput[]
    NOT?: VibeViewerScalarWhereWithAggregatesInput | VibeViewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VibeViewer"> | string
    vibeId?: StringWithAggregatesFilter<"VibeViewer"> | string
    viewerId?: StringWithAggregatesFilter<"VibeViewer"> | string
    viewedAt?: DateTimeWithAggregatesFilter<"VibeViewer"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    mediaId?: StringFilter<"Favorite"> | string
    favoritedAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaId?: SortOrder
    favoritedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: StringFilter<"Favorite"> | string
    mediaId?: StringFilter<"Favorite"> | string
    favoritedAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    media?: XOR<MediaRelationFilter, MediaWhereInput>
  }, "id">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaId?: SortOrder
    favoritedAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: StringWithAggregatesFilter<"Favorite"> | string
    mediaId?: StringWithAggregatesFilter<"Favorite"> | string
    favoritedAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    vibeId?: StringNullableFilter<"Notification"> | string | null
    mediaId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    vibeId?: SortOrderInput | SortOrder
    mediaId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    vibe?: VibeOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    vibeId?: StringNullableFilter<"Notification"> | string | null
    mediaId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    vibeId?: SortOrderInput | SortOrder
    mediaId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    vibeId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    mediaId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DraftWhereInput = {
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    id?: StringFilter<"Draft"> | string
    userId?: StringFilter<"Draft"> | string
    vibeId?: StringFilter<"Draft"> | string
    lastEditedAt?: DateTimeFilter<"Draft"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }

  export type DraftOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    lastEditedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    vibe?: VibeOrderByWithRelationInput
  }

  export type DraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    userId?: StringFilter<"Draft"> | string
    vibeId?: StringFilter<"Draft"> | string
    lastEditedAt?: DateTimeFilter<"Draft"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }, "id">

  export type DraftOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    lastEditedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: DraftCountOrderByAggregateInput
    _max?: DraftMaxOrderByAggregateInput
    _min?: DraftMinOrderByAggregateInput
  }

  export type DraftScalarWhereWithAggregatesInput = {
    AND?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    OR?: DraftScalarWhereWithAggregatesInput[]
    NOT?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Draft"> | string
    userId?: StringWithAggregatesFilter<"Draft"> | string
    vibeId?: StringWithAggregatesFilter<"Draft"> | string
    lastEditedAt?: DateTimeWithAggregatesFilter<"Draft"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Draft"> | Date | string | null
  }

  export type VibeInviteWhereInput = {
    AND?: VibeInviteWhereInput | VibeInviteWhereInput[]
    OR?: VibeInviteWhereInput[]
    NOT?: VibeInviteWhereInput | VibeInviteWhereInput[]
    id?: StringFilter<"VibeInvite"> | string
    vibeId?: StringFilter<"VibeInvite"> | string
    invitedUserId?: StringFilter<"VibeInvite"> | string
    invitedById?: StringFilter<"VibeInvite"> | string
    status?: StringFilter<"VibeInvite"> | string
    invitedAt?: DateTimeFilter<"VibeInvite"> | Date | string
    respondedAt?: DateTimeNullableFilter<"VibeInvite"> | Date | string | null
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VibeInviteOrderByWithRelationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    invitedUserId?: SortOrder
    invitedById?: SortOrder
    status?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    vibe?: VibeOrderByWithRelationInput
    invitedUser?: UserOrderByWithRelationInput
    invitedBy?: UserOrderByWithRelationInput
  }

  export type VibeInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VibeInviteWhereInput | VibeInviteWhereInput[]
    OR?: VibeInviteWhereInput[]
    NOT?: VibeInviteWhereInput | VibeInviteWhereInput[]
    vibeId?: StringFilter<"VibeInvite"> | string
    invitedUserId?: StringFilter<"VibeInvite"> | string
    invitedById?: StringFilter<"VibeInvite"> | string
    status?: StringFilter<"VibeInvite"> | string
    invitedAt?: DateTimeFilter<"VibeInvite"> | Date | string
    respondedAt?: DateTimeNullableFilter<"VibeInvite"> | Date | string | null
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
    invitedUser?: XOR<UserRelationFilter, UserWhereInput>
    invitedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VibeInviteOrderByWithAggregationInput = {
    id?: SortOrder
    vibeId?: SortOrder
    invitedUserId?: SortOrder
    invitedById?: SortOrder
    status?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: VibeInviteCountOrderByAggregateInput
    _max?: VibeInviteMaxOrderByAggregateInput
    _min?: VibeInviteMinOrderByAggregateInput
  }

  export type VibeInviteScalarWhereWithAggregatesInput = {
    AND?: VibeInviteScalarWhereWithAggregatesInput | VibeInviteScalarWhereWithAggregatesInput[]
    OR?: VibeInviteScalarWhereWithAggregatesInput[]
    NOT?: VibeInviteScalarWhereWithAggregatesInput | VibeInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VibeInvite"> | string
    vibeId?: StringWithAggregatesFilter<"VibeInvite"> | string
    invitedUserId?: StringWithAggregatesFilter<"VibeInvite"> | string
    invitedById?: StringWithAggregatesFilter<"VibeInvite"> | string
    status?: StringWithAggregatesFilter<"VibeInvite"> | string
    invitedAt?: DateTimeWithAggregatesFilter<"VibeInvite"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"VibeInvite"> | Date | string | null
  }

  export type MediaFlagWhereInput = {
    AND?: MediaFlagWhereInput | MediaFlagWhereInput[]
    OR?: MediaFlagWhereInput[]
    NOT?: MediaFlagWhereInput | MediaFlagWhereInput[]
    id?: StringFilter<"MediaFlag"> | string
    mediaId?: StringFilter<"MediaFlag"> | string
    flaggedById?: StringFilter<"MediaFlag"> | string
    reason?: StringFilter<"MediaFlag"> | string
    additionalInfo?: StringNullableFilter<"MediaFlag"> | string | null
    flaggedAt?: DateTimeFilter<"MediaFlag"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
    flaggedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MediaFlagOrderByWithRelationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    flaggedById?: SortOrder
    reason?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    flaggedAt?: SortOrder
    media?: MediaOrderByWithRelationInput
    flaggedBy?: UserOrderByWithRelationInput
  }

  export type MediaFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaFlagWhereInput | MediaFlagWhereInput[]
    OR?: MediaFlagWhereInput[]
    NOT?: MediaFlagWhereInput | MediaFlagWhereInput[]
    mediaId?: StringFilter<"MediaFlag"> | string
    flaggedById?: StringFilter<"MediaFlag"> | string
    reason?: StringFilter<"MediaFlag"> | string
    additionalInfo?: StringNullableFilter<"MediaFlag"> | string | null
    flaggedAt?: DateTimeFilter<"MediaFlag"> | Date | string
    media?: XOR<MediaRelationFilter, MediaWhereInput>
    flaggedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MediaFlagOrderByWithAggregationInput = {
    id?: SortOrder
    mediaId?: SortOrder
    flaggedById?: SortOrder
    reason?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    flaggedAt?: SortOrder
    _count?: MediaFlagCountOrderByAggregateInput
    _max?: MediaFlagMaxOrderByAggregateInput
    _min?: MediaFlagMinOrderByAggregateInput
  }

  export type MediaFlagScalarWhereWithAggregatesInput = {
    AND?: MediaFlagScalarWhereWithAggregatesInput | MediaFlagScalarWhereWithAggregatesInput[]
    OR?: MediaFlagScalarWhereWithAggregatesInput[]
    NOT?: MediaFlagScalarWhereWithAggregatesInput | MediaFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaFlag"> | string
    mediaId?: StringWithAggregatesFilter<"MediaFlag"> | string
    flaggedById?: StringWithAggregatesFilter<"MediaFlag"> | string
    reason?: StringWithAggregatesFilter<"MediaFlag"> | string
    additionalInfo?: StringNullableWithAggregatesFilter<"MediaFlag"> | string | null
    flaggedAt?: DateTimeWithAggregatesFilter<"MediaFlag"> | Date | string
  }

  export type FeedEventWhereInput = {
    AND?: FeedEventWhereInput | FeedEventWhereInput[]
    OR?: FeedEventWhereInput[]
    NOT?: FeedEventWhereInput | FeedEventWhereInput[]
    id?: StringFilter<"FeedEvent"> | string
    userId?: StringFilter<"FeedEvent"> | string
    eventType?: StringFilter<"FeedEvent"> | string
    vibeId?: StringNullableFilter<"FeedEvent"> | string | null
    createdAt?: DateTimeFilter<"FeedEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
  }

  export type FeedEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    vibeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vibe?: VibeOrderByWithRelationInput
  }

  export type FeedEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedEventWhereInput | FeedEventWhereInput[]
    OR?: FeedEventWhereInput[]
    NOT?: FeedEventWhereInput | FeedEventWhereInput[]
    userId?: StringFilter<"FeedEvent"> | string
    eventType?: StringFilter<"FeedEvent"> | string
    vibeId?: StringNullableFilter<"FeedEvent"> | string | null
    createdAt?: DateTimeFilter<"FeedEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeNullableRelationFilter, VibeWhereInput> | null
  }, "id">

  export type FeedEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    vibeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedEventCountOrderByAggregateInput
    _max?: FeedEventMaxOrderByAggregateInput
    _min?: FeedEventMinOrderByAggregateInput
  }

  export type FeedEventScalarWhereWithAggregatesInput = {
    AND?: FeedEventScalarWhereWithAggregatesInput | FeedEventScalarWhereWithAggregatesInput[]
    OR?: FeedEventScalarWhereWithAggregatesInput[]
    NOT?: FeedEventScalarWhereWithAggregatesInput | FeedEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedEvent"> | string
    userId?: StringWithAggregatesFilter<"FeedEvent"> | string
    eventType?: StringWithAggregatesFilter<"FeedEvent"> | string
    vibeId?: StringNullableWithAggregatesFilter<"FeedEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeedEvent"> | Date | string
  }

  export type SuggestedUserWhereInput = {
    AND?: SuggestedUserWhereInput | SuggestedUserWhereInput[]
    OR?: SuggestedUserWhereInput[]
    NOT?: SuggestedUserWhereInput | SuggestedUserWhereInput[]
    id?: StringFilter<"SuggestedUser"> | string
    userId?: StringFilter<"SuggestedUser"> | string
    suggestedUserId?: StringFilter<"SuggestedUser"> | string
    reason?: StringNullableFilter<"SuggestedUser"> | string | null
    createdAt?: DateTimeFilter<"SuggestedUser"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SuggestedUser"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    suggestedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SuggestedUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    suggestedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    suggestedUser?: UserOrderByWithRelationInput
  }

  export type SuggestedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuggestedUserWhereInput | SuggestedUserWhereInput[]
    OR?: SuggestedUserWhereInput[]
    NOT?: SuggestedUserWhereInput | SuggestedUserWhereInput[]
    userId?: StringFilter<"SuggestedUser"> | string
    suggestedUserId?: StringFilter<"SuggestedUser"> | string
    reason?: StringNullableFilter<"SuggestedUser"> | string | null
    createdAt?: DateTimeFilter<"SuggestedUser"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SuggestedUser"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    suggestedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SuggestedUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    suggestedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: SuggestedUserCountOrderByAggregateInput
    _max?: SuggestedUserMaxOrderByAggregateInput
    _min?: SuggestedUserMinOrderByAggregateInput
  }

  export type SuggestedUserScalarWhereWithAggregatesInput = {
    AND?: SuggestedUserScalarWhereWithAggregatesInput | SuggestedUserScalarWhereWithAggregatesInput[]
    OR?: SuggestedUserScalarWhereWithAggregatesInput[]
    NOT?: SuggestedUserScalarWhereWithAggregatesInput | SuggestedUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuggestedUser"> | string
    userId?: StringWithAggregatesFilter<"SuggestedUser"> | string
    suggestedUserId?: StringWithAggregatesFilter<"SuggestedUser"> | string
    reason?: StringNullableWithAggregatesFilter<"SuggestedUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SuggestedUser"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SuggestedUser"> | Date | string | null
  }

  export type CityFeedCacheWhereInput = {
    AND?: CityFeedCacheWhereInput | CityFeedCacheWhereInput[]
    OR?: CityFeedCacheWhereInput[]
    NOT?: CityFeedCacheWhereInput | CityFeedCacheWhereInput[]
    id?: StringFilter<"CityFeedCache"> | string
    city?: StringFilter<"CityFeedCache"> | string
    vibeId?: StringFilter<"CityFeedCache"> | string
    cachedAt?: DateTimeFilter<"CityFeedCache"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }

  export type CityFeedCacheOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrder
    vibeId?: SortOrder
    cachedAt?: SortOrder
    vibe?: VibeOrderByWithRelationInput
  }

  export type CityFeedCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityFeedCacheWhereInput | CityFeedCacheWhereInput[]
    OR?: CityFeedCacheWhereInput[]
    NOT?: CityFeedCacheWhereInput | CityFeedCacheWhereInput[]
    city?: StringFilter<"CityFeedCache"> | string
    vibeId?: StringFilter<"CityFeedCache"> | string
    cachedAt?: DateTimeFilter<"CityFeedCache"> | Date | string
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }, "id">

  export type CityFeedCacheOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrder
    vibeId?: SortOrder
    cachedAt?: SortOrder
    _count?: CityFeedCacheCountOrderByAggregateInput
    _max?: CityFeedCacheMaxOrderByAggregateInput
    _min?: CityFeedCacheMinOrderByAggregateInput
  }

  export type CityFeedCacheScalarWhereWithAggregatesInput = {
    AND?: CityFeedCacheScalarWhereWithAggregatesInput | CityFeedCacheScalarWhereWithAggregatesInput[]
    OR?: CityFeedCacheScalarWhereWithAggregatesInput[]
    NOT?: CityFeedCacheScalarWhereWithAggregatesInput | CityFeedCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CityFeedCache"> | string
    city?: StringWithAggregatesFilter<"CityFeedCache"> | string
    vibeId?: StringWithAggregatesFilter<"CityFeedCache"> | string
    cachedAt?: DateTimeWithAggregatesFilter<"CityFeedCache"> | Date | string
  }

  export type InviteQueueWhereInput = {
    AND?: InviteQueueWhereInput | InviteQueueWhereInput[]
    OR?: InviteQueueWhereInput[]
    NOT?: InviteQueueWhereInput | InviteQueueWhereInput[]
    id?: StringFilter<"InviteQueue"> | string
    userId?: StringFilter<"InviteQueue"> | string
    vibeId?: StringFilter<"InviteQueue"> | string
    invitedAt?: DateTimeFilter<"InviteQueue"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }

  export type InviteQueueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    invitedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vibe?: VibeOrderByWithRelationInput
  }

  export type InviteQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InviteQueueWhereInput | InviteQueueWhereInput[]
    OR?: InviteQueueWhereInput[]
    NOT?: InviteQueueWhereInput | InviteQueueWhereInput[]
    userId?: StringFilter<"InviteQueue"> | string
    vibeId?: StringFilter<"InviteQueue"> | string
    invitedAt?: DateTimeFilter<"InviteQueue"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vibe?: XOR<VibeRelationFilter, VibeWhereInput>
  }, "id">

  export type InviteQueueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    invitedAt?: SortOrder
    _count?: InviteQueueCountOrderByAggregateInput
    _max?: InviteQueueMaxOrderByAggregateInput
    _min?: InviteQueueMinOrderByAggregateInput
  }

  export type InviteQueueScalarWhereWithAggregatesInput = {
    AND?: InviteQueueScalarWhereWithAggregatesInput | InviteQueueScalarWhereWithAggregatesInput[]
    OR?: InviteQueueScalarWhereWithAggregatesInput[]
    NOT?: InviteQueueScalarWhereWithAggregatesInput | InviteQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InviteQueue"> | string
    userId?: StringWithAggregatesFilter<"InviteQueue"> | string
    vibeId?: StringWithAggregatesFilter<"InviteQueue"> | string
    invitedAt?: DateTimeWithAggregatesFilter<"InviteQueue"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    model?: StringFilter<"AuditLog"> | string
    modelId?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    model?: SortOrder
    modelId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    model?: StringFilter<"AuditLog"> | string
    modelId?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    model?: SortOrder
    modelId?: SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    model?: StringWithAggregatesFilter<"AuditLog"> | string
    modelId?: StringWithAggregatesFilter<"AuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VibeCreateInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type VibeCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VibeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeContributorCreateInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutContributorsInput
    user: UserCreateNestedOneWithoutContributedVibesInput
  }

  export type VibeContributorUncheckedCreateInput = {
    id?: string
    vibeId: string
    userId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type VibeContributorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutContributorsNestedInput
    user?: UserUpdateOneRequiredWithoutContributedVibesNestedInput
  }

  export type VibeContributorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeContributorCreateManyInput = {
    id?: string
    vibeId: string
    userId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type VibeContributorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeContributorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaCreateInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerCreateInput = {
    id?: string
    viewedAt?: Date | string
    vibe: VibeCreateNestedOneWithoutViewersInput
    viewer: UserCreateNestedOneWithoutVibeViewsInput
  }

  export type VibeViewerUncheckedCreateInput = {
    id?: string
    vibeId: string
    viewerId: string
    viewedAt?: Date | string
  }

  export type VibeViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutViewersNestedInput
    viewer?: UserUpdateOneRequiredWithoutVibeViewsNestedInput
  }

  export type VibeViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerCreateManyInput = {
    id?: string
    vibeId: string
    viewerId: string
    viewedAt?: Date | string
  }

  export type VibeViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    id?: string
    favoritedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    media: MediaCreateNestedOneWithoutFavoritedByInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    mediaId: string
    favoritedAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    media?: MediaUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    mediaId: string
    favoritedAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender: UserCreateNestedOneWithoutSentNotificationsInput
    vibe?: VibeCreateNestedOneWithoutNotificationsInput
    media?: MediaCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
    vibe?: VibeUpdateOneWithoutNotificationsNestedInput
    media?: MediaUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftCreateInput = {
    id?: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutDraftsInput
    vibe: VibeCreateNestedOneWithoutDraftsInput
  }

  export type DraftUncheckedCreateInput = {
    id?: string
    userId: string
    vibeId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type DraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDraftsNestedInput
    vibe?: VibeUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type DraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DraftCreateManyInput = {
    id?: string
    userId: string
    vibeId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type DraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteCreateInput = {
    id?: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutInvitesInput
    invitedUser: UserCreateNestedOneWithoutInvitesInput
    invitedBy: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type VibeInviteUncheckedCreateInput = {
    id?: string
    vibeId: string
    invitedUserId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutInvitesNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutInvitesNestedInput
    invitedBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
  }

  export type VibeInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteCreateManyInput = {
    id?: string
    vibeId: string
    invitedUserId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaFlagCreateInput = {
    id?: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
    media: MediaCreateNestedOneWithoutFlagsInput
    flaggedBy: UserCreateNestedOneWithoutFlaggedMediaInput
  }

  export type MediaFlagUncheckedCreateInput = {
    id?: string
    mediaId: string
    flaggedById: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type MediaFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutFlagsNestedInput
    flaggedBy?: UserUpdateOneRequiredWithoutFlaggedMediaNestedInput
  }

  export type MediaFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    flaggedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagCreateManyInput = {
    id?: string
    mediaId: string
    flaggedById: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type MediaFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    flaggedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventCreateInput = {
    id?: string
    eventType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedEventsInput
    vibe?: VibeCreateNestedOneWithoutFeedEventsInput
  }

  export type FeedEventUncheckedCreateInput = {
    id?: string
    userId: string
    eventType: string
    vibeId?: string | null
    createdAt?: Date | string
  }

  export type FeedEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedEventsNestedInput
    vibe?: VibeUpdateOneWithoutFeedEventsNestedInput
  }

  export type FeedEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventCreateManyInput = {
    id?: string
    userId: string
    eventType: string
    vibeId?: string | null
    createdAt?: Date | string
  }

  export type FeedEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestedUserCreateInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutSuggestedToInput
    suggestedUser: UserCreateNestedOneWithoutSuggestedFromInput
  }

  export type SuggestedUserUncheckedCreateInput = {
    id?: string
    userId: string
    suggestedUserId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SuggestedUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSuggestedToNestedInput
    suggestedUser?: UserUpdateOneRequiredWithoutSuggestedFromNestedInput
  }

  export type SuggestedUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserCreateManyInput = {
    id?: string
    userId: string
    suggestedUserId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SuggestedUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CityFeedCacheCreateInput = {
    id?: string
    city: string
    cachedAt?: Date | string
    vibe: VibeCreateNestedOneWithoutCityFeedCacheInput
  }

  export type CityFeedCacheUncheckedCreateInput = {
    id?: string
    city: string
    vibeId: string
    cachedAt?: Date | string
  }

  export type CityFeedCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutCityFeedCacheNestedInput
  }

  export type CityFeedCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityFeedCacheCreateManyInput = {
    id?: string
    city: string
    vibeId: string
    cachedAt?: Date | string
  }

  export type CityFeedCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityFeedCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueCreateInput = {
    id?: string
    invitedAt?: Date | string
    user: UserCreateNestedOneWithoutInviteQueueInput
    vibe: VibeCreateNestedOneWithoutInviteQueueInput
  }

  export type InviteQueueUncheckedCreateInput = {
    id?: string
    userId: string
    vibeId: string
    invitedAt?: Date | string
  }

  export type InviteQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInviteQueueNestedInput
    vibe?: VibeUpdateOneRequiredWithoutInviteQueueNestedInput
  }

  export type InviteQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueCreateManyInput = {
    id?: string
    userId: string
    vibeId: string
    invitedAt?: Date | string
  }

  export type InviteQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId: string
    action: string
    model: string
    modelId: string
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    model: string
    modelId: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    model: string
    modelId: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type VibeListRelationFilter = {
    every?: VibeWhereInput
    some?: VibeWhereInput
    none?: VibeWhereInput
  }

  export type VibeContributorListRelationFilter = {
    every?: VibeContributorWhereInput
    some?: VibeContributorWhereInput
    none?: VibeContributorWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type VibeViewerListRelationFilter = {
    every?: VibeViewerWhereInput
    some?: VibeViewerWhereInput
    none?: VibeViewerWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DraftListRelationFilter = {
    every?: DraftWhereInput
    some?: DraftWhereInput
    none?: DraftWhereInput
  }

  export type VibeInviteListRelationFilter = {
    every?: VibeInviteWhereInput
    some?: VibeInviteWhereInput
    none?: VibeInviteWhereInput
  }

  export type SuggestedUserListRelationFilter = {
    every?: SuggestedUserWhereInput
    some?: SuggestedUserWhereInput
    none?: SuggestedUserWhereInput
  }

  export type FeedEventListRelationFilter = {
    every?: FeedEventWhereInput
    some?: FeedEventWhereInput
    none?: FeedEventWhereInput
  }

  export type InviteQueueListRelationFilter = {
    every?: InviteQueueWhereInput
    some?: InviteQueueWhereInput
    none?: InviteQueueWhereInput
  }

  export type MediaFlagListRelationFilter = {
    every?: MediaFlagWhereInput
    some?: MediaFlagWhereInput
    none?: MediaFlagWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VibeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VibeContributorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VibeViewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VibeInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuggestedUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaFlagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    profilePicture?: SortOrder
    timeZone?: SortOrder
    joinedAt?: SortOrder
    inviteCode?: SortOrder
    invitedById?: SortOrder
    isDeleted?: SortOrder
    firebaseUid?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    profilePicture?: SortOrder
    timeZone?: SortOrder
    joinedAt?: SortOrder
    inviteCode?: SortOrder
    invitedById?: SortOrder
    isDeleted?: SortOrder
    firebaseUid?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    profilePicture?: SortOrder
    timeZone?: SortOrder
    joinedAt?: SortOrder
    inviteCode?: SortOrder
    invitedById?: SortOrder
    isDeleted?: SortOrder
    firebaseUid?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MediaNullableRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CityFeedCacheListRelationFilter = {
    every?: CityFeedCacheWhereInput
    some?: CityFeedCacheWhereInput
    none?: CityFeedCacheWhereInput
  }

  export type CityFeedCacheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VibeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverMediaId?: SortOrder
    createdById?: SortOrder
    isShared?: SortOrder
    status?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VibeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverMediaId?: SortOrder
    createdById?: SortOrder
    isShared?: SortOrder
    status?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VibeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverMediaId?: SortOrder
    createdById?: SortOrder
    isShared?: SortOrder
    status?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VibeRelationFilter = {
    is?: VibeWhereInput
    isNot?: VibeWhereInput
  }

  export type VibeContributorCountOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    hasUploaded?: SortOrder
    leftAt?: SortOrder
  }

  export type VibeContributorMaxOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    hasUploaded?: SortOrder
    leftAt?: SortOrder
  }

  export type VibeContributorMinOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    hasUploaded?: SortOrder
    leftAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VibeNullableRelationFilter = {
    is?: VibeWhereInput | null
    isNot?: VibeWhereInput | null
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    uploadedById?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    exifData?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    uploadedById?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    uploadedById?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type VibeViewerCountOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    viewerId?: SortOrder
    viewedAt?: SortOrder
  }

  export type VibeViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    viewerId?: SortOrder
    viewedAt?: SortOrder
  }

  export type VibeViewerMinOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    viewerId?: SortOrder
    viewedAt?: SortOrder
  }

  export type MediaRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaId?: SortOrder
    favoritedAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaId?: SortOrder
    favoritedAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaId?: SortOrder
    favoritedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    vibeId?: SortOrder
    mediaId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    vibeId?: SortOrder
    mediaId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    vibeId?: SortOrder
    mediaId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type DraftCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    lastEditedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DraftMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    lastEditedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DraftMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    lastEditedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VibeInviteCountOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    invitedUserId?: SortOrder
    invitedById?: SortOrder
    status?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type VibeInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    invitedUserId?: SortOrder
    invitedById?: SortOrder
    status?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type VibeInviteMinOrderByAggregateInput = {
    id?: SortOrder
    vibeId?: SortOrder
    invitedUserId?: SortOrder
    invitedById?: SortOrder
    status?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type MediaFlagCountOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    flaggedById?: SortOrder
    reason?: SortOrder
    additionalInfo?: SortOrder
    flaggedAt?: SortOrder
  }

  export type MediaFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    flaggedById?: SortOrder
    reason?: SortOrder
    additionalInfo?: SortOrder
    flaggedAt?: SortOrder
  }

  export type MediaFlagMinOrderByAggregateInput = {
    id?: SortOrder
    mediaId?: SortOrder
    flaggedById?: SortOrder
    reason?: SortOrder
    additionalInfo?: SortOrder
    flaggedAt?: SortOrder
  }

  export type FeedEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    vibeId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    vibeId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    vibeId?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestedUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    suggestedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SuggestedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    suggestedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SuggestedUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    suggestedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CityFeedCacheCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    vibeId?: SortOrder
    cachedAt?: SortOrder
  }

  export type CityFeedCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    vibeId?: SortOrder
    cachedAt?: SortOrder
  }

  export type CityFeedCacheMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    vibeId?: SortOrder
    cachedAt?: SortOrder
  }

  export type InviteQueueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    invitedAt?: SortOrder
  }

  export type InviteQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    invitedAt?: SortOrder
  }

  export type InviteQueueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vibeId?: SortOrder
    invitedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    model?: SortOrder
    modelId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    model?: SortOrder
    modelId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    model?: SortOrder
    modelId?: SortOrder
    timestamp?: SortOrder
  }

  export type UserCreateNestedOneWithoutInvitedUsersInput = {
    create?: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VibeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput> | VibeCreateWithoutCreatedByInput[] | VibeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VibeCreateOrConnectWithoutCreatedByInput | VibeCreateOrConnectWithoutCreatedByInput[]
    createMany?: VibeCreateManyCreatedByInputEnvelope
    connect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
  }

  export type VibeContributorCreateNestedManyWithoutUserInput = {
    create?: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput> | VibeContributorCreateWithoutUserInput[] | VibeContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutUserInput | VibeContributorCreateOrConnectWithoutUserInput[]
    createMany?: VibeContributorCreateManyUserInputEnvelope
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type VibeViewerCreateNestedManyWithoutViewerInput = {
    create?: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput> | VibeViewerCreateWithoutViewerInput[] | VibeViewerUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutViewerInput | VibeViewerCreateOrConnectWithoutViewerInput[]
    createMany?: VibeViewerCreateManyViewerInputEnvelope
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DraftCreateNestedManyWithoutUserInput = {
    create?: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput> | DraftCreateWithoutUserInput[] | DraftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutUserInput | DraftCreateOrConnectWithoutUserInput[]
    createMany?: DraftCreateManyUserInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type VibeInviteCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput> | VibeInviteCreateWithoutInvitedUserInput[] | VibeInviteUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedUserInput | VibeInviteCreateOrConnectWithoutInvitedUserInput[]
    createMany?: VibeInviteCreateManyInvitedUserInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type VibeInviteCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput> | VibeInviteCreateWithoutInvitedByInput[] | VibeInviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedByInput | VibeInviteCreateOrConnectWithoutInvitedByInput[]
    createMany?: VibeInviteCreateManyInvitedByInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type SuggestedUserCreateNestedManyWithoutUserInput = {
    create?: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput> | SuggestedUserCreateWithoutUserInput[] | SuggestedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutUserInput | SuggestedUserCreateOrConnectWithoutUserInput[]
    createMany?: SuggestedUserCreateManyUserInputEnvelope
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
  }

  export type SuggestedUserCreateNestedManyWithoutSuggestedUserInput = {
    create?: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput> | SuggestedUserCreateWithoutSuggestedUserInput[] | SuggestedUserUncheckedCreateWithoutSuggestedUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutSuggestedUserInput | SuggestedUserCreateOrConnectWithoutSuggestedUserInput[]
    createMany?: SuggestedUserCreateManySuggestedUserInputEnvelope
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
  }

  export type FeedEventCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput> | FeedEventCreateWithoutUserInput[] | FeedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutUserInput | FeedEventCreateOrConnectWithoutUserInput[]
    createMany?: FeedEventCreateManyUserInputEnvelope
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
  }

  export type InviteQueueCreateNestedManyWithoutUserInput = {
    create?: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput> | InviteQueueCreateWithoutUserInput[] | InviteQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutUserInput | InviteQueueCreateOrConnectWithoutUserInput[]
    createMany?: InviteQueueCreateManyUserInputEnvelope
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
  }

  export type MediaFlagCreateNestedManyWithoutFlaggedByInput = {
    create?: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput> | MediaFlagCreateWithoutFlaggedByInput[] | MediaFlagUncheckedCreateWithoutFlaggedByInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutFlaggedByInput | MediaFlagCreateOrConnectWithoutFlaggedByInput[]
    createMany?: MediaFlagCreateManyFlaggedByInputEnvelope
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VibeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput> | VibeCreateWithoutCreatedByInput[] | VibeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VibeCreateOrConnectWithoutCreatedByInput | VibeCreateOrConnectWithoutCreatedByInput[]
    createMany?: VibeCreateManyCreatedByInputEnvelope
    connect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
  }

  export type VibeContributorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput> | VibeContributorCreateWithoutUserInput[] | VibeContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutUserInput | VibeContributorCreateOrConnectWithoutUserInput[]
    createMany?: VibeContributorCreateManyUserInputEnvelope
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type VibeViewerUncheckedCreateNestedManyWithoutViewerInput = {
    create?: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput> | VibeViewerCreateWithoutViewerInput[] | VibeViewerUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutViewerInput | VibeViewerCreateOrConnectWithoutViewerInput[]
    createMany?: VibeViewerCreateManyViewerInputEnvelope
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DraftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput> | DraftCreateWithoutUserInput[] | DraftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutUserInput | DraftCreateOrConnectWithoutUserInput[]
    createMany?: DraftCreateManyUserInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput> | VibeInviteCreateWithoutInvitedUserInput[] | VibeInviteUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedUserInput | VibeInviteCreateOrConnectWithoutInvitedUserInput[]
    createMany?: VibeInviteCreateManyInvitedUserInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput> | VibeInviteCreateWithoutInvitedByInput[] | VibeInviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedByInput | VibeInviteCreateOrConnectWithoutInvitedByInput[]
    createMany?: VibeInviteCreateManyInvitedByInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type SuggestedUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput> | SuggestedUserCreateWithoutUserInput[] | SuggestedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutUserInput | SuggestedUserCreateOrConnectWithoutUserInput[]
    createMany?: SuggestedUserCreateManyUserInputEnvelope
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
  }

  export type SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput = {
    create?: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput> | SuggestedUserCreateWithoutSuggestedUserInput[] | SuggestedUserUncheckedCreateWithoutSuggestedUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutSuggestedUserInput | SuggestedUserCreateOrConnectWithoutSuggestedUserInput[]
    createMany?: SuggestedUserCreateManySuggestedUserInputEnvelope
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
  }

  export type FeedEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput> | FeedEventCreateWithoutUserInput[] | FeedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutUserInput | FeedEventCreateOrConnectWithoutUserInput[]
    createMany?: FeedEventCreateManyUserInputEnvelope
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
  }

  export type InviteQueueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput> | InviteQueueCreateWithoutUserInput[] | InviteQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutUserInput | InviteQueueCreateOrConnectWithoutUserInput[]
    createMany?: InviteQueueCreateManyUserInputEnvelope
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
  }

  export type MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput = {
    create?: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput> | MediaFlagCreateWithoutFlaggedByInput[] | MediaFlagUncheckedCreateWithoutFlaggedByInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutFlaggedByInput | MediaFlagCreateOrConnectWithoutFlaggedByInput[]
    createMany?: MediaFlagCreateManyFlaggedByInputEnvelope
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutInvitedUsersNestedInput = {
    create?: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedUsersInput
    upsert?: UserUpsertWithoutInvitedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitedUsersInput, UserUpdateWithoutInvitedUsersInput>, UserUncheckedUpdateWithoutInvitedUsersInput>
  }

  export type UserUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInvitedByInput | UserUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInvitedByInput | UserUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInvitedByInput | UserUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VibeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput> | VibeCreateWithoutCreatedByInput[] | VibeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VibeCreateOrConnectWithoutCreatedByInput | VibeCreateOrConnectWithoutCreatedByInput[]
    upsert?: VibeUpsertWithWhereUniqueWithoutCreatedByInput | VibeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VibeCreateManyCreatedByInputEnvelope
    set?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    disconnect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    delete?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    connect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    update?: VibeUpdateWithWhereUniqueWithoutCreatedByInput | VibeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VibeUpdateManyWithWhereWithoutCreatedByInput | VibeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VibeScalarWhereInput | VibeScalarWhereInput[]
  }

  export type VibeContributorUpdateManyWithoutUserNestedInput = {
    create?: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput> | VibeContributorCreateWithoutUserInput[] | VibeContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutUserInput | VibeContributorCreateOrConnectWithoutUserInput[]
    upsert?: VibeContributorUpsertWithWhereUniqueWithoutUserInput | VibeContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VibeContributorCreateManyUserInputEnvelope
    set?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    disconnect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    delete?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    update?: VibeContributorUpdateWithWhereUniqueWithoutUserInput | VibeContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VibeContributorUpdateManyWithWhereWithoutUserInput | VibeContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploadedByInput | MediaUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploadedByInput | MediaUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploadedByInput | MediaUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type VibeViewerUpdateManyWithoutViewerNestedInput = {
    create?: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput> | VibeViewerCreateWithoutViewerInput[] | VibeViewerUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutViewerInput | VibeViewerCreateOrConnectWithoutViewerInput[]
    upsert?: VibeViewerUpsertWithWhereUniqueWithoutViewerInput | VibeViewerUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: VibeViewerCreateManyViewerInputEnvelope
    set?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    disconnect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    delete?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    update?: VibeViewerUpdateWithWhereUniqueWithoutViewerInput | VibeViewerUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: VibeViewerUpdateManyWithWhereWithoutViewerInput | VibeViewerUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DraftUpdateManyWithoutUserNestedInput = {
    create?: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput> | DraftCreateWithoutUserInput[] | DraftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutUserInput | DraftCreateOrConnectWithoutUserInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutUserInput | DraftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DraftCreateManyUserInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutUserInput | DraftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutUserInput | DraftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type VibeInviteUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput> | VibeInviteCreateWithoutInvitedUserInput[] | VibeInviteUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedUserInput | VibeInviteCreateOrConnectWithoutInvitedUserInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutInvitedUserInput | VibeInviteUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: VibeInviteCreateManyInvitedUserInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutInvitedUserInput | VibeInviteUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutInvitedUserInput | VibeInviteUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type VibeInviteUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput> | VibeInviteCreateWithoutInvitedByInput[] | VibeInviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedByInput | VibeInviteCreateOrConnectWithoutInvitedByInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutInvitedByInput | VibeInviteUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: VibeInviteCreateManyInvitedByInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutInvitedByInput | VibeInviteUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutInvitedByInput | VibeInviteUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type SuggestedUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput> | SuggestedUserCreateWithoutUserInput[] | SuggestedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutUserInput | SuggestedUserCreateOrConnectWithoutUserInput[]
    upsert?: SuggestedUserUpsertWithWhereUniqueWithoutUserInput | SuggestedUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuggestedUserCreateManyUserInputEnvelope
    set?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    disconnect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    delete?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    update?: SuggestedUserUpdateWithWhereUniqueWithoutUserInput | SuggestedUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuggestedUserUpdateManyWithWhereWithoutUserInput | SuggestedUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
  }

  export type SuggestedUserUpdateManyWithoutSuggestedUserNestedInput = {
    create?: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput> | SuggestedUserCreateWithoutSuggestedUserInput[] | SuggestedUserUncheckedCreateWithoutSuggestedUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutSuggestedUserInput | SuggestedUserCreateOrConnectWithoutSuggestedUserInput[]
    upsert?: SuggestedUserUpsertWithWhereUniqueWithoutSuggestedUserInput | SuggestedUserUpsertWithWhereUniqueWithoutSuggestedUserInput[]
    createMany?: SuggestedUserCreateManySuggestedUserInputEnvelope
    set?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    disconnect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    delete?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    update?: SuggestedUserUpdateWithWhereUniqueWithoutSuggestedUserInput | SuggestedUserUpdateWithWhereUniqueWithoutSuggestedUserInput[]
    updateMany?: SuggestedUserUpdateManyWithWhereWithoutSuggestedUserInput | SuggestedUserUpdateManyWithWhereWithoutSuggestedUserInput[]
    deleteMany?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
  }

  export type FeedEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput> | FeedEventCreateWithoutUserInput[] | FeedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutUserInput | FeedEventCreateOrConnectWithoutUserInput[]
    upsert?: FeedEventUpsertWithWhereUniqueWithoutUserInput | FeedEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedEventCreateManyUserInputEnvelope
    set?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    disconnect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    delete?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    update?: FeedEventUpdateWithWhereUniqueWithoutUserInput | FeedEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedEventUpdateManyWithWhereWithoutUserInput | FeedEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
  }

  export type InviteQueueUpdateManyWithoutUserNestedInput = {
    create?: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput> | InviteQueueCreateWithoutUserInput[] | InviteQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutUserInput | InviteQueueCreateOrConnectWithoutUserInput[]
    upsert?: InviteQueueUpsertWithWhereUniqueWithoutUserInput | InviteQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InviteQueueCreateManyUserInputEnvelope
    set?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    disconnect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    delete?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    update?: InviteQueueUpdateWithWhereUniqueWithoutUserInput | InviteQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InviteQueueUpdateManyWithWhereWithoutUserInput | InviteQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
  }

  export type MediaFlagUpdateManyWithoutFlaggedByNestedInput = {
    create?: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput> | MediaFlagCreateWithoutFlaggedByInput[] | MediaFlagUncheckedCreateWithoutFlaggedByInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutFlaggedByInput | MediaFlagCreateOrConnectWithoutFlaggedByInput[]
    upsert?: MediaFlagUpsertWithWhereUniqueWithoutFlaggedByInput | MediaFlagUpsertWithWhereUniqueWithoutFlaggedByInput[]
    createMany?: MediaFlagCreateManyFlaggedByInputEnvelope
    set?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    disconnect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    delete?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    update?: MediaFlagUpdateWithWhereUniqueWithoutFlaggedByInput | MediaFlagUpdateWithWhereUniqueWithoutFlaggedByInput[]
    updateMany?: MediaFlagUpdateManyWithWhereWithoutFlaggedByInput | MediaFlagUpdateManyWithWhereWithoutFlaggedByInput[]
    deleteMany?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput> | UserCreateWithoutInvitedByInput[] | UserUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutInvitedByInput | UserCreateOrConnectWithoutInvitedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutInvitedByInput | UserUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: UserCreateManyInvitedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutInvitedByInput | UserUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutInvitedByInput | UserUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VibeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput> | VibeCreateWithoutCreatedByInput[] | VibeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VibeCreateOrConnectWithoutCreatedByInput | VibeCreateOrConnectWithoutCreatedByInput[]
    upsert?: VibeUpsertWithWhereUniqueWithoutCreatedByInput | VibeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VibeCreateManyCreatedByInputEnvelope
    set?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    disconnect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    delete?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    connect?: VibeWhereUniqueInput | VibeWhereUniqueInput[]
    update?: VibeUpdateWithWhereUniqueWithoutCreatedByInput | VibeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VibeUpdateManyWithWhereWithoutCreatedByInput | VibeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VibeScalarWhereInput | VibeScalarWhereInput[]
  }

  export type VibeContributorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput> | VibeContributorCreateWithoutUserInput[] | VibeContributorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutUserInput | VibeContributorCreateOrConnectWithoutUserInput[]
    upsert?: VibeContributorUpsertWithWhereUniqueWithoutUserInput | VibeContributorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VibeContributorCreateManyUserInputEnvelope
    set?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    disconnect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    delete?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    update?: VibeContributorUpdateWithWhereUniqueWithoutUserInput | VibeContributorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VibeContributorUpdateManyWithWhereWithoutUserInput | VibeContributorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploadedByInput | MediaUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploadedByInput | MediaUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploadedByInput | MediaUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type VibeViewerUncheckedUpdateManyWithoutViewerNestedInput = {
    create?: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput> | VibeViewerCreateWithoutViewerInput[] | VibeViewerUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutViewerInput | VibeViewerCreateOrConnectWithoutViewerInput[]
    upsert?: VibeViewerUpsertWithWhereUniqueWithoutViewerInput | VibeViewerUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: VibeViewerCreateManyViewerInputEnvelope
    set?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    disconnect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    delete?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    update?: VibeViewerUpdateWithWhereUniqueWithoutViewerInput | VibeViewerUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: VibeViewerUpdateManyWithWhereWithoutViewerInput | VibeViewerUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DraftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput> | DraftCreateWithoutUserInput[] | DraftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutUserInput | DraftCreateOrConnectWithoutUserInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutUserInput | DraftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DraftCreateManyUserInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutUserInput | DraftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutUserInput | DraftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput> | VibeInviteCreateWithoutInvitedUserInput[] | VibeInviteUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedUserInput | VibeInviteCreateOrConnectWithoutInvitedUserInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutInvitedUserInput | VibeInviteUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: VibeInviteCreateManyInvitedUserInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutInvitedUserInput | VibeInviteUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutInvitedUserInput | VibeInviteUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput> | VibeInviteCreateWithoutInvitedByInput[] | VibeInviteUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutInvitedByInput | VibeInviteCreateOrConnectWithoutInvitedByInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutInvitedByInput | VibeInviteUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: VibeInviteCreateManyInvitedByInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutInvitedByInput | VibeInviteUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutInvitedByInput | VibeInviteUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type SuggestedUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput> | SuggestedUserCreateWithoutUserInput[] | SuggestedUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutUserInput | SuggestedUserCreateOrConnectWithoutUserInput[]
    upsert?: SuggestedUserUpsertWithWhereUniqueWithoutUserInput | SuggestedUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuggestedUserCreateManyUserInputEnvelope
    set?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    disconnect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    delete?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    update?: SuggestedUserUpdateWithWhereUniqueWithoutUserInput | SuggestedUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuggestedUserUpdateManyWithWhereWithoutUserInput | SuggestedUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
  }

  export type SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput = {
    create?: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput> | SuggestedUserCreateWithoutSuggestedUserInput[] | SuggestedUserUncheckedCreateWithoutSuggestedUserInput[]
    connectOrCreate?: SuggestedUserCreateOrConnectWithoutSuggestedUserInput | SuggestedUserCreateOrConnectWithoutSuggestedUserInput[]
    upsert?: SuggestedUserUpsertWithWhereUniqueWithoutSuggestedUserInput | SuggestedUserUpsertWithWhereUniqueWithoutSuggestedUserInput[]
    createMany?: SuggestedUserCreateManySuggestedUserInputEnvelope
    set?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    disconnect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    delete?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    connect?: SuggestedUserWhereUniqueInput | SuggestedUserWhereUniqueInput[]
    update?: SuggestedUserUpdateWithWhereUniqueWithoutSuggestedUserInput | SuggestedUserUpdateWithWhereUniqueWithoutSuggestedUserInput[]
    updateMany?: SuggestedUserUpdateManyWithWhereWithoutSuggestedUserInput | SuggestedUserUpdateManyWithWhereWithoutSuggestedUserInput[]
    deleteMany?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
  }

  export type FeedEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput> | FeedEventCreateWithoutUserInput[] | FeedEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutUserInput | FeedEventCreateOrConnectWithoutUserInput[]
    upsert?: FeedEventUpsertWithWhereUniqueWithoutUserInput | FeedEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedEventCreateManyUserInputEnvelope
    set?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    disconnect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    delete?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    update?: FeedEventUpdateWithWhereUniqueWithoutUserInput | FeedEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedEventUpdateManyWithWhereWithoutUserInput | FeedEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
  }

  export type InviteQueueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput> | InviteQueueCreateWithoutUserInput[] | InviteQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutUserInput | InviteQueueCreateOrConnectWithoutUserInput[]
    upsert?: InviteQueueUpsertWithWhereUniqueWithoutUserInput | InviteQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InviteQueueCreateManyUserInputEnvelope
    set?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    disconnect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    delete?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    update?: InviteQueueUpdateWithWhereUniqueWithoutUserInput | InviteQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InviteQueueUpdateManyWithWhereWithoutUserInput | InviteQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
  }

  export type MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput = {
    create?: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput> | MediaFlagCreateWithoutFlaggedByInput[] | MediaFlagUncheckedCreateWithoutFlaggedByInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutFlaggedByInput | MediaFlagCreateOrConnectWithoutFlaggedByInput[]
    upsert?: MediaFlagUpsertWithWhereUniqueWithoutFlaggedByInput | MediaFlagUpsertWithWhereUniqueWithoutFlaggedByInput[]
    createMany?: MediaFlagCreateManyFlaggedByInputEnvelope
    set?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    disconnect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    delete?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    update?: MediaFlagUpdateWithWhereUniqueWithoutFlaggedByInput | MediaFlagUpdateWithWhereUniqueWithoutFlaggedByInput[]
    updateMany?: MediaFlagUpdateManyWithWhereWithoutFlaggedByInput | MediaFlagUpdateManyWithWhereWithoutFlaggedByInput[]
    deleteMany?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutCoverOfVibeInput = {
    create?: XOR<MediaCreateWithoutCoverOfVibeInput, MediaUncheckedCreateWithoutCoverOfVibeInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCoverOfVibeInput
    connect?: MediaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedVibesInput = {
    create?: XOR<UserCreateWithoutCreatedVibesInput, UserUncheckedCreateWithoutCreatedVibesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedVibesInput
    connect?: UserWhereUniqueInput
  }

  export type VibeContributorCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput> | VibeContributorCreateWithoutVibeInput[] | VibeContributorUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutVibeInput | VibeContributorCreateOrConnectWithoutVibeInput[]
    createMany?: VibeContributorCreateManyVibeInputEnvelope
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutVibeInput = {
    create?: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput> | MediaCreateWithoutVibeInput[] | MediaUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVibeInput | MediaCreateOrConnectWithoutVibeInput[]
    createMany?: MediaCreateManyVibeInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type VibeViewerCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput> | VibeViewerCreateWithoutVibeInput[] | VibeViewerUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutVibeInput | VibeViewerCreateOrConnectWithoutVibeInput[]
    createMany?: VibeViewerCreateManyVibeInputEnvelope
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
  }

  export type DraftCreateNestedManyWithoutVibeInput = {
    create?: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput> | DraftCreateWithoutVibeInput[] | DraftUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutVibeInput | DraftCreateOrConnectWithoutVibeInput[]
    createMany?: DraftCreateManyVibeInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type VibeInviteCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput> | VibeInviteCreateWithoutVibeInput[] | VibeInviteUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutVibeInput | VibeInviteCreateOrConnectWithoutVibeInput[]
    createMany?: VibeInviteCreateManyVibeInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutVibeInput = {
    create?: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput> | NotificationCreateWithoutVibeInput[] | NotificationUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVibeInput | NotificationCreateOrConnectWithoutVibeInput[]
    createMany?: NotificationCreateManyVibeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FeedEventCreateNestedManyWithoutVibeInput = {
    create?: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput> | FeedEventCreateWithoutVibeInput[] | FeedEventUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutVibeInput | FeedEventCreateOrConnectWithoutVibeInput[]
    createMany?: FeedEventCreateManyVibeInputEnvelope
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
  }

  export type CityFeedCacheCreateNestedManyWithoutVibeInput = {
    create?: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput> | CityFeedCacheCreateWithoutVibeInput[] | CityFeedCacheUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: CityFeedCacheCreateOrConnectWithoutVibeInput | CityFeedCacheCreateOrConnectWithoutVibeInput[]
    createMany?: CityFeedCacheCreateManyVibeInputEnvelope
    connect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
  }

  export type InviteQueueCreateNestedManyWithoutVibeInput = {
    create?: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput> | InviteQueueCreateWithoutVibeInput[] | InviteQueueUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutVibeInput | InviteQueueCreateOrConnectWithoutVibeInput[]
    createMany?: InviteQueueCreateManyVibeInputEnvelope
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
  }

  export type VibeContributorUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput> | VibeContributorCreateWithoutVibeInput[] | VibeContributorUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutVibeInput | VibeContributorCreateOrConnectWithoutVibeInput[]
    createMany?: VibeContributorCreateManyVibeInputEnvelope
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput> | MediaCreateWithoutVibeInput[] | MediaUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVibeInput | MediaCreateOrConnectWithoutVibeInput[]
    createMany?: MediaCreateManyVibeInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type VibeViewerUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput> | VibeViewerCreateWithoutVibeInput[] | VibeViewerUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutVibeInput | VibeViewerCreateOrConnectWithoutVibeInput[]
    createMany?: VibeViewerCreateManyVibeInputEnvelope
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
  }

  export type DraftUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput> | DraftCreateWithoutVibeInput[] | DraftUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutVibeInput | DraftCreateOrConnectWithoutVibeInput[]
    createMany?: DraftCreateManyVibeInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type VibeInviteUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput> | VibeInviteCreateWithoutVibeInput[] | VibeInviteUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutVibeInput | VibeInviteCreateOrConnectWithoutVibeInput[]
    createMany?: VibeInviteCreateManyVibeInputEnvelope
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput> | NotificationCreateWithoutVibeInput[] | NotificationUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVibeInput | NotificationCreateOrConnectWithoutVibeInput[]
    createMany?: NotificationCreateManyVibeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FeedEventUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput> | FeedEventCreateWithoutVibeInput[] | FeedEventUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutVibeInput | FeedEventCreateOrConnectWithoutVibeInput[]
    createMany?: FeedEventCreateManyVibeInputEnvelope
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
  }

  export type CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput> | CityFeedCacheCreateWithoutVibeInput[] | CityFeedCacheUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: CityFeedCacheCreateOrConnectWithoutVibeInput | CityFeedCacheCreateOrConnectWithoutVibeInput[]
    createMany?: CityFeedCacheCreateManyVibeInputEnvelope
    connect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
  }

  export type InviteQueueUncheckedCreateNestedManyWithoutVibeInput = {
    create?: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput> | InviteQueueCreateWithoutVibeInput[] | InviteQueueUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutVibeInput | InviteQueueCreateOrConnectWithoutVibeInput[]
    createMany?: InviteQueueCreateManyVibeInputEnvelope
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MediaUpdateOneWithoutCoverOfVibeNestedInput = {
    create?: XOR<MediaCreateWithoutCoverOfVibeInput, MediaUncheckedCreateWithoutCoverOfVibeInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCoverOfVibeInput
    upsert?: MediaUpsertWithoutCoverOfVibeInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCoverOfVibeInput, MediaUpdateWithoutCoverOfVibeInput>, MediaUncheckedUpdateWithoutCoverOfVibeInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedVibesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedVibesInput, UserUncheckedCreateWithoutCreatedVibesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedVibesInput
    upsert?: UserUpsertWithoutCreatedVibesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedVibesInput, UserUpdateWithoutCreatedVibesInput>, UserUncheckedUpdateWithoutCreatedVibesInput>
  }

  export type VibeContributorUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput> | VibeContributorCreateWithoutVibeInput[] | VibeContributorUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutVibeInput | VibeContributorCreateOrConnectWithoutVibeInput[]
    upsert?: VibeContributorUpsertWithWhereUniqueWithoutVibeInput | VibeContributorUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeContributorCreateManyVibeInputEnvelope
    set?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    disconnect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    delete?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    update?: VibeContributorUpdateWithWhereUniqueWithoutVibeInput | VibeContributorUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeContributorUpdateManyWithWhereWithoutVibeInput | VibeContributorUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutVibeNestedInput = {
    create?: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput> | MediaCreateWithoutVibeInput[] | MediaUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVibeInput | MediaCreateOrConnectWithoutVibeInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutVibeInput | MediaUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: MediaCreateManyVibeInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutVibeInput | MediaUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutVibeInput | MediaUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type VibeViewerUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput> | VibeViewerCreateWithoutVibeInput[] | VibeViewerUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutVibeInput | VibeViewerCreateOrConnectWithoutVibeInput[]
    upsert?: VibeViewerUpsertWithWhereUniqueWithoutVibeInput | VibeViewerUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeViewerCreateManyVibeInputEnvelope
    set?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    disconnect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    delete?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    update?: VibeViewerUpdateWithWhereUniqueWithoutVibeInput | VibeViewerUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeViewerUpdateManyWithWhereWithoutVibeInput | VibeViewerUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
  }

  export type DraftUpdateManyWithoutVibeNestedInput = {
    create?: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput> | DraftCreateWithoutVibeInput[] | DraftUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutVibeInput | DraftCreateOrConnectWithoutVibeInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutVibeInput | DraftUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: DraftCreateManyVibeInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutVibeInput | DraftUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutVibeInput | DraftUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type VibeInviteUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput> | VibeInviteCreateWithoutVibeInput[] | VibeInviteUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutVibeInput | VibeInviteCreateOrConnectWithoutVibeInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutVibeInput | VibeInviteUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeInviteCreateManyVibeInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutVibeInput | VibeInviteUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutVibeInput | VibeInviteUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutVibeNestedInput = {
    create?: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput> | NotificationCreateWithoutVibeInput[] | NotificationUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVibeInput | NotificationCreateOrConnectWithoutVibeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVibeInput | NotificationUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: NotificationCreateManyVibeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVibeInput | NotificationUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVibeInput | NotificationUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FeedEventUpdateManyWithoutVibeNestedInput = {
    create?: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput> | FeedEventCreateWithoutVibeInput[] | FeedEventUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutVibeInput | FeedEventCreateOrConnectWithoutVibeInput[]
    upsert?: FeedEventUpsertWithWhereUniqueWithoutVibeInput | FeedEventUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: FeedEventCreateManyVibeInputEnvelope
    set?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    disconnect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    delete?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    update?: FeedEventUpdateWithWhereUniqueWithoutVibeInput | FeedEventUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: FeedEventUpdateManyWithWhereWithoutVibeInput | FeedEventUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
  }

  export type CityFeedCacheUpdateManyWithoutVibeNestedInput = {
    create?: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput> | CityFeedCacheCreateWithoutVibeInput[] | CityFeedCacheUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: CityFeedCacheCreateOrConnectWithoutVibeInput | CityFeedCacheCreateOrConnectWithoutVibeInput[]
    upsert?: CityFeedCacheUpsertWithWhereUniqueWithoutVibeInput | CityFeedCacheUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: CityFeedCacheCreateManyVibeInputEnvelope
    set?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    disconnect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    delete?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    connect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    update?: CityFeedCacheUpdateWithWhereUniqueWithoutVibeInput | CityFeedCacheUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: CityFeedCacheUpdateManyWithWhereWithoutVibeInput | CityFeedCacheUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: CityFeedCacheScalarWhereInput | CityFeedCacheScalarWhereInput[]
  }

  export type InviteQueueUpdateManyWithoutVibeNestedInput = {
    create?: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput> | InviteQueueCreateWithoutVibeInput[] | InviteQueueUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutVibeInput | InviteQueueCreateOrConnectWithoutVibeInput[]
    upsert?: InviteQueueUpsertWithWhereUniqueWithoutVibeInput | InviteQueueUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: InviteQueueCreateManyVibeInputEnvelope
    set?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    disconnect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    delete?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    update?: InviteQueueUpdateWithWhereUniqueWithoutVibeInput | InviteQueueUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: InviteQueueUpdateManyWithWhereWithoutVibeInput | InviteQueueUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
  }

  export type VibeContributorUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput> | VibeContributorCreateWithoutVibeInput[] | VibeContributorUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeContributorCreateOrConnectWithoutVibeInput | VibeContributorCreateOrConnectWithoutVibeInput[]
    upsert?: VibeContributorUpsertWithWhereUniqueWithoutVibeInput | VibeContributorUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeContributorCreateManyVibeInputEnvelope
    set?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    disconnect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    delete?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    connect?: VibeContributorWhereUniqueInput | VibeContributorWhereUniqueInput[]
    update?: VibeContributorUpdateWithWhereUniqueWithoutVibeInput | VibeContributorUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeContributorUpdateManyWithWhereWithoutVibeInput | VibeContributorUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput> | MediaCreateWithoutVibeInput[] | MediaUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutVibeInput | MediaCreateOrConnectWithoutVibeInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutVibeInput | MediaUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: MediaCreateManyVibeInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutVibeInput | MediaUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutVibeInput | MediaUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type VibeViewerUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput> | VibeViewerCreateWithoutVibeInput[] | VibeViewerUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeViewerCreateOrConnectWithoutVibeInput | VibeViewerCreateOrConnectWithoutVibeInput[]
    upsert?: VibeViewerUpsertWithWhereUniqueWithoutVibeInput | VibeViewerUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeViewerCreateManyVibeInputEnvelope
    set?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    disconnect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    delete?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    connect?: VibeViewerWhereUniqueInput | VibeViewerWhereUniqueInput[]
    update?: VibeViewerUpdateWithWhereUniqueWithoutVibeInput | VibeViewerUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeViewerUpdateManyWithWhereWithoutVibeInput | VibeViewerUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
  }

  export type DraftUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput> | DraftCreateWithoutVibeInput[] | DraftUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutVibeInput | DraftCreateOrConnectWithoutVibeInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutVibeInput | DraftUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: DraftCreateManyVibeInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutVibeInput | DraftUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutVibeInput | DraftUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type VibeInviteUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput> | VibeInviteCreateWithoutVibeInput[] | VibeInviteUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: VibeInviteCreateOrConnectWithoutVibeInput | VibeInviteCreateOrConnectWithoutVibeInput[]
    upsert?: VibeInviteUpsertWithWhereUniqueWithoutVibeInput | VibeInviteUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: VibeInviteCreateManyVibeInputEnvelope
    set?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    disconnect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    delete?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    connect?: VibeInviteWhereUniqueInput | VibeInviteWhereUniqueInput[]
    update?: VibeInviteUpdateWithWhereUniqueWithoutVibeInput | VibeInviteUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: VibeInviteUpdateManyWithWhereWithoutVibeInput | VibeInviteUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput> | NotificationCreateWithoutVibeInput[] | NotificationUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVibeInput | NotificationCreateOrConnectWithoutVibeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVibeInput | NotificationUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: NotificationCreateManyVibeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVibeInput | NotificationUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVibeInput | NotificationUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FeedEventUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput> | FeedEventCreateWithoutVibeInput[] | FeedEventUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: FeedEventCreateOrConnectWithoutVibeInput | FeedEventCreateOrConnectWithoutVibeInput[]
    upsert?: FeedEventUpsertWithWhereUniqueWithoutVibeInput | FeedEventUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: FeedEventCreateManyVibeInputEnvelope
    set?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    disconnect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    delete?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    connect?: FeedEventWhereUniqueInput | FeedEventWhereUniqueInput[]
    update?: FeedEventUpdateWithWhereUniqueWithoutVibeInput | FeedEventUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: FeedEventUpdateManyWithWhereWithoutVibeInput | FeedEventUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
  }

  export type CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput> | CityFeedCacheCreateWithoutVibeInput[] | CityFeedCacheUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: CityFeedCacheCreateOrConnectWithoutVibeInput | CityFeedCacheCreateOrConnectWithoutVibeInput[]
    upsert?: CityFeedCacheUpsertWithWhereUniqueWithoutVibeInput | CityFeedCacheUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: CityFeedCacheCreateManyVibeInputEnvelope
    set?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    disconnect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    delete?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    connect?: CityFeedCacheWhereUniqueInput | CityFeedCacheWhereUniqueInput[]
    update?: CityFeedCacheUpdateWithWhereUniqueWithoutVibeInput | CityFeedCacheUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: CityFeedCacheUpdateManyWithWhereWithoutVibeInput | CityFeedCacheUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: CityFeedCacheScalarWhereInput | CityFeedCacheScalarWhereInput[]
  }

  export type InviteQueueUncheckedUpdateManyWithoutVibeNestedInput = {
    create?: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput> | InviteQueueCreateWithoutVibeInput[] | InviteQueueUncheckedCreateWithoutVibeInput[]
    connectOrCreate?: InviteQueueCreateOrConnectWithoutVibeInput | InviteQueueCreateOrConnectWithoutVibeInput[]
    upsert?: InviteQueueUpsertWithWhereUniqueWithoutVibeInput | InviteQueueUpsertWithWhereUniqueWithoutVibeInput[]
    createMany?: InviteQueueCreateManyVibeInputEnvelope
    set?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    disconnect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    delete?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    connect?: InviteQueueWhereUniqueInput | InviteQueueWhereUniqueInput[]
    update?: InviteQueueUpdateWithWhereUniqueWithoutVibeInput | InviteQueueUpdateWithWhereUniqueWithoutVibeInput[]
    updateMany?: InviteQueueUpdateManyWithWhereWithoutVibeInput | InviteQueueUpdateManyWithWhereWithoutVibeInput[]
    deleteMany?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
  }

  export type VibeCreateNestedOneWithoutContributorsInput = {
    create?: XOR<VibeCreateWithoutContributorsInput, VibeUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutContributorsInput
    connect?: VibeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContributedVibesInput = {
    create?: XOR<UserCreateWithoutContributedVibesInput, UserUncheckedCreateWithoutContributedVibesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributedVibesInput
    connect?: UserWhereUniqueInput
  }

  export type VibeUpdateOneRequiredWithoutContributorsNestedInput = {
    create?: XOR<VibeCreateWithoutContributorsInput, VibeUncheckedCreateWithoutContributorsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutContributorsInput
    upsert?: VibeUpsertWithoutContributorsInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutContributorsInput, VibeUpdateWithoutContributorsInput>, VibeUncheckedUpdateWithoutContributorsInput>
  }

  export type UserUpdateOneRequiredWithoutContributedVibesNestedInput = {
    create?: XOR<UserCreateWithoutContributedVibesInput, UserUncheckedCreateWithoutContributedVibesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContributedVibesInput
    upsert?: UserUpsertWithoutContributedVibesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContributedVibesInput, UserUpdateWithoutContributedVibesInput>, UserUncheckedUpdateWithoutContributedVibesInput>
  }

  export type VibeCreateNestedOneWithoutMediaInput = {
    create?: XOR<VibeCreateWithoutMediaInput, VibeUncheckedCreateWithoutMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutMediaInput
    connect?: VibeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMediaInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    connect?: UserWhereUniqueInput
  }

  export type FavoriteCreateNestedManyWithoutMediaInput = {
    create?: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput> | FavoriteCreateWithoutMediaInput[] | FavoriteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutMediaInput | FavoriteCreateOrConnectWithoutMediaInput[]
    createMany?: FavoriteCreateManyMediaInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type VibeCreateNestedOneWithoutCoverMediaInput = {
    create?: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCoverMediaInput
    connect?: VibeWhereUniqueInput
  }

  export type MediaFlagCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput> | MediaFlagCreateWithoutMediaInput[] | MediaFlagUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutMediaInput | MediaFlagCreateOrConnectWithoutMediaInput[]
    createMany?: MediaFlagCreateManyMediaInputEnvelope
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutMediaInput = {
    create?: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput> | NotificationCreateWithoutMediaInput[] | NotificationUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMediaInput | NotificationCreateOrConnectWithoutMediaInput[]
    createMany?: NotificationCreateManyMediaInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput> | FavoriteCreateWithoutMediaInput[] | FavoriteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutMediaInput | FavoriteCreateOrConnectWithoutMediaInput[]
    createMany?: FavoriteCreateManyMediaInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type VibeUncheckedCreateNestedOneWithoutCoverMediaInput = {
    create?: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCoverMediaInput
    connect?: VibeWhereUniqueInput
  }

  export type MediaFlagUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput> | MediaFlagCreateWithoutMediaInput[] | MediaFlagUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutMediaInput | MediaFlagCreateOrConnectWithoutMediaInput[]
    createMany?: MediaFlagCreateManyMediaInputEnvelope
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput> | NotificationCreateWithoutMediaInput[] | NotificationUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMediaInput | NotificationCreateOrConnectWithoutMediaInput[]
    createMany?: NotificationCreateManyMediaInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VibeUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<VibeCreateWithoutMediaInput, VibeUncheckedCreateWithoutMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutMediaInput
    upsert?: VibeUpsertWithoutMediaInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutMediaInput, VibeUpdateWithoutMediaInput>, VibeUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    upsert?: UserUpsertWithoutMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaInput, UserUpdateWithoutMediaInput>, UserUncheckedUpdateWithoutMediaInput>
  }

  export type FavoriteUpdateManyWithoutMediaNestedInput = {
    create?: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput> | FavoriteCreateWithoutMediaInput[] | FavoriteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutMediaInput | FavoriteCreateOrConnectWithoutMediaInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutMediaInput | FavoriteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: FavoriteCreateManyMediaInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutMediaInput | FavoriteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutMediaInput | FavoriteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type VibeUpdateOneWithoutCoverMediaNestedInput = {
    create?: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCoverMediaInput
    upsert?: VibeUpsertWithoutCoverMediaInput
    disconnect?: VibeWhereInput | boolean
    delete?: VibeWhereInput | boolean
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutCoverMediaInput, VibeUpdateWithoutCoverMediaInput>, VibeUncheckedUpdateWithoutCoverMediaInput>
  }

  export type MediaFlagUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput> | MediaFlagCreateWithoutMediaInput[] | MediaFlagUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutMediaInput | MediaFlagCreateOrConnectWithoutMediaInput[]
    upsert?: MediaFlagUpsertWithWhereUniqueWithoutMediaInput | MediaFlagUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaFlagCreateManyMediaInputEnvelope
    set?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    disconnect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    delete?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    update?: MediaFlagUpdateWithWhereUniqueWithoutMediaInput | MediaFlagUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaFlagUpdateManyWithWhereWithoutMediaInput | MediaFlagUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput> | NotificationCreateWithoutMediaInput[] | NotificationUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMediaInput | NotificationCreateOrConnectWithoutMediaInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMediaInput | NotificationUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NotificationCreateManyMediaInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMediaInput | NotificationUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMediaInput | NotificationUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput> | FavoriteCreateWithoutMediaInput[] | FavoriteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutMediaInput | FavoriteCreateOrConnectWithoutMediaInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutMediaInput | FavoriteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: FavoriteCreateManyMediaInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutMediaInput | FavoriteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutMediaInput | FavoriteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type VibeUncheckedUpdateOneWithoutCoverMediaNestedInput = {
    create?: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCoverMediaInput
    upsert?: VibeUpsertWithoutCoverMediaInput
    disconnect?: VibeWhereInput | boolean
    delete?: VibeWhereInput | boolean
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutCoverMediaInput, VibeUpdateWithoutCoverMediaInput>, VibeUncheckedUpdateWithoutCoverMediaInput>
  }

  export type MediaFlagUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput> | MediaFlagCreateWithoutMediaInput[] | MediaFlagUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MediaFlagCreateOrConnectWithoutMediaInput | MediaFlagCreateOrConnectWithoutMediaInput[]
    upsert?: MediaFlagUpsertWithWhereUniqueWithoutMediaInput | MediaFlagUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MediaFlagCreateManyMediaInputEnvelope
    set?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    disconnect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    delete?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    connect?: MediaFlagWhereUniqueInput | MediaFlagWhereUniqueInput[]
    update?: MediaFlagUpdateWithWhereUniqueWithoutMediaInput | MediaFlagUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MediaFlagUpdateManyWithWhereWithoutMediaInput | MediaFlagUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput> | NotificationCreateWithoutMediaInput[] | NotificationUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMediaInput | NotificationCreateOrConnectWithoutMediaInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMediaInput | NotificationUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NotificationCreateManyMediaInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMediaInput | NotificationUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMediaInput | NotificationUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VibeCreateNestedOneWithoutViewersInput = {
    create?: XOR<VibeCreateWithoutViewersInput, VibeUncheckedCreateWithoutViewersInput>
    connectOrCreate?: VibeCreateOrConnectWithoutViewersInput
    connect?: VibeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVibeViewsInput = {
    create?: XOR<UserCreateWithoutVibeViewsInput, UserUncheckedCreateWithoutVibeViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVibeViewsInput
    connect?: UserWhereUniqueInput
  }

  export type VibeUpdateOneRequiredWithoutViewersNestedInput = {
    create?: XOR<VibeCreateWithoutViewersInput, VibeUncheckedCreateWithoutViewersInput>
    connectOrCreate?: VibeCreateOrConnectWithoutViewersInput
    upsert?: VibeUpsertWithoutViewersInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutViewersInput, VibeUpdateWithoutViewersInput>, VibeUncheckedUpdateWithoutViewersInput>
  }

  export type UserUpdateOneRequiredWithoutVibeViewsNestedInput = {
    create?: XOR<UserCreateWithoutVibeViewsInput, UserUncheckedCreateWithoutVibeViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVibeViewsInput
    upsert?: UserUpsertWithoutVibeViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVibeViewsInput, UserUpdateWithoutVibeViewsInput>, UserUncheckedUpdateWithoutVibeViewsInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutFavoritedByInput = {
    create?: XOR<MediaCreateWithoutFavoritedByInput, MediaUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: MediaCreateOrConnectWithoutFavoritedByInput
    connect?: MediaWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type MediaUpdateOneRequiredWithoutFavoritedByNestedInput = {
    create?: XOR<MediaCreateWithoutFavoritedByInput, MediaUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: MediaCreateOrConnectWithoutFavoritedByInput
    upsert?: MediaUpsertWithoutFavoritedByInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutFavoritedByInput, MediaUpdateWithoutFavoritedByInput>, MediaUncheckedUpdateWithoutFavoritedByInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type VibeCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<VibeCreateWithoutNotificationsInput, VibeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutNotificationsInput
    connect?: VibeWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<MediaCreateWithoutNotificationsInput, MediaUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNotificationsInput
    connect?: MediaWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type VibeUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<VibeCreateWithoutNotificationsInput, VibeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutNotificationsInput
    upsert?: VibeUpsertWithoutNotificationsInput
    disconnect?: VibeWhereInput | boolean
    delete?: VibeWhereInput | boolean
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutNotificationsInput, VibeUpdateWithoutNotificationsInput>, VibeUncheckedUpdateWithoutNotificationsInput>
  }

  export type MediaUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<MediaCreateWithoutNotificationsInput, MediaUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNotificationsInput
    upsert?: MediaUpsertWithoutNotificationsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutNotificationsInput, MediaUpdateWithoutNotificationsInput>, MediaUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutDraftsInput = {
    create?: XOR<UserCreateWithoutDraftsInput, UserUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDraftsInput
    connect?: UserWhereUniqueInput
  }

  export type VibeCreateNestedOneWithoutDraftsInput = {
    create?: XOR<VibeCreateWithoutDraftsInput, VibeUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutDraftsInput
    connect?: VibeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<UserCreateWithoutDraftsInput, UserUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDraftsInput
    upsert?: UserUpsertWithoutDraftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDraftsInput, UserUpdateWithoutDraftsInput>, UserUncheckedUpdateWithoutDraftsInput>
  }

  export type VibeUpdateOneRequiredWithoutDraftsNestedInput = {
    create?: XOR<VibeCreateWithoutDraftsInput, VibeUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutDraftsInput
    upsert?: VibeUpsertWithoutDraftsInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutDraftsInput, VibeUpdateWithoutDraftsInput>, VibeUncheckedUpdateWithoutDraftsInput>
  }

  export type VibeCreateNestedOneWithoutInvitesInput = {
    create?: XOR<VibeCreateWithoutInvitesInput, VibeUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: VibeCreateOrConnectWithoutInvitesInput
    connect?: VibeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitesInput = {
    create?: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitesInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type VibeUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<VibeCreateWithoutInvitesInput, VibeUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: VibeCreateOrConnectWithoutInvitesInput
    upsert?: VibeUpsertWithoutInvitesInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutInvitesInput, VibeUpdateWithoutInvitesInput>, VibeUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesInput
    upsert?: UserUpsertWithoutInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitesInput, UserUpdateWithoutInvitesInput>, UserUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutSentInvitesNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitesInput
    upsert?: UserUpsertWithoutSentInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitesInput, UserUpdateWithoutSentInvitesInput>, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type MediaCreateNestedOneWithoutFlagsInput = {
    create?: XOR<MediaCreateWithoutFlagsInput, MediaUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutFlagsInput
    connect?: MediaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlaggedMediaInput = {
    create?: XOR<UserCreateWithoutFlaggedMediaInput, UserUncheckedCreateWithoutFlaggedMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlaggedMediaInput
    connect?: UserWhereUniqueInput
  }

  export type MediaUpdateOneRequiredWithoutFlagsNestedInput = {
    create?: XOR<MediaCreateWithoutFlagsInput, MediaUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutFlagsInput
    upsert?: MediaUpsertWithoutFlagsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutFlagsInput, MediaUpdateWithoutFlagsInput>, MediaUncheckedUpdateWithoutFlagsInput>
  }

  export type UserUpdateOneRequiredWithoutFlaggedMediaNestedInput = {
    create?: XOR<UserCreateWithoutFlaggedMediaInput, UserUncheckedCreateWithoutFlaggedMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlaggedMediaInput
    upsert?: UserUpsertWithoutFlaggedMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlaggedMediaInput, UserUpdateWithoutFlaggedMediaInput>, UserUncheckedUpdateWithoutFlaggedMediaInput>
  }

  export type UserCreateNestedOneWithoutFeedEventsInput = {
    create?: XOR<UserCreateWithoutFeedEventsInput, UserUncheckedCreateWithoutFeedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type VibeCreateNestedOneWithoutFeedEventsInput = {
    create?: XOR<VibeCreateWithoutFeedEventsInput, VibeUncheckedCreateWithoutFeedEventsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutFeedEventsInput
    connect?: VibeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeedEventsNestedInput = {
    create?: XOR<UserCreateWithoutFeedEventsInput, UserUncheckedCreateWithoutFeedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedEventsInput
    upsert?: UserUpsertWithoutFeedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedEventsInput, UserUpdateWithoutFeedEventsInput>, UserUncheckedUpdateWithoutFeedEventsInput>
  }

  export type VibeUpdateOneWithoutFeedEventsNestedInput = {
    create?: XOR<VibeCreateWithoutFeedEventsInput, VibeUncheckedCreateWithoutFeedEventsInput>
    connectOrCreate?: VibeCreateOrConnectWithoutFeedEventsInput
    upsert?: VibeUpsertWithoutFeedEventsInput
    disconnect?: VibeWhereInput | boolean
    delete?: VibeWhereInput | boolean
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutFeedEventsInput, VibeUpdateWithoutFeedEventsInput>, VibeUncheckedUpdateWithoutFeedEventsInput>
  }

  export type UserCreateNestedOneWithoutSuggestedToInput = {
    create?: XOR<UserCreateWithoutSuggestedToInput, UserUncheckedCreateWithoutSuggestedToInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestedToInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSuggestedFromInput = {
    create?: XOR<UserCreateWithoutSuggestedFromInput, UserUncheckedCreateWithoutSuggestedFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestedFromInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSuggestedToNestedInput = {
    create?: XOR<UserCreateWithoutSuggestedToInput, UserUncheckedCreateWithoutSuggestedToInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestedToInput
    upsert?: UserUpsertWithoutSuggestedToInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuggestedToInput, UserUpdateWithoutSuggestedToInput>, UserUncheckedUpdateWithoutSuggestedToInput>
  }

  export type UserUpdateOneRequiredWithoutSuggestedFromNestedInput = {
    create?: XOR<UserCreateWithoutSuggestedFromInput, UserUncheckedCreateWithoutSuggestedFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestedFromInput
    upsert?: UserUpsertWithoutSuggestedFromInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuggestedFromInput, UserUpdateWithoutSuggestedFromInput>, UserUncheckedUpdateWithoutSuggestedFromInput>
  }

  export type VibeCreateNestedOneWithoutCityFeedCacheInput = {
    create?: XOR<VibeCreateWithoutCityFeedCacheInput, VibeUncheckedCreateWithoutCityFeedCacheInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCityFeedCacheInput
    connect?: VibeWhereUniqueInput
  }

  export type VibeUpdateOneRequiredWithoutCityFeedCacheNestedInput = {
    create?: XOR<VibeCreateWithoutCityFeedCacheInput, VibeUncheckedCreateWithoutCityFeedCacheInput>
    connectOrCreate?: VibeCreateOrConnectWithoutCityFeedCacheInput
    upsert?: VibeUpsertWithoutCityFeedCacheInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutCityFeedCacheInput, VibeUpdateWithoutCityFeedCacheInput>, VibeUncheckedUpdateWithoutCityFeedCacheInput>
  }

  export type UserCreateNestedOneWithoutInviteQueueInput = {
    create?: XOR<UserCreateWithoutInviteQueueInput, UserUncheckedCreateWithoutInviteQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteQueueInput
    connect?: UserWhereUniqueInput
  }

  export type VibeCreateNestedOneWithoutInviteQueueInput = {
    create?: XOR<VibeCreateWithoutInviteQueueInput, VibeUncheckedCreateWithoutInviteQueueInput>
    connectOrCreate?: VibeCreateOrConnectWithoutInviteQueueInput
    connect?: VibeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInviteQueueNestedInput = {
    create?: XOR<UserCreateWithoutInviteQueueInput, UserUncheckedCreateWithoutInviteQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteQueueInput
    upsert?: UserUpsertWithoutInviteQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInviteQueueInput, UserUpdateWithoutInviteQueueInput>, UserUncheckedUpdateWithoutInviteQueueInput>
  }

  export type VibeUpdateOneRequiredWithoutInviteQueueNestedInput = {
    create?: XOR<VibeCreateWithoutInviteQueueInput, VibeUncheckedCreateWithoutInviteQueueInput>
    connectOrCreate?: VibeCreateOrConnectWithoutInviteQueueInput
    upsert?: VibeUpsertWithoutInviteQueueInput
    connect?: VibeWhereUniqueInput
    update?: XOR<XOR<VibeUpdateToOneWithWhereWithoutInviteQueueInput, VibeUpdateWithoutInviteQueueInput>, VibeUncheckedUpdateWithoutInviteQueueInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutInvitedUsersInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutInvitedUsersInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutInvitedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
  }

  export type UserCreateWithoutInvitedByInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutInvitedByInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput>
  }

  export type UserCreateManyInvitedByInputEnvelope = {
    data: UserCreateManyInvitedByInput | UserCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type VibeCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutCreatedByInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput>
  }

  export type VibeCreateManyCreatedByInputEnvelope = {
    data: VibeCreateManyCreatedByInput | VibeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type VibeContributorCreateWithoutUserInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutContributorsInput
  }

  export type VibeContributorUncheckedCreateWithoutUserInput = {
    id?: string
    vibeId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type VibeContributorCreateOrConnectWithoutUserInput = {
    where: VibeContributorWhereUniqueInput
    create: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput>
  }

  export type VibeContributorCreateManyUserInputEnvelope = {
    data: VibeContributorCreateManyUserInput | VibeContributorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutUploadedByInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutUploadedByInput = {
    id?: string
    vibeId: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput>
  }

  export type MediaCreateManyUploadedByInputEnvelope = {
    data: MediaCreateManyUploadedByInput | MediaCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type VibeViewerCreateWithoutViewerInput = {
    id?: string
    viewedAt?: Date | string
    vibe: VibeCreateNestedOneWithoutViewersInput
  }

  export type VibeViewerUncheckedCreateWithoutViewerInput = {
    id?: string
    vibeId: string
    viewedAt?: Date | string
  }

  export type VibeViewerCreateOrConnectWithoutViewerInput = {
    where: VibeViewerWhereUniqueInput
    create: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput>
  }

  export type VibeViewerCreateManyViewerInputEnvelope = {
    data: VibeViewerCreateManyViewerInput | VibeViewerCreateManyViewerInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    favoritedAt?: Date | string
    media: MediaCreateNestedOneWithoutFavoritedByInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    mediaId: string
    favoritedAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentNotificationsInput
    vibe?: VibeCreateNestedOneWithoutNotificationsInput
    media?: MediaCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    type: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    vibe?: VibeCreateNestedOneWithoutNotificationsInput
    media?: MediaCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DraftCreateWithoutUserInput = {
    id?: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutDraftsInput
  }

  export type DraftUncheckedCreateWithoutUserInput = {
    id?: string
    vibeId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type DraftCreateOrConnectWithoutUserInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput>
  }

  export type DraftCreateManyUserInputEnvelope = {
    data: DraftCreateManyUserInput | DraftCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VibeInviteCreateWithoutInvitedUserInput = {
    id?: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutInvitesInput
    invitedBy: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type VibeInviteUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    vibeId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteCreateOrConnectWithoutInvitedUserInput = {
    where: VibeInviteWhereUniqueInput
    create: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput>
  }

  export type VibeInviteCreateManyInvitedUserInputEnvelope = {
    data: VibeInviteCreateManyInvitedUserInput | VibeInviteCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type VibeInviteCreateWithoutInvitedByInput = {
    id?: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    vibe: VibeCreateNestedOneWithoutInvitesInput
    invitedUser: UserCreateNestedOneWithoutInvitesInput
  }

  export type VibeInviteUncheckedCreateWithoutInvitedByInput = {
    id?: string
    vibeId: string
    invitedUserId: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteCreateOrConnectWithoutInvitedByInput = {
    where: VibeInviteWhereUniqueInput
    create: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput>
  }

  export type VibeInviteCreateManyInvitedByInputEnvelope = {
    data: VibeInviteCreateManyInvitedByInput | VibeInviteCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type SuggestedUserCreateWithoutUserInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    suggestedUser: UserCreateNestedOneWithoutSuggestedFromInput
  }

  export type SuggestedUserUncheckedCreateWithoutUserInput = {
    id?: string
    suggestedUserId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SuggestedUserCreateOrConnectWithoutUserInput = {
    where: SuggestedUserWhereUniqueInput
    create: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput>
  }

  export type SuggestedUserCreateManyUserInputEnvelope = {
    data: SuggestedUserCreateManyUserInput | SuggestedUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SuggestedUserCreateWithoutSuggestedUserInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutSuggestedToInput
  }

  export type SuggestedUserUncheckedCreateWithoutSuggestedUserInput = {
    id?: string
    userId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SuggestedUserCreateOrConnectWithoutSuggestedUserInput = {
    where: SuggestedUserWhereUniqueInput
    create: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput>
  }

  export type SuggestedUserCreateManySuggestedUserInputEnvelope = {
    data: SuggestedUserCreateManySuggestedUserInput | SuggestedUserCreateManySuggestedUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedEventCreateWithoutUserInput = {
    id?: string
    eventType: string
    createdAt?: Date | string
    vibe?: VibeCreateNestedOneWithoutFeedEventsInput
  }

  export type FeedEventUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    vibeId?: string | null
    createdAt?: Date | string
  }

  export type FeedEventCreateOrConnectWithoutUserInput = {
    where: FeedEventWhereUniqueInput
    create: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput>
  }

  export type FeedEventCreateManyUserInputEnvelope = {
    data: FeedEventCreateManyUserInput | FeedEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InviteQueueCreateWithoutUserInput = {
    id?: string
    invitedAt?: Date | string
    vibe: VibeCreateNestedOneWithoutInviteQueueInput
  }

  export type InviteQueueUncheckedCreateWithoutUserInput = {
    id?: string
    vibeId: string
    invitedAt?: Date | string
  }

  export type InviteQueueCreateOrConnectWithoutUserInput = {
    where: InviteQueueWhereUniqueInput
    create: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput>
  }

  export type InviteQueueCreateManyUserInputEnvelope = {
    data: InviteQueueCreateManyUserInput | InviteQueueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaFlagCreateWithoutFlaggedByInput = {
    id?: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
    media: MediaCreateNestedOneWithoutFlagsInput
  }

  export type MediaFlagUncheckedCreateWithoutFlaggedByInput = {
    id?: string
    mediaId: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type MediaFlagCreateOrConnectWithoutFlaggedByInput = {
    where: MediaFlagWhereUniqueInput
    create: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput>
  }

  export type MediaFlagCreateManyFlaggedByInputEnvelope = {
    data: MediaFlagCreateManyFlaggedByInput | MediaFlagCreateManyFlaggedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvitedUsersInput = {
    update: XOR<UserUpdateWithoutInvitedUsersInput, UserUncheckedUpdateWithoutInvitedUsersInput>
    create: XOR<UserCreateWithoutInvitedUsersInput, UserUncheckedCreateWithoutInvitedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitedUsersInput, UserUncheckedUpdateWithoutInvitedUsersInput>
  }

  export type UserUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutInvitedByInput, UserUncheckedUpdateWithoutInvitedByInput>
    create: XOR<UserCreateWithoutInvitedByInput, UserUncheckedCreateWithoutInvitedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutInvitedByInput, UserUncheckedUpdateWithoutInvitedByInput>
  }

  export type UserUpdateManyWithWhereWithoutInvitedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    timeZone?: StringNullableFilter<"User"> | string | null
    joinedAt?: DateTimeFilter<"User"> | Date | string
    inviteCode?: StringNullableFilter<"User"> | string | null
    invitedById?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    firebaseUid?: StringNullableFilter<"User"> | string | null
  }

  export type VibeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: VibeWhereUniqueInput
    update: XOR<VibeUpdateWithoutCreatedByInput, VibeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<VibeCreateWithoutCreatedByInput, VibeUncheckedCreateWithoutCreatedByInput>
  }

  export type VibeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: VibeWhereUniqueInput
    data: XOR<VibeUpdateWithoutCreatedByInput, VibeUncheckedUpdateWithoutCreatedByInput>
  }

  export type VibeUpdateManyWithWhereWithoutCreatedByInput = {
    where: VibeScalarWhereInput
    data: XOR<VibeUpdateManyMutationInput, VibeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type VibeScalarWhereInput = {
    AND?: VibeScalarWhereInput | VibeScalarWhereInput[]
    OR?: VibeScalarWhereInput[]
    NOT?: VibeScalarWhereInput | VibeScalarWhereInput[]
    id?: StringFilter<"Vibe"> | string
    title?: StringFilter<"Vibe"> | string
    description?: StringNullableFilter<"Vibe"> | string | null
    location?: StringNullableFilter<"Vibe"> | string | null
    startDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    coverMediaId?: StringNullableFilter<"Vibe"> | string | null
    createdById?: StringFilter<"Vibe"> | string
    isShared?: BoolFilter<"Vibe"> | boolean
    status?: StringFilter<"Vibe"> | string
    finalizedAt?: DateTimeNullableFilter<"Vibe"> | Date | string | null
    createdAt?: DateTimeFilter<"Vibe"> | Date | string
    updatedAt?: DateTimeFilter<"Vibe"> | Date | string
  }

  export type VibeContributorUpsertWithWhereUniqueWithoutUserInput = {
    where: VibeContributorWhereUniqueInput
    update: XOR<VibeContributorUpdateWithoutUserInput, VibeContributorUncheckedUpdateWithoutUserInput>
    create: XOR<VibeContributorCreateWithoutUserInput, VibeContributorUncheckedCreateWithoutUserInput>
  }

  export type VibeContributorUpdateWithWhereUniqueWithoutUserInput = {
    where: VibeContributorWhereUniqueInput
    data: XOR<VibeContributorUpdateWithoutUserInput, VibeContributorUncheckedUpdateWithoutUserInput>
  }

  export type VibeContributorUpdateManyWithWhereWithoutUserInput = {
    where: VibeContributorScalarWhereInput
    data: XOR<VibeContributorUpdateManyMutationInput, VibeContributorUncheckedUpdateManyWithoutUserInput>
  }

  export type VibeContributorScalarWhereInput = {
    AND?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
    OR?: VibeContributorScalarWhereInput[]
    NOT?: VibeContributorScalarWhereInput | VibeContributorScalarWhereInput[]
    id?: StringFilter<"VibeContributor"> | string
    vibeId?: StringFilter<"VibeContributor"> | string
    userId?: StringFilter<"VibeContributor"> | string
    role?: StringFilter<"VibeContributor"> | string
    joinedAt?: DateTimeFilter<"VibeContributor"> | Date | string
    hasUploaded?: BoolFilter<"VibeContributor"> | boolean
    leftAt?: DateTimeNullableFilter<"VibeContributor"> | Date | string | null
  }

  export type MediaUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutUploadedByInput, MediaUncheckedUpdateWithoutUploadedByInput>
    create: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutUploadedByInput, MediaUncheckedUpdateWithoutUploadedByInput>
  }

  export type MediaUpdateManyWithWhereWithoutUploadedByInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    vibeId?: StringFilter<"Media"> | string
    uploadedById?: StringFilter<"Media"> | string
    mediaType?: StringFilter<"Media"> | string
    mediaUrl?: StringFilter<"Media"> | string
    thumbnailUrl?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    timestamp?: DateTimeNullableFilter<"Media"> | Date | string | null
    exifData?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type VibeViewerUpsertWithWhereUniqueWithoutViewerInput = {
    where: VibeViewerWhereUniqueInput
    update: XOR<VibeViewerUpdateWithoutViewerInput, VibeViewerUncheckedUpdateWithoutViewerInput>
    create: XOR<VibeViewerCreateWithoutViewerInput, VibeViewerUncheckedCreateWithoutViewerInput>
  }

  export type VibeViewerUpdateWithWhereUniqueWithoutViewerInput = {
    where: VibeViewerWhereUniqueInput
    data: XOR<VibeViewerUpdateWithoutViewerInput, VibeViewerUncheckedUpdateWithoutViewerInput>
  }

  export type VibeViewerUpdateManyWithWhereWithoutViewerInput = {
    where: VibeViewerScalarWhereInput
    data: XOR<VibeViewerUpdateManyMutationInput, VibeViewerUncheckedUpdateManyWithoutViewerInput>
  }

  export type VibeViewerScalarWhereInput = {
    AND?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
    OR?: VibeViewerScalarWhereInput[]
    NOT?: VibeViewerScalarWhereInput | VibeViewerScalarWhereInput[]
    id?: StringFilter<"VibeViewer"> | string
    vibeId?: StringFilter<"VibeViewer"> | string
    viewerId?: StringFilter<"VibeViewer"> | string
    viewedAt?: DateTimeFilter<"VibeViewer"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    mediaId?: StringFilter<"Favorite"> | string
    favoritedAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    vibeId?: StringNullableFilter<"Notification"> | string | null
    mediaId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type DraftUpsertWithWhereUniqueWithoutUserInput = {
    where: DraftWhereUniqueInput
    update: XOR<DraftUpdateWithoutUserInput, DraftUncheckedUpdateWithoutUserInput>
    create: XOR<DraftCreateWithoutUserInput, DraftUncheckedCreateWithoutUserInput>
  }

  export type DraftUpdateWithWhereUniqueWithoutUserInput = {
    where: DraftWhereUniqueInput
    data: XOR<DraftUpdateWithoutUserInput, DraftUncheckedUpdateWithoutUserInput>
  }

  export type DraftUpdateManyWithWhereWithoutUserInput = {
    where: DraftScalarWhereInput
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyWithoutUserInput>
  }

  export type DraftScalarWhereInput = {
    AND?: DraftScalarWhereInput | DraftScalarWhereInput[]
    OR?: DraftScalarWhereInput[]
    NOT?: DraftScalarWhereInput | DraftScalarWhereInput[]
    id?: StringFilter<"Draft"> | string
    userId?: StringFilter<"Draft"> | string
    vibeId?: StringFilter<"Draft"> | string
    lastEditedAt?: DateTimeFilter<"Draft"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
  }

  export type VibeInviteUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: VibeInviteWhereUniqueInput
    update: XOR<VibeInviteUpdateWithoutInvitedUserInput, VibeInviteUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<VibeInviteCreateWithoutInvitedUserInput, VibeInviteUncheckedCreateWithoutInvitedUserInput>
  }

  export type VibeInviteUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: VibeInviteWhereUniqueInput
    data: XOR<VibeInviteUpdateWithoutInvitedUserInput, VibeInviteUncheckedUpdateWithoutInvitedUserInput>
  }

  export type VibeInviteUpdateManyWithWhereWithoutInvitedUserInput = {
    where: VibeInviteScalarWhereInput
    data: XOR<VibeInviteUpdateManyMutationInput, VibeInviteUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type VibeInviteScalarWhereInput = {
    AND?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
    OR?: VibeInviteScalarWhereInput[]
    NOT?: VibeInviteScalarWhereInput | VibeInviteScalarWhereInput[]
    id?: StringFilter<"VibeInvite"> | string
    vibeId?: StringFilter<"VibeInvite"> | string
    invitedUserId?: StringFilter<"VibeInvite"> | string
    invitedById?: StringFilter<"VibeInvite"> | string
    status?: StringFilter<"VibeInvite"> | string
    invitedAt?: DateTimeFilter<"VibeInvite"> | Date | string
    respondedAt?: DateTimeNullableFilter<"VibeInvite"> | Date | string | null
  }

  export type VibeInviteUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: VibeInviteWhereUniqueInput
    update: XOR<VibeInviteUpdateWithoutInvitedByInput, VibeInviteUncheckedUpdateWithoutInvitedByInput>
    create: XOR<VibeInviteCreateWithoutInvitedByInput, VibeInviteUncheckedCreateWithoutInvitedByInput>
  }

  export type VibeInviteUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: VibeInviteWhereUniqueInput
    data: XOR<VibeInviteUpdateWithoutInvitedByInput, VibeInviteUncheckedUpdateWithoutInvitedByInput>
  }

  export type VibeInviteUpdateManyWithWhereWithoutInvitedByInput = {
    where: VibeInviteScalarWhereInput
    data: XOR<VibeInviteUpdateManyMutationInput, VibeInviteUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type SuggestedUserUpsertWithWhereUniqueWithoutUserInput = {
    where: SuggestedUserWhereUniqueInput
    update: XOR<SuggestedUserUpdateWithoutUserInput, SuggestedUserUncheckedUpdateWithoutUserInput>
    create: XOR<SuggestedUserCreateWithoutUserInput, SuggestedUserUncheckedCreateWithoutUserInput>
  }

  export type SuggestedUserUpdateWithWhereUniqueWithoutUserInput = {
    where: SuggestedUserWhereUniqueInput
    data: XOR<SuggestedUserUpdateWithoutUserInput, SuggestedUserUncheckedUpdateWithoutUserInput>
  }

  export type SuggestedUserUpdateManyWithWhereWithoutUserInput = {
    where: SuggestedUserScalarWhereInput
    data: XOR<SuggestedUserUpdateManyMutationInput, SuggestedUserUncheckedUpdateManyWithoutUserInput>
  }

  export type SuggestedUserScalarWhereInput = {
    AND?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
    OR?: SuggestedUserScalarWhereInput[]
    NOT?: SuggestedUserScalarWhereInput | SuggestedUserScalarWhereInput[]
    id?: StringFilter<"SuggestedUser"> | string
    userId?: StringFilter<"SuggestedUser"> | string
    suggestedUserId?: StringFilter<"SuggestedUser"> | string
    reason?: StringNullableFilter<"SuggestedUser"> | string | null
    createdAt?: DateTimeFilter<"SuggestedUser"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SuggestedUser"> | Date | string | null
  }

  export type SuggestedUserUpsertWithWhereUniqueWithoutSuggestedUserInput = {
    where: SuggestedUserWhereUniqueInput
    update: XOR<SuggestedUserUpdateWithoutSuggestedUserInput, SuggestedUserUncheckedUpdateWithoutSuggestedUserInput>
    create: XOR<SuggestedUserCreateWithoutSuggestedUserInput, SuggestedUserUncheckedCreateWithoutSuggestedUserInput>
  }

  export type SuggestedUserUpdateWithWhereUniqueWithoutSuggestedUserInput = {
    where: SuggestedUserWhereUniqueInput
    data: XOR<SuggestedUserUpdateWithoutSuggestedUserInput, SuggestedUserUncheckedUpdateWithoutSuggestedUserInput>
  }

  export type SuggestedUserUpdateManyWithWhereWithoutSuggestedUserInput = {
    where: SuggestedUserScalarWhereInput
    data: XOR<SuggestedUserUpdateManyMutationInput, SuggestedUserUncheckedUpdateManyWithoutSuggestedUserInput>
  }

  export type FeedEventUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedEventWhereUniqueInput
    update: XOR<FeedEventUpdateWithoutUserInput, FeedEventUncheckedUpdateWithoutUserInput>
    create: XOR<FeedEventCreateWithoutUserInput, FeedEventUncheckedCreateWithoutUserInput>
  }

  export type FeedEventUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedEventWhereUniqueInput
    data: XOR<FeedEventUpdateWithoutUserInput, FeedEventUncheckedUpdateWithoutUserInput>
  }

  export type FeedEventUpdateManyWithWhereWithoutUserInput = {
    where: FeedEventScalarWhereInput
    data: XOR<FeedEventUpdateManyMutationInput, FeedEventUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedEventScalarWhereInput = {
    AND?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
    OR?: FeedEventScalarWhereInput[]
    NOT?: FeedEventScalarWhereInput | FeedEventScalarWhereInput[]
    id?: StringFilter<"FeedEvent"> | string
    userId?: StringFilter<"FeedEvent"> | string
    eventType?: StringFilter<"FeedEvent"> | string
    vibeId?: StringNullableFilter<"FeedEvent"> | string | null
    createdAt?: DateTimeFilter<"FeedEvent"> | Date | string
  }

  export type InviteQueueUpsertWithWhereUniqueWithoutUserInput = {
    where: InviteQueueWhereUniqueInput
    update: XOR<InviteQueueUpdateWithoutUserInput, InviteQueueUncheckedUpdateWithoutUserInput>
    create: XOR<InviteQueueCreateWithoutUserInput, InviteQueueUncheckedCreateWithoutUserInput>
  }

  export type InviteQueueUpdateWithWhereUniqueWithoutUserInput = {
    where: InviteQueueWhereUniqueInput
    data: XOR<InviteQueueUpdateWithoutUserInput, InviteQueueUncheckedUpdateWithoutUserInput>
  }

  export type InviteQueueUpdateManyWithWhereWithoutUserInput = {
    where: InviteQueueScalarWhereInput
    data: XOR<InviteQueueUpdateManyMutationInput, InviteQueueUncheckedUpdateManyWithoutUserInput>
  }

  export type InviteQueueScalarWhereInput = {
    AND?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
    OR?: InviteQueueScalarWhereInput[]
    NOT?: InviteQueueScalarWhereInput | InviteQueueScalarWhereInput[]
    id?: StringFilter<"InviteQueue"> | string
    userId?: StringFilter<"InviteQueue"> | string
    vibeId?: StringFilter<"InviteQueue"> | string
    invitedAt?: DateTimeFilter<"InviteQueue"> | Date | string
  }

  export type MediaFlagUpsertWithWhereUniqueWithoutFlaggedByInput = {
    where: MediaFlagWhereUniqueInput
    update: XOR<MediaFlagUpdateWithoutFlaggedByInput, MediaFlagUncheckedUpdateWithoutFlaggedByInput>
    create: XOR<MediaFlagCreateWithoutFlaggedByInput, MediaFlagUncheckedCreateWithoutFlaggedByInput>
  }

  export type MediaFlagUpdateWithWhereUniqueWithoutFlaggedByInput = {
    where: MediaFlagWhereUniqueInput
    data: XOR<MediaFlagUpdateWithoutFlaggedByInput, MediaFlagUncheckedUpdateWithoutFlaggedByInput>
  }

  export type MediaFlagUpdateManyWithWhereWithoutFlaggedByInput = {
    where: MediaFlagScalarWhereInput
    data: XOR<MediaFlagUpdateManyMutationInput, MediaFlagUncheckedUpdateManyWithoutFlaggedByInput>
  }

  export type MediaFlagScalarWhereInput = {
    AND?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
    OR?: MediaFlagScalarWhereInput[]
    NOT?: MediaFlagScalarWhereInput | MediaFlagScalarWhereInput[]
    id?: StringFilter<"MediaFlag"> | string
    mediaId?: StringFilter<"MediaFlag"> | string
    flaggedById?: StringFilter<"MediaFlag"> | string
    reason?: StringFilter<"MediaFlag"> | string
    additionalInfo?: StringNullableFilter<"MediaFlag"> | string | null
    flaggedAt?: DateTimeFilter<"MediaFlag"> | Date | string
  }

  export type MediaCreateWithoutCoverOfVibeInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCoverOfVibeInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCoverOfVibeInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCoverOfVibeInput, MediaUncheckedCreateWithoutCoverOfVibeInput>
  }

  export type UserCreateWithoutCreatedVibesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutCreatedVibesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutCreatedVibesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedVibesInput, UserUncheckedCreateWithoutCreatedVibesInput>
  }

  export type VibeContributorCreateWithoutVibeInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutContributedVibesInput
  }

  export type VibeContributorUncheckedCreateWithoutVibeInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type VibeContributorCreateOrConnectWithoutVibeInput = {
    where: VibeContributorWhereUniqueInput
    create: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput>
  }

  export type VibeContributorCreateManyVibeInputEnvelope = {
    data: VibeContributorCreateManyVibeInput | VibeContributorCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutVibeInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutVibeInput = {
    id?: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutVibeInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput>
  }

  export type MediaCreateManyVibeInputEnvelope = {
    data: MediaCreateManyVibeInput | MediaCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type VibeViewerCreateWithoutVibeInput = {
    id?: string
    viewedAt?: Date | string
    viewer: UserCreateNestedOneWithoutVibeViewsInput
  }

  export type VibeViewerUncheckedCreateWithoutVibeInput = {
    id?: string
    viewerId: string
    viewedAt?: Date | string
  }

  export type VibeViewerCreateOrConnectWithoutVibeInput = {
    where: VibeViewerWhereUniqueInput
    create: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput>
  }

  export type VibeViewerCreateManyVibeInputEnvelope = {
    data: VibeViewerCreateManyVibeInput | VibeViewerCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type DraftCreateWithoutVibeInput = {
    id?: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutDraftsInput
  }

  export type DraftUncheckedCreateWithoutVibeInput = {
    id?: string
    userId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type DraftCreateOrConnectWithoutVibeInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput>
  }

  export type DraftCreateManyVibeInputEnvelope = {
    data: DraftCreateManyVibeInput | DraftCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type VibeInviteCreateWithoutVibeInput = {
    id?: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    invitedUser: UserCreateNestedOneWithoutInvitesInput
    invitedBy: UserCreateNestedOneWithoutSentInvitesInput
  }

  export type VibeInviteUncheckedCreateWithoutVibeInput = {
    id?: string
    invitedUserId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteCreateOrConnectWithoutVibeInput = {
    where: VibeInviteWhereUniqueInput
    create: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput>
  }

  export type VibeInviteCreateManyVibeInputEnvelope = {
    data: VibeInviteCreateManyVibeInput | VibeInviteCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutVibeInput = {
    id?: string
    type: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender: UserCreateNestedOneWithoutSentNotificationsInput
    media?: MediaCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutVibeInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutVibeInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput>
  }

  export type NotificationCreateManyVibeInputEnvelope = {
    data: NotificationCreateManyVibeInput | NotificationCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type FeedEventCreateWithoutVibeInput = {
    id?: string
    eventType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedEventsInput
  }

  export type FeedEventUncheckedCreateWithoutVibeInput = {
    id?: string
    userId: string
    eventType: string
    createdAt?: Date | string
  }

  export type FeedEventCreateOrConnectWithoutVibeInput = {
    where: FeedEventWhereUniqueInput
    create: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput>
  }

  export type FeedEventCreateManyVibeInputEnvelope = {
    data: FeedEventCreateManyVibeInput | FeedEventCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type CityFeedCacheCreateWithoutVibeInput = {
    id?: string
    city: string
    cachedAt?: Date | string
  }

  export type CityFeedCacheUncheckedCreateWithoutVibeInput = {
    id?: string
    city: string
    cachedAt?: Date | string
  }

  export type CityFeedCacheCreateOrConnectWithoutVibeInput = {
    where: CityFeedCacheWhereUniqueInput
    create: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput>
  }

  export type CityFeedCacheCreateManyVibeInputEnvelope = {
    data: CityFeedCacheCreateManyVibeInput | CityFeedCacheCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type InviteQueueCreateWithoutVibeInput = {
    id?: string
    invitedAt?: Date | string
    user: UserCreateNestedOneWithoutInviteQueueInput
  }

  export type InviteQueueUncheckedCreateWithoutVibeInput = {
    id?: string
    userId: string
    invitedAt?: Date | string
  }

  export type InviteQueueCreateOrConnectWithoutVibeInput = {
    where: InviteQueueWhereUniqueInput
    create: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput>
  }

  export type InviteQueueCreateManyVibeInputEnvelope = {
    data: InviteQueueCreateManyVibeInput | InviteQueueCreateManyVibeInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutCoverOfVibeInput = {
    update: XOR<MediaUpdateWithoutCoverOfVibeInput, MediaUncheckedUpdateWithoutCoverOfVibeInput>
    create: XOR<MediaCreateWithoutCoverOfVibeInput, MediaUncheckedCreateWithoutCoverOfVibeInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCoverOfVibeInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCoverOfVibeInput, MediaUncheckedUpdateWithoutCoverOfVibeInput>
  }

  export type MediaUpdateWithoutCoverOfVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCoverOfVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserUpsertWithoutCreatedVibesInput = {
    update: XOR<UserUpdateWithoutCreatedVibesInput, UserUncheckedUpdateWithoutCreatedVibesInput>
    create: XOR<UserCreateWithoutCreatedVibesInput, UserUncheckedCreateWithoutCreatedVibesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedVibesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedVibesInput, UserUncheckedUpdateWithoutCreatedVibesInput>
  }

  export type UserUpdateWithoutCreatedVibesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedVibesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeContributorUpsertWithWhereUniqueWithoutVibeInput = {
    where: VibeContributorWhereUniqueInput
    update: XOR<VibeContributorUpdateWithoutVibeInput, VibeContributorUncheckedUpdateWithoutVibeInput>
    create: XOR<VibeContributorCreateWithoutVibeInput, VibeContributorUncheckedCreateWithoutVibeInput>
  }

  export type VibeContributorUpdateWithWhereUniqueWithoutVibeInput = {
    where: VibeContributorWhereUniqueInput
    data: XOR<VibeContributorUpdateWithoutVibeInput, VibeContributorUncheckedUpdateWithoutVibeInput>
  }

  export type VibeContributorUpdateManyWithWhereWithoutVibeInput = {
    where: VibeContributorScalarWhereInput
    data: XOR<VibeContributorUpdateManyMutationInput, VibeContributorUncheckedUpdateManyWithoutVibeInput>
  }

  export type MediaUpsertWithWhereUniqueWithoutVibeInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutVibeInput, MediaUncheckedUpdateWithoutVibeInput>
    create: XOR<MediaCreateWithoutVibeInput, MediaUncheckedCreateWithoutVibeInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutVibeInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutVibeInput, MediaUncheckedUpdateWithoutVibeInput>
  }

  export type MediaUpdateManyWithWhereWithoutVibeInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutVibeInput>
  }

  export type VibeViewerUpsertWithWhereUniqueWithoutVibeInput = {
    where: VibeViewerWhereUniqueInput
    update: XOR<VibeViewerUpdateWithoutVibeInput, VibeViewerUncheckedUpdateWithoutVibeInput>
    create: XOR<VibeViewerCreateWithoutVibeInput, VibeViewerUncheckedCreateWithoutVibeInput>
  }

  export type VibeViewerUpdateWithWhereUniqueWithoutVibeInput = {
    where: VibeViewerWhereUniqueInput
    data: XOR<VibeViewerUpdateWithoutVibeInput, VibeViewerUncheckedUpdateWithoutVibeInput>
  }

  export type VibeViewerUpdateManyWithWhereWithoutVibeInput = {
    where: VibeViewerScalarWhereInput
    data: XOR<VibeViewerUpdateManyMutationInput, VibeViewerUncheckedUpdateManyWithoutVibeInput>
  }

  export type DraftUpsertWithWhereUniqueWithoutVibeInput = {
    where: DraftWhereUniqueInput
    update: XOR<DraftUpdateWithoutVibeInput, DraftUncheckedUpdateWithoutVibeInput>
    create: XOR<DraftCreateWithoutVibeInput, DraftUncheckedCreateWithoutVibeInput>
  }

  export type DraftUpdateWithWhereUniqueWithoutVibeInput = {
    where: DraftWhereUniqueInput
    data: XOR<DraftUpdateWithoutVibeInput, DraftUncheckedUpdateWithoutVibeInput>
  }

  export type DraftUpdateManyWithWhereWithoutVibeInput = {
    where: DraftScalarWhereInput
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyWithoutVibeInput>
  }

  export type VibeInviteUpsertWithWhereUniqueWithoutVibeInput = {
    where: VibeInviteWhereUniqueInput
    update: XOR<VibeInviteUpdateWithoutVibeInput, VibeInviteUncheckedUpdateWithoutVibeInput>
    create: XOR<VibeInviteCreateWithoutVibeInput, VibeInviteUncheckedCreateWithoutVibeInput>
  }

  export type VibeInviteUpdateWithWhereUniqueWithoutVibeInput = {
    where: VibeInviteWhereUniqueInput
    data: XOR<VibeInviteUpdateWithoutVibeInput, VibeInviteUncheckedUpdateWithoutVibeInput>
  }

  export type VibeInviteUpdateManyWithWhereWithoutVibeInput = {
    where: VibeInviteScalarWhereInput
    data: XOR<VibeInviteUpdateManyMutationInput, VibeInviteUncheckedUpdateManyWithoutVibeInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutVibeInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutVibeInput, NotificationUncheckedUpdateWithoutVibeInput>
    create: XOR<NotificationCreateWithoutVibeInput, NotificationUncheckedCreateWithoutVibeInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutVibeInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutVibeInput, NotificationUncheckedUpdateWithoutVibeInput>
  }

  export type NotificationUpdateManyWithWhereWithoutVibeInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutVibeInput>
  }

  export type FeedEventUpsertWithWhereUniqueWithoutVibeInput = {
    where: FeedEventWhereUniqueInput
    update: XOR<FeedEventUpdateWithoutVibeInput, FeedEventUncheckedUpdateWithoutVibeInput>
    create: XOR<FeedEventCreateWithoutVibeInput, FeedEventUncheckedCreateWithoutVibeInput>
  }

  export type FeedEventUpdateWithWhereUniqueWithoutVibeInput = {
    where: FeedEventWhereUniqueInput
    data: XOR<FeedEventUpdateWithoutVibeInput, FeedEventUncheckedUpdateWithoutVibeInput>
  }

  export type FeedEventUpdateManyWithWhereWithoutVibeInput = {
    where: FeedEventScalarWhereInput
    data: XOR<FeedEventUpdateManyMutationInput, FeedEventUncheckedUpdateManyWithoutVibeInput>
  }

  export type CityFeedCacheUpsertWithWhereUniqueWithoutVibeInput = {
    where: CityFeedCacheWhereUniqueInput
    update: XOR<CityFeedCacheUpdateWithoutVibeInput, CityFeedCacheUncheckedUpdateWithoutVibeInput>
    create: XOR<CityFeedCacheCreateWithoutVibeInput, CityFeedCacheUncheckedCreateWithoutVibeInput>
  }

  export type CityFeedCacheUpdateWithWhereUniqueWithoutVibeInput = {
    where: CityFeedCacheWhereUniqueInput
    data: XOR<CityFeedCacheUpdateWithoutVibeInput, CityFeedCacheUncheckedUpdateWithoutVibeInput>
  }

  export type CityFeedCacheUpdateManyWithWhereWithoutVibeInput = {
    where: CityFeedCacheScalarWhereInput
    data: XOR<CityFeedCacheUpdateManyMutationInput, CityFeedCacheUncheckedUpdateManyWithoutVibeInput>
  }

  export type CityFeedCacheScalarWhereInput = {
    AND?: CityFeedCacheScalarWhereInput | CityFeedCacheScalarWhereInput[]
    OR?: CityFeedCacheScalarWhereInput[]
    NOT?: CityFeedCacheScalarWhereInput | CityFeedCacheScalarWhereInput[]
    id?: StringFilter<"CityFeedCache"> | string
    city?: StringFilter<"CityFeedCache"> | string
    vibeId?: StringFilter<"CityFeedCache"> | string
    cachedAt?: DateTimeFilter<"CityFeedCache"> | Date | string
  }

  export type InviteQueueUpsertWithWhereUniqueWithoutVibeInput = {
    where: InviteQueueWhereUniqueInput
    update: XOR<InviteQueueUpdateWithoutVibeInput, InviteQueueUncheckedUpdateWithoutVibeInput>
    create: XOR<InviteQueueCreateWithoutVibeInput, InviteQueueUncheckedCreateWithoutVibeInput>
  }

  export type InviteQueueUpdateWithWhereUniqueWithoutVibeInput = {
    where: InviteQueueWhereUniqueInput
    data: XOR<InviteQueueUpdateWithoutVibeInput, InviteQueueUncheckedUpdateWithoutVibeInput>
  }

  export type InviteQueueUpdateManyWithWhereWithoutVibeInput = {
    where: InviteQueueScalarWhereInput
    data: XOR<InviteQueueUpdateManyMutationInput, InviteQueueUncheckedUpdateManyWithoutVibeInput>
  }

  export type VibeCreateWithoutContributorsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutContributorsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutContributorsInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutContributorsInput, VibeUncheckedCreateWithoutContributorsInput>
  }

  export type UserCreateWithoutContributedVibesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutContributedVibesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutContributedVibesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContributedVibesInput, UserUncheckedCreateWithoutContributedVibesInput>
  }

  export type VibeUpsertWithoutContributorsInput = {
    update: XOR<VibeUpdateWithoutContributorsInput, VibeUncheckedUpdateWithoutContributorsInput>
    create: XOR<VibeCreateWithoutContributorsInput, VibeUncheckedCreateWithoutContributorsInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutContributorsInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutContributorsInput, VibeUncheckedUpdateWithoutContributorsInput>
  }

  export type VibeUpdateWithoutContributorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutContributorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserUpsertWithoutContributedVibesInput = {
    update: XOR<UserUpdateWithoutContributedVibesInput, UserUncheckedUpdateWithoutContributedVibesInput>
    create: XOR<UserCreateWithoutContributedVibesInput, UserUncheckedCreateWithoutContributedVibesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContributedVibesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContributedVibesInput, UserUncheckedUpdateWithoutContributedVibesInput>
  }

  export type UserUpdateWithoutContributedVibesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutContributedVibesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeCreateWithoutMediaInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutMediaInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutMediaInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutMediaInput, VibeUncheckedCreateWithoutMediaInput>
  }

  export type UserCreateWithoutMediaInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutMediaInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
  }

  export type FavoriteCreateWithoutMediaInput = {
    id?: string
    favoritedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutMediaInput = {
    id?: string
    userId: string
    favoritedAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutMediaInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput>
  }

  export type FavoriteCreateManyMediaInputEnvelope = {
    data: FavoriteCreateManyMediaInput | FavoriteCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type VibeCreateWithoutCoverMediaInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutCoverMediaInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutCoverMediaInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
  }

  export type MediaFlagCreateWithoutMediaInput = {
    id?: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
    flaggedBy: UserCreateNestedOneWithoutFlaggedMediaInput
  }

  export type MediaFlagUncheckedCreateWithoutMediaInput = {
    id?: string
    flaggedById: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type MediaFlagCreateOrConnectWithoutMediaInput = {
    where: MediaFlagWhereUniqueInput
    create: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput>
  }

  export type MediaFlagCreateManyMediaInputEnvelope = {
    data: MediaFlagCreateManyMediaInput | MediaFlagCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutMediaInput = {
    id?: string
    type: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender: UserCreateNestedOneWithoutSentNotificationsInput
    vibe?: VibeCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutMediaInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutMediaInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput>
  }

  export type NotificationCreateManyMediaInputEnvelope = {
    data: NotificationCreateManyMediaInput | NotificationCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type VibeUpsertWithoutMediaInput = {
    update: XOR<VibeUpdateWithoutMediaInput, VibeUncheckedUpdateWithoutMediaInput>
    create: XOR<VibeCreateWithoutMediaInput, VibeUncheckedCreateWithoutMediaInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutMediaInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutMediaInput, VibeUncheckedUpdateWithoutMediaInput>
  }

  export type VibeUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserUpsertWithoutMediaInput = {
    update: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type FavoriteUpsertWithWhereUniqueWithoutMediaInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutMediaInput, FavoriteUncheckedUpdateWithoutMediaInput>
    create: XOR<FavoriteCreateWithoutMediaInput, FavoriteUncheckedCreateWithoutMediaInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutMediaInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutMediaInput, FavoriteUncheckedUpdateWithoutMediaInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutMediaInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutMediaInput>
  }

  export type VibeUpsertWithoutCoverMediaInput = {
    update: XOR<VibeUpdateWithoutCoverMediaInput, VibeUncheckedUpdateWithoutCoverMediaInput>
    create: XOR<VibeCreateWithoutCoverMediaInput, VibeUncheckedCreateWithoutCoverMediaInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutCoverMediaInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutCoverMediaInput, VibeUncheckedUpdateWithoutCoverMediaInput>
  }

  export type VibeUpdateWithoutCoverMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutCoverMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type MediaFlagUpsertWithWhereUniqueWithoutMediaInput = {
    where: MediaFlagWhereUniqueInput
    update: XOR<MediaFlagUpdateWithoutMediaInput, MediaFlagUncheckedUpdateWithoutMediaInput>
    create: XOR<MediaFlagCreateWithoutMediaInput, MediaFlagUncheckedCreateWithoutMediaInput>
  }

  export type MediaFlagUpdateWithWhereUniqueWithoutMediaInput = {
    where: MediaFlagWhereUniqueInput
    data: XOR<MediaFlagUpdateWithoutMediaInput, MediaFlagUncheckedUpdateWithoutMediaInput>
  }

  export type MediaFlagUpdateManyWithWhereWithoutMediaInput = {
    where: MediaFlagScalarWhereInput
    data: XOR<MediaFlagUpdateManyMutationInput, MediaFlagUncheckedUpdateManyWithoutMediaInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutMediaInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMediaInput, NotificationUncheckedUpdateWithoutMediaInput>
    create: XOR<NotificationCreateWithoutMediaInput, NotificationUncheckedCreateWithoutMediaInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMediaInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMediaInput, NotificationUncheckedUpdateWithoutMediaInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMediaInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutMediaInput>
  }

  export type VibeCreateWithoutViewersInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutViewersInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutViewersInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutViewersInput, VibeUncheckedCreateWithoutViewersInput>
  }

  export type UserCreateWithoutVibeViewsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutVibeViewsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutVibeViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVibeViewsInput, UserUncheckedCreateWithoutVibeViewsInput>
  }

  export type VibeUpsertWithoutViewersInput = {
    update: XOR<VibeUpdateWithoutViewersInput, VibeUncheckedUpdateWithoutViewersInput>
    create: XOR<VibeCreateWithoutViewersInput, VibeUncheckedCreateWithoutViewersInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutViewersInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutViewersInput, VibeUncheckedUpdateWithoutViewersInput>
  }

  export type VibeUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserUpsertWithoutVibeViewsInput = {
    update: XOR<UserUpdateWithoutVibeViewsInput, UserUncheckedUpdateWithoutVibeViewsInput>
    create: XOR<UserCreateWithoutVibeViewsInput, UserUncheckedCreateWithoutVibeViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVibeViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVibeViewsInput, UserUncheckedUpdateWithoutVibeViewsInput>
  }

  export type UserUpdateWithoutVibeViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVibeViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type MediaCreateWithoutFavoritedByInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutFavoritedByInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutFavoritedByInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutFavoritedByInput, MediaUncheckedCreateWithoutFavoritedByInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type MediaUpsertWithoutFavoritedByInput = {
    update: XOR<MediaUpdateWithoutFavoritedByInput, MediaUncheckedUpdateWithoutFavoritedByInput>
    create: XOR<MediaCreateWithoutFavoritedByInput, MediaUncheckedCreateWithoutFavoritedByInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutFavoritedByInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutFavoritedByInput, MediaUncheckedUpdateWithoutFavoritedByInput>
  }

  export type MediaUpdateWithoutFavoritedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutFavoritedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type VibeCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutNotificationsInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutNotificationsInput, VibeUncheckedCreateWithoutNotificationsInput>
  }

  export type MediaCreateWithoutNotificationsInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutNotificationsInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    flags?: MediaFlagUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutNotificationsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutNotificationsInput, MediaUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeUpsertWithoutNotificationsInput = {
    update: XOR<VibeUpdateWithoutNotificationsInput, VibeUncheckedUpdateWithoutNotificationsInput>
    create: XOR<VibeCreateWithoutNotificationsInput, VibeUncheckedCreateWithoutNotificationsInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutNotificationsInput, VibeUncheckedUpdateWithoutNotificationsInput>
  }

  export type VibeUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type MediaUpsertWithoutNotificationsInput = {
    update: XOR<MediaUpdateWithoutNotificationsInput, MediaUncheckedUpdateWithoutNotificationsInput>
    create: XOR<MediaCreateWithoutNotificationsInput, MediaUncheckedCreateWithoutNotificationsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutNotificationsInput, MediaUncheckedUpdateWithoutNotificationsInput>
  }

  export type MediaUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserCreateWithoutDraftsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutDraftsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutDraftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDraftsInput, UserUncheckedCreateWithoutDraftsInput>
  }

  export type VibeCreateWithoutDraftsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutDraftsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutDraftsInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutDraftsInput, VibeUncheckedCreateWithoutDraftsInput>
  }

  export type UserUpsertWithoutDraftsInput = {
    update: XOR<UserUpdateWithoutDraftsInput, UserUncheckedUpdateWithoutDraftsInput>
    create: XOR<UserCreateWithoutDraftsInput, UserUncheckedCreateWithoutDraftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDraftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDraftsInput, UserUncheckedUpdateWithoutDraftsInput>
  }

  export type UserUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeUpsertWithoutDraftsInput = {
    update: XOR<VibeUpdateWithoutDraftsInput, VibeUncheckedUpdateWithoutDraftsInput>
    create: XOR<VibeCreateWithoutDraftsInput, VibeUncheckedCreateWithoutDraftsInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutDraftsInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutDraftsInput, VibeUncheckedUpdateWithoutDraftsInput>
  }

  export type VibeUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type VibeCreateWithoutInvitesInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutInvitesInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutInvitesInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutInvitesInput, VibeUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutInvitesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutInvitesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutSentInvitesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutSentInvitesInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutSentInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
  }

  export type VibeUpsertWithoutInvitesInput = {
    update: XOR<VibeUpdateWithoutInvitesInput, VibeUncheckedUpdateWithoutInvitesInput>
    create: XOR<VibeCreateWithoutInvitesInput, VibeUncheckedCreateWithoutInvitesInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutInvitesInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutInvitesInput, VibeUncheckedUpdateWithoutInvitesInput>
  }

  export type VibeUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserUpsertWithoutInvitesInput = {
    update: XOR<UserUpdateWithoutInvitesInput, UserUncheckedUpdateWithoutInvitesInput>
    create: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitesInput, UserUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUpsertWithoutSentInvitesInput = {
    update: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
    create: XOR<UserCreateWithoutSentInvitesInput, UserUncheckedCreateWithoutSentInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitesInput, UserUncheckedUpdateWithoutSentInvitesInput>
  }

  export type UserUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type MediaCreateWithoutFlagsInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vibe: VibeCreateNestedOneWithoutMediaInput
    uploadedBy: UserCreateNestedOneWithoutMediaInput
    favoritedBy?: FavoriteCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeCreateNestedOneWithoutCoverMediaInput
    notifications?: NotificationCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutFlagsInput = {
    id?: string
    vibeId: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    favoritedBy?: FavoriteUncheckedCreateNestedManyWithoutMediaInput
    coverOfVibe?: VibeUncheckedCreateNestedOneWithoutCoverMediaInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutFlagsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutFlagsInput, MediaUncheckedCreateWithoutFlagsInput>
  }

  export type UserCreateWithoutFlaggedMediaInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlaggedMediaInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlaggedMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlaggedMediaInput, UserUncheckedCreateWithoutFlaggedMediaInput>
  }

  export type MediaUpsertWithoutFlagsInput = {
    update: XOR<MediaUpdateWithoutFlagsInput, MediaUncheckedUpdateWithoutFlagsInput>
    create: XOR<MediaCreateWithoutFlagsInput, MediaUncheckedCreateWithoutFlagsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutFlagsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutFlagsInput, MediaUncheckedUpdateWithoutFlagsInput>
  }

  export type MediaUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserUpsertWithoutFlaggedMediaInput = {
    update: XOR<UserUpdateWithoutFlaggedMediaInput, UserUncheckedUpdateWithoutFlaggedMediaInput>
    create: XOR<UserCreateWithoutFlaggedMediaInput, UserUncheckedCreateWithoutFlaggedMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlaggedMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlaggedMediaInput, UserUncheckedUpdateWithoutFlaggedMediaInput>
  }

  export type UserUpdateWithoutFlaggedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlaggedMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedEventsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutFeedEventsInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutFeedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedEventsInput, UserUncheckedCreateWithoutFeedEventsInput>
  }

  export type VibeCreateWithoutFeedEventsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutFeedEventsInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutFeedEventsInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutFeedEventsInput, VibeUncheckedCreateWithoutFeedEventsInput>
  }

  export type UserUpsertWithoutFeedEventsInput = {
    update: XOR<UserUpdateWithoutFeedEventsInput, UserUncheckedUpdateWithoutFeedEventsInput>
    create: XOR<UserCreateWithoutFeedEventsInput, UserUncheckedCreateWithoutFeedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedEventsInput, UserUncheckedUpdateWithoutFeedEventsInput>
  }

  export type UserUpdateWithoutFeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeUpsertWithoutFeedEventsInput = {
    update: XOR<VibeUpdateWithoutFeedEventsInput, VibeUncheckedUpdateWithoutFeedEventsInput>
    create: XOR<VibeCreateWithoutFeedEventsInput, VibeUncheckedCreateWithoutFeedEventsInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutFeedEventsInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutFeedEventsInput, VibeUncheckedUpdateWithoutFeedEventsInput>
  }

  export type VibeUpdateWithoutFeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutFeedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserCreateWithoutSuggestedToInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutSuggestedToInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutSuggestedToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuggestedToInput, UserUncheckedCreateWithoutSuggestedToInput>
  }

  export type UserCreateWithoutSuggestedFromInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutSuggestedFromInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutSuggestedFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuggestedFromInput, UserUncheckedCreateWithoutSuggestedFromInput>
  }

  export type UserUpsertWithoutSuggestedToInput = {
    update: XOR<UserUpdateWithoutSuggestedToInput, UserUncheckedUpdateWithoutSuggestedToInput>
    create: XOR<UserCreateWithoutSuggestedToInput, UserUncheckedCreateWithoutSuggestedToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuggestedToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuggestedToInput, UserUncheckedUpdateWithoutSuggestedToInput>
  }

  export type UserUpdateWithoutSuggestedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSuggestedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUpsertWithoutSuggestedFromInput = {
    update: XOR<UserUpdateWithoutSuggestedFromInput, UserUncheckedUpdateWithoutSuggestedFromInput>
    create: XOR<UserCreateWithoutSuggestedFromInput, UserUncheckedCreateWithoutSuggestedFromInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuggestedFromInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuggestedFromInput, UserUncheckedUpdateWithoutSuggestedFromInput>
  }

  export type UserUpdateWithoutSuggestedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSuggestedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeCreateWithoutCityFeedCacheInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutCityFeedCacheInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    inviteQueue?: InviteQueueUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutCityFeedCacheInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutCityFeedCacheInput, VibeUncheckedCreateWithoutCityFeedCacheInput>
  }

  export type VibeUpsertWithoutCityFeedCacheInput = {
    update: XOR<VibeUpdateWithoutCityFeedCacheInput, VibeUncheckedUpdateWithoutCityFeedCacheInput>
    create: XOR<VibeCreateWithoutCityFeedCacheInput, VibeUncheckedCreateWithoutCityFeedCacheInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutCityFeedCacheInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutCityFeedCacheInput, VibeUncheckedUpdateWithoutCityFeedCacheInput>
  }

  export type VibeUpdateWithoutCityFeedCacheInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutCityFeedCacheInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserCreateWithoutInviteQueueInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedBy?: UserCreateNestedOneWithoutInvitedUsersInput
    invitedUsers?: UserCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerCreateNestedManyWithoutViewerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    drafts?: DraftCreateNestedManyWithoutUserInput
    invites?: VibeInviteCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagCreateNestedManyWithoutFlaggedByInput
  }

  export type UserUncheckedCreateWithoutInviteQueueInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    invitedById?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
    invitedUsers?: UserUncheckedCreateNestedManyWithoutInvitedByInput
    createdVibes?: VibeUncheckedCreateNestedManyWithoutCreatedByInput
    contributedVibes?: VibeContributorUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    vibeViews?: VibeViewerUncheckedCreateNestedManyWithoutViewerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    drafts?: DraftUncheckedCreateNestedManyWithoutUserInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedUserInput
    sentInvites?: VibeInviteUncheckedCreateNestedManyWithoutInvitedByInput
    suggestedTo?: SuggestedUserUncheckedCreateNestedManyWithoutUserInput
    suggestedFrom?: SuggestedUserUncheckedCreateNestedManyWithoutSuggestedUserInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutUserInput
    flaggedMedia?: MediaFlagUncheckedCreateNestedManyWithoutFlaggedByInput
  }

  export type UserCreateOrConnectWithoutInviteQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInviteQueueInput, UserUncheckedCreateWithoutInviteQueueInput>
  }

  export type VibeCreateWithoutInviteQueueInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coverMedia?: MediaCreateNestedOneWithoutCoverOfVibeInput
    createdBy: UserCreateNestedOneWithoutCreatedVibesInput
    contributors?: VibeContributorCreateNestedManyWithoutVibeInput
    media?: MediaCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerCreateNestedManyWithoutVibeInput
    drafts?: DraftCreateNestedManyWithoutVibeInput
    invites?: VibeInviteCreateNestedManyWithoutVibeInput
    notifications?: NotificationCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheCreateNestedManyWithoutVibeInput
  }

  export type VibeUncheckedCreateWithoutInviteQueueInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    createdById: string
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributors?: VibeContributorUncheckedCreateNestedManyWithoutVibeInput
    media?: MediaUncheckedCreateNestedManyWithoutVibeInput
    viewers?: VibeViewerUncheckedCreateNestedManyWithoutVibeInput
    drafts?: DraftUncheckedCreateNestedManyWithoutVibeInput
    invites?: VibeInviteUncheckedCreateNestedManyWithoutVibeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVibeInput
    feedEvents?: FeedEventUncheckedCreateNestedManyWithoutVibeInput
    cityFeedCache?: CityFeedCacheUncheckedCreateNestedManyWithoutVibeInput
  }

  export type VibeCreateOrConnectWithoutInviteQueueInput = {
    where: VibeWhereUniqueInput
    create: XOR<VibeCreateWithoutInviteQueueInput, VibeUncheckedCreateWithoutInviteQueueInput>
  }

  export type UserUpsertWithoutInviteQueueInput = {
    update: XOR<UserUpdateWithoutInviteQueueInput, UserUncheckedUpdateWithoutInviteQueueInput>
    create: XOR<UserCreateWithoutInviteQueueInput, UserUncheckedCreateWithoutInviteQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInviteQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInviteQueueInput, UserUncheckedUpdateWithoutInviteQueueInput>
  }

  export type UserUpdateWithoutInviteQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedBy?: UserUpdateOneWithoutInvitedUsersNestedInput
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInviteQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type VibeUpsertWithoutInviteQueueInput = {
    update: XOR<VibeUpdateWithoutInviteQueueInput, VibeUncheckedUpdateWithoutInviteQueueInput>
    create: XOR<VibeCreateWithoutInviteQueueInput, VibeUncheckedCreateWithoutInviteQueueInput>
    where?: VibeWhereInput
  }

  export type VibeUpdateToOneWithWhereWithoutInviteQueueInput = {
    where?: VibeWhereInput
    data: XOR<VibeUpdateWithoutInviteQueueInput, VibeUncheckedUpdateWithoutInviteQueueInput>
  }

  export type VibeUpdateWithoutInviteQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedVibesNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutInviteQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type UserCreateManyInvitedByInput = {
    id?: string
    username: string
    phoneNumber?: string | null
    email?: string | null
    passwordHash?: string | null
    name?: string | null
    bio?: string | null
    city?: string | null
    profilePicture?: string | null
    timeZone?: string | null
    joinedAt?: Date | string
    inviteCode?: string | null
    isDeleted?: boolean
    firebaseUid?: string | null
  }

  export type VibeCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    location?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    coverMediaId?: string | null
    isShared?: boolean
    status: string
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VibeContributorCreateManyUserInput = {
    id?: string
    vibeId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type MediaCreateManyUploadedByInput = {
    id?: string
    vibeId: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VibeViewerCreateManyViewerInput = {
    id?: string
    vibeId: string
    viewedAt?: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    mediaId: string
    favoritedAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    recipientId: string
    type: string
    message?: string | null
    vibeId?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type DraftCreateManyUserInput = {
    id?: string
    vibeId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VibeInviteCreateManyInvitedUserInput = {
    id?: string
    vibeId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type VibeInviteCreateManyInvitedByInput = {
    id?: string
    vibeId: string
    invitedUserId: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type SuggestedUserCreateManyUserInput = {
    id?: string
    suggestedUserId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SuggestedUserCreateManySuggestedUserInput = {
    id?: string
    userId: string
    reason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type FeedEventCreateManyUserInput = {
    id?: string
    eventType: string
    vibeId?: string | null
    createdAt?: Date | string
  }

  export type InviteQueueCreateManyUserInput = {
    id?: string
    vibeId: string
    invitedAt?: Date | string
  }

  export type MediaFlagCreateManyFlaggedByInput = {
    id?: string
    mediaId: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type UserUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    drafts?: DraftUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    invitedUsers?: UserUncheckedUpdateManyWithoutInvitedByNestedInput
    createdVibes?: VibeUncheckedUpdateManyWithoutCreatedByNestedInput
    contributedVibes?: VibeContributorUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    vibeViews?: VibeViewerUncheckedUpdateManyWithoutViewerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutUserNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutInvitedUserNestedInput
    sentInvites?: VibeInviteUncheckedUpdateManyWithoutInvitedByNestedInput
    suggestedTo?: SuggestedUserUncheckedUpdateManyWithoutUserNestedInput
    suggestedFrom?: SuggestedUserUncheckedUpdateManyWithoutSuggestedUserNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutUserNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutUserNestedInput
    flaggedMedia?: MediaFlagUncheckedUpdateManyWithoutFlaggedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    timeZone?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    firebaseUid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VibeUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverMedia?: MediaUpdateOneWithoutCoverOfVibeNestedInput
    contributors?: VibeContributorUpdateManyWithoutVibeNestedInput
    media?: MediaUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUpdateManyWithoutVibeNestedInput
    drafts?: DraftUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributors?: VibeContributorUncheckedUpdateManyWithoutVibeNestedInput
    media?: MediaUncheckedUpdateManyWithoutVibeNestedInput
    viewers?: VibeViewerUncheckedUpdateManyWithoutVibeNestedInput
    drafts?: DraftUncheckedUpdateManyWithoutVibeNestedInput
    invites?: VibeInviteUncheckedUpdateManyWithoutVibeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVibeNestedInput
    feedEvents?: FeedEventUncheckedUpdateManyWithoutVibeNestedInput
    cityFeedCache?: CityFeedCacheUncheckedUpdateManyWithoutVibeNestedInput
    inviteQueue?: InviteQueueUncheckedUpdateManyWithoutVibeNestedInput
  }

  export type VibeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coverMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeContributorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutContributorsNestedInput
  }

  export type VibeContributorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeContributorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutViewersNestedInput
  }

  export type VibeViewerUncheckedUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerUncheckedUpdateManyWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
    vibe?: VibeUpdateOneWithoutNotificationsNestedInput
    media?: MediaUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    vibe?: VibeUpdateOneWithoutNotificationsNestedInput
    media?: MediaUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type DraftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DraftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutInvitesNestedInput
    invitedBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
  }

  export type VibeInviteUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vibe?: VibeUpdateOneRequiredWithoutInvitesNestedInput
    invitedUser?: UserUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type VibeInviteUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suggestedUser?: UserUpdateOneRequiredWithoutSuggestedFromNestedInput
  }

  export type SuggestedUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserUpdateWithoutSuggestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSuggestedToNestedInput
  }

  export type SuggestedUserUncheckedUpdateWithoutSuggestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestedUserUncheckedUpdateManyWithoutSuggestedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneWithoutFeedEventsNestedInput
  }

  export type FeedEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vibe?: VibeUpdateOneRequiredWithoutInviteQueueNestedInput
  }

  export type InviteQueueUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vibeId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagUpdateWithoutFlaggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutFlagsNestedInput
  }

  export type MediaFlagUncheckedUpdateWithoutFlaggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagUncheckedUpdateManyWithoutFlaggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeContributorCreateManyVibeInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    hasUploaded?: boolean
    leftAt?: Date | string | null
  }

  export type MediaCreateManyVibeInput = {
    id?: string
    uploadedById: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    timestamp?: Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VibeViewerCreateManyVibeInput = {
    id?: string
    viewerId: string
    viewedAt?: Date | string
  }

  export type DraftCreateManyVibeInput = {
    id?: string
    userId: string
    lastEditedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type VibeInviteCreateManyVibeInput = {
    id?: string
    invitedUserId: string
    invitedById: string
    status: string
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type NotificationCreateManyVibeInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    mediaId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type FeedEventCreateManyVibeInput = {
    id?: string
    userId: string
    eventType: string
    createdAt?: Date | string
  }

  export type CityFeedCacheCreateManyVibeInput = {
    id?: string
    city: string
    cachedAt?: Date | string
  }

  export type InviteQueueCreateManyVibeInput = {
    id?: string
    userId: string
    invitedAt?: Date | string
  }

  export type VibeContributorUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutContributedVibesNestedInput
  }

  export type VibeContributorUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeContributorUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUploaded?: BoolFieldUpdateOperationsInput | boolean
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    favoritedBy?: FavoriteUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritedBy?: FavoriteUncheckedUpdateManyWithoutMediaNestedInput
    coverOfVibe?: VibeUncheckedUpdateOneWithoutCoverMediaNestedInput
    flags?: MediaFlagUncheckedUpdateManyWithoutMediaNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exifData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewer?: UserUpdateOneRequiredWithoutVibeViewsNestedInput
  }

  export type VibeViewerUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VibeViewerUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDraftsNestedInput
  }

  export type DraftUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DraftUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedUser?: UserUpdateOneRequiredWithoutInvitesNestedInput
    invitedBy?: UserUpdateOneRequiredWithoutSentInvitesNestedInput
  }

  export type VibeInviteUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VibeInviteUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedUserId?: StringFieldUpdateOperationsInput | string
    invitedById?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
    media?: MediaUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedEventsNestedInput
  }

  export type FeedEventUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedEventUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityFeedCacheUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityFeedCacheUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityFeedCacheUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInviteQueueNestedInput
  }

  export type InviteQueueUncheckedUpdateWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteQueueUncheckedUpdateManyWithoutVibeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyMediaInput = {
    id?: string
    userId: string
    favoritedAt?: Date | string
  }

  export type MediaFlagCreateManyMediaInput = {
    id?: string
    flaggedById: string
    reason: string
    additionalInfo?: string | null
    flaggedAt?: Date | string
  }

  export type NotificationCreateManyMediaInput = {
    id?: string
    recipientId: string
    senderId: string
    type: string
    message?: string | null
    vibeId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type FavoriteUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    favoritedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flaggedBy?: UserUpdateOneRequiredWithoutFlaggedMediaNestedInput
  }

  export type MediaFlagUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    flaggedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFlagUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    flaggedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneRequiredWithoutSentNotificationsNestedInput
    vibe?: VibeUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    vibeId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VibeCountOutputTypeDefaultArgs instead
     */
    export type VibeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VibeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VibeDefaultArgs instead
     */
    export type VibeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VibeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VibeContributorDefaultArgs instead
     */
    export type VibeContributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VibeContributorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VibeViewerDefaultArgs instead
     */
    export type VibeViewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VibeViewerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavoriteDefaultArgs instead
     */
    export type FavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavoriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DraftDefaultArgs instead
     */
    export type DraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DraftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VibeInviteDefaultArgs instead
     */
    export type VibeInviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VibeInviteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaFlagDefaultArgs instead
     */
    export type MediaFlagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaFlagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedEventDefaultArgs instead
     */
    export type FeedEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuggestedUserDefaultArgs instead
     */
    export type SuggestedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuggestedUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityFeedCacheDefaultArgs instead
     */
    export type CityFeedCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityFeedCacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteQueueDefaultArgs instead
     */
    export type InviteQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}